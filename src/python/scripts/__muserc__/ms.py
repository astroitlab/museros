# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ms', [dirname(__file__)])
        except ImportError:
            import _ms
            return _ms
        if fp is not None:
            try:
                _mod = imp.load_module('_ms', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ms = swig_import_helper()
    del swig_import_helper
else:
    import _ms
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class ms(_object):
    """Proxy of C++ casac::ms class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ms, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ms, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> ms"""
        this = _ms.new_ms()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ms.delete_ms
    __del__ = lambda self : None;
    def fromfits(self, *args, **kwargs):
        """
        fromfits(self, msfile=string(""), fitsfile=string(""), nomodify=True, lock=False, obstype=0, host=string(""), 
            forcenewserver=False, antnamescheme=string("old")) -> bool

        Summary
        	Create a measurement set from a uvfits file

        Description
        	
            This function will convert a \uvfits\ file to a measurement set table and
            then open the measurement set table. The newly created measurement set
            table will continue to exist after the tool has been closed.

            Setting the lock argument to True will permanently lock the table
            preventing other processes from writing to the measurement set. Unless you
            expect this to happen, and want to prevent it, you should leave the lock
            argument at the default value which implies auto-locking.



            Note that the variety of fits files that fromfits is able to
            interpret correctly is limited mostly to files similar to those
            produced by classic AIPS. In particular, it understands only binary
            table extensions for the antenna (AN), frequency (FQ) and source
            (SU) information and ignores other extensions.

            This function returns True if it successfully attachs the ms tool
            to a newly created Measurement Set or False if something went
            wrong, like an error in a file name.
          

        Input Parameters:
        	msfile		 Filename for the newly created measurement set 
        	fitsfile	 uvfits file to read 
        	nomodify	 open for read access only true 
        	lock		 lock the table for exclusive use false 
        	obstype		 specify the observation type: 0=standard, 1=fastmosaic, requiring small tiles in the measurement set 0 
        	host		 host to start ms tool on (IGNORED!!!) 
        	forcenewserver	 start a new server tool (IGNORED!!!) false 
        	antnamescheme	 For VLA only, antenna name scheme, old style is just antenna number, new style prepends VA or EV old old new 
        	
        Example:
        	
            
              ms.fromfits('3C273XC1.MS', '3C273XC1.fits')
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_fromfits(self, *args, **kwargs)

    def fromfitsidi(self, *args, **kwargs):
        """
        fromfitsidi(self, msfile=string(""), fitsfile=string(""), nomodify=True, lock=False, obstype=0) -> bool

        Summary
        	Create a measurement set from a fits-idi file

        Description
        	
            This function will convert a \uvfits\ file to a measurement set table and
            then open the measurement set table. The newly created measurement set
            table will continue to exist after the tool has been closed.

            Setting the lock argument to True will permanently lock the table
            preventing other processes from writing to the measurement set. Unless you
            expect this to happen, and want to prevent it, you should leave the lock
            argument at the default value which implies auto-locking.

            Note that the variety of fits files that fromfits is able to
            interpret correctly is limited mostly to files similar to those
            produced by classic AIPS. In particular, it understands only binary
            table extensions for the antenna (AN), frequency (FQ) and source
            (SU) information and ignores other extensions.

            This function returns True if it successfully attachs the ms tool
            to a newly created Measurement Set or False if something went
            wrong, like an error in a file name.
          

        Input Parameters:
        	msfile		 Filename for the newly created measurement set 
        	fitsfile	 fits-idi file to read 
        	nomodify	 open for read access only true 
        	lock		 lock the table for exclusive use false 
        	obstype		 specify the observation type: 0=standard, 1=fastmosaic, requiring small tiles in the measurement set 0 
        	
        Example:
        	
            
              ms.fromfits('3C273XC1.MS', '3C273XC1.fits')
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_fromfitsidi(self, *args, **kwargs)

    def listfits(self, *args, **kwargs):
        """
        listfits(self, fitsfile) -> bool

        Summary
        	
                

        Description
        	
                

        Input Parameters:
        	fitsfile	 list HDU and typical data rows in a uvfits file 
        	
        Example:
        	
                    ms.listfits('ngc5921.fits')
                
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_listfits(self, *args, **kwargs)

    def createmultims(self, *args, **kwargs):
        """
        createmultims(self, outputTableName, tables, subtables, nomodify=True, lock=False, copysubtables=False, 
            omitsubtables=std::vector< string >(1, "")) -> bool

        Summary
        	
                

        Description
        	
                

        Input Parameters:
        	outputTableName	
        	tables		
        	subtables	
        	nomodify	 prevent changes to the measurement set true 
        	lock		 lock the table for exclusive use by this tool false 
        	copysubtables	 copy the subtables from the first to all other member MSs false 
        	omitsubtables	 Omit the subtables from this list when copying subtables 
        	
        Example:
        	
                
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_createmultims(self, *args, **kwargs)

    def ismultims(self):
        """
        ismultims(self) -> bool

        Summary
        	
                

        Description
        	
                
        Example:
        	
                
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_ismultims(self)

    def getreferencedtables(self):
        """
        getreferencedtables(self) -> std::vector< std::string >

        Summary
        	
                

        Description
        	
                
        Example:
        	
                
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_getreferencedtables(self)

    def getfielddirmeas(self, *args, **kwargs):
        """
        getfielddirmeas(self, dircolname=string("PHASE_DIR"), fieldid=0, time=0, format=string("measure")) -> variant *

        Summary
        	Returns the direction measure from the given FIELD table column and row

        Description
        	
            This function returns the direction measures from the
            given direction column of the MS FIELD table as a either a measure dictionary
            or sexigesimal string representation.
          

        Input Parameters:
        	dircolname	 Name of the direction column in the FIELD table PHASE\_DIR PHASE\_DIR DELAY\_DIR REFERENCE\_DIR 
        	fieldid		 Field ID, starting at 0 0 
        	time		 (optional) time for ephemeris access (in seconds, as in Main table TIME column) 0 
        	format		 Output format. Either 'measure' (measure dictionary) or 'string' (sexigesimal representation). Minimum match supported. measure 
        	
        Example:
        	
            
              ms.open('3C273XC1.MS')
              print 'Delay direction from FIELD table row 3 =', ms.getfielddirmeas('DELAY_DIR', 3)
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_getfielddirmeas(self, *args, **kwargs)

    def nrow(self, selected=False):
        """
        nrow(self, selected=False) -> int

        Summary
        	Returns the number of rows in the measurement set

        Description
        	
            This function returns the number of rows in the measurement
            set. If the optional argument selected is set to True, it returns
            the number of currently selected rows, otherwise it returns the 
            the number of rows in the original measurement.
          

        Input Parameters:
        	selected	 return number of selected rows false 
        	
        Example:
        	
            
              ms.open('3C273XC1.MS')
              print 'Number of rows in ms =', ms.nrow()
              #Number of rows in ms = 7669
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_nrow(self, selected)

    def iswritable(self):
        """
        iswritable(self) -> bool

        Summary
        	Returns True is the underlying Table is
          writable

        Description
        	
            This function returns True if the underlying MeasurementSet
          Table was opened for writing/update.
          
        Example:
        	
            
              ms.open('3C273XC1.MS',nomodify=False)
              if ms.iswritable():
                print 'MeasurementSet is writable'
              else:
                print 'MeasurementSet is readonly'
              #MeasurementSet is writable
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_iswritable(self)

    def open(self, *args, **kwargs):
        """
        open(self, thems=string(""), nomodify=True, lock=False) -> bool

        Summary
        	Attach the ms tool to a measurement set table

        Description
        	
               Use this function when you have detached (using the
               close function) the ms tool from a
               measurement set table and wish to reattach to another measurement
               set table.  
             

        Input Parameters:
        	thems		 Name of the measurement set table to open 
        	nomodify	 prevent changes to the measurement set true 
        	lock		 lock the table for exclusive use by this tool false 
        	
        Example:
        	
            
               ms.open('3C273XC1.MS')
               ms.close()
               ms.open('anotherms', nomodify=False, lock=False)
            
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_open(self, *args, **kwargs)

    def reset(self):
        """
        reset(self) -> bool

        Summary
        	Re-attach the tool to the original MS.

        Description
        	
               This function re-attaches the ms tool to the original MS,
               effectively discarding any prior operations, in particular any
               data selection operations
               using msselect
               function.
             
        Example:
        	
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_reset(self)

    def close(self):
        """
        close(self) -> bool

        Summary
        	Detach the ms tool from the measurement set table

        Description
        	
               This function detaches the ms tool from the associated measurement
               set table after flushing all the cached changes.  After calling
               this function the ms tool is not associated with any measurement
               set and using any function other than
               open or
               fromfits
               will result in an error message being sent to the logger.

               This function can be useful to avoid synchronization problems
               which can occur when different processes have the same ms open.
             
        Example:
        	
               See the example for the open function.
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_close(self)

    def name(self):
        """
        name(self) -> string

        Summary
        	Name of the measurement set table the tool is attached to.

        Description
        	
            This function returns the name of the measurement set table that
            is being manipulated. If the ms tool is not attached to any
            measurement set then this function will return the string ``none''.
          
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              print 'Processing file', ms.name()
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_name(self)

    def tofits(self, *args, **kwargs):
        """
        tofits(self, fitsfile=string(""), column=string("corrected"), field=initialize_variant(""), spw=initialize_variant(""), 
            width=1, baseline=initialize_variant(""), time=string(""), 
            scan=initialize_variant(""), uvrange=initialize_variant(""), taql=string(""), 
            writesyscal=False, multisource=False, combinespw=False, writestation=False, 
            padwithflags=False) -> bool

        Summary
        	Convert a measurement set to a uvfits file

        Description
        	
            This function writes a \uvfits\ file that contains the data in
            the measurement set associated with this tool. The its\ file is
            always written in floating point format and the data are always
            stored in the primary array of the its\ file.

            If the measurement set has been imaged or calibrated in CASA, it
            may contain additional data columns. You need to select ONE of
            these columns to be written to the its\ file. The possible
            options are:
            egin{description}
              \item[observed] This is the raw data as collected by the
                              telescope. All interferometric measurement sets must
                              contain this column. A synonym for 'observed' is
                              'data'.
              \item[corrected] This is the calibrated data. A synonym for
                               'corrected' is 'corrected\_data'.
              \item[model] This is the visibilites that would be measured using
                           the current model of the sky. A synonym for
                           'model' is 'model\_data'.
            nd{description}
            The parsing of these strings is case insensitive. If any other
            option is specified then the observed data will be written.

            By default a single-source \uvfits\ file is written, but if the
            measurement set contains more than one field or if you set the
            multisource argument to True a multi-source \uvfits\ file will be
            written. Because of limitations in the \uvfits\ format you have to
            ensure that the data shape is fixed for all the data you intend to
            write to one its\ file. See the general description of this tool
            for how you can select data to meet this condition.

            The combinespw argument is used to control whether data from
            different spectral windows will be written as different entries in
            the its\ FQ (frequency) table or combined as different IF's
            within one entry in the FQ table. You should normally only set
            this to True if you know that the data from different spectral
            windows were observed simultaneously, and the data in the
            measurement set can be equally divided between all the spectral
            windows (i.e.\ each window should have the same width).  Use of
            this switch is recommended for data to be processed in classic
            AIPS and difmap (if possible, e.g., standard dual IF observations).

            The padwithflags argument is only relevant if combinespw is True.
            If true, it will fill in data that is 'missing' with flags to fit
            the IF structure.  This is appropriate if the MS had a few
            frequency-dependent flags applied, and was then time-averaged by
            split.  If the spectral windows were observed at different times,
            padwithflags=True will add a large number of flags, making the 
            output file significantly longer.  It does not yet support spectral
            windows with different widths.

            The its\ GC (gain curve) and TY (system temperature) tables can
            be optionally written by setting the writesyscal argument to True.
            This is a rather WSRT-specific operation at the moment and may not
            work correctly for measurement sets from other telescopes.

            The width argument is for channel averaging while outputing the 
            data to the fits file. The default values of 1 will copy the 
            channels of the input as is. The start channel number is the 
            first channel of the spw expression. The number of output channels
            is determined by spw expression and the width. The width is the 
            number of channels of the input data to make 1 channel of the output data. 
          

        Input Parameters:
        	fitsfile	 Name of the new uvfits file 
        	column		 Data column to write, see above for options corrected 
        	field		 Field ids (0-based) or fieldnames to split out 
        	spw		 Spectral windows to split 
        	width		 number of input channels to average 1 
        	baseline	 Antenna names or Antenna indices to select 
        	time		 Limit data selected to be within a given time range. Syntax is the defined in the msselection link 
        	scan		 Limit data selected on scan numbers. Syntax is the defined in the msselection link 
        	uvrange		 Limit data selected on uv distance. Syntax is the defined in the msselection link 
        	taql		 For the TAQL experts, flexible data selection using the TAQL syntax 
        	writesyscal	 Write GC and TY tables false 
        	multisource	 Write in multisource format false 
        	combinespw	 Export spectral windows as IFs false 
        	writestation	 Write station name instead of antenna name false 
        	padwithflags	 If combinespw==True, pad data with flags to fit IFs false 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              ms.tofits('3C273XC1.fits', column='DATA'); 
              ms.done()
            
             This example writes  the observed data of a measurement set to a 
             \uvfits\ file.

              
              ms.open('big.ms')
              ms.tofits('part.fits', column='CORRECTED', field=[0,1], spw=[2]); 
              ms.done()
            
             This example writes part (the first 2 fields and the third spectral 
             window) of the corrected data to the fits file.  
            

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_tofits(self, *args, **kwargs)

    def summary(self, *args, **kwargs):
        """
        summary(self, verbose=False, listfile=string(""), listunfl=False, cachesize=50, overwrite=False) -> record *

        Summary
        	(PARTIALLY IMPLEMENTED!!!) Summarize the measurement set

        Description
        	
            This method will print a summary of the measurement set to the
            system logger. The verbose argument provides some control on how
            much information is displayed.

            For especially large datasets, the cachesize parameter can be increased for possibly better
            performance.

            This method can also return, in the header argument, a record
            containing the following fields.
            egin{description}
              \item[nrow]       Number of rows in the measurement set
              \item[name]       Name of the measurement set
            nd{description}
            
            DESCRIPTION OF ALGORITHM TO CALCULATE THE NUMBER OF UNFLAGGED ROWS
            The number of unflagged rows will only be computed if listunflis True.
            The number of unflagged rows (the nUnflRows columns in the scans and fields portions of the listing) is
            calculated by summing the fractional unflagged bandwidth for each row (and hence why the number of unflagged
            rows, in general, is not an integer). Thus a row which has half of its
            total bandwidth flagged contributes 0.5 rows to the unflagged row count. A row with 20 of 32 channels of
            homogeneous width contributes 20/32 = 0.625 rows to the unflagged row count. A row with a value of False
            in the FLAG\_ROW column is not counted in the number of unflagged rows.
          

        Input Parameters:
        	verbose		 Produce verbose logging output false 
        	listfile	 Output file 
        	listunfl	 List unflagged row counts? If true, it can have significant negative performance impact. false 
        	cachesize	 EXPERIMENTAL. Maximum size in megabytes of cache in which data structures can be held. 50 
        	overwrite	 If True, tacitly overwrite listfile if it exists. false 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              outr=ms.summary(verbose=True)
              ###print the begining of observation in this ms
              print qa.time(qa.quantity(outr['header']['BeginTime'],'d'), form='ymd')
              ###print  a dictionary of the info of scan 1
              outr['header']['scan_1']
            
            This example will send a verbose summary of the measurement
            set to the logger.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_summary(self, *args, **kwargs)

    def getscansummary(self):
        """
        getscansummary(self) -> record *

        Summary
        	Get the summary of the ms

        Description
        	
            This function will return a summary of the main table as a structure
          
        Example:
        	
            ms.open('3C273XC1.MS')
            scanInfo = ms.getscansummary()
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_getscansummary(self)

    def getspectralwindowinfo(self):
        """
        getspectralwindowinfo(self) -> record *

        Summary
        	Get a summary of the spectral windows

        Description
        	
            This method will get a summary of the spectral window actually
            used in this ms. To be precise those reference by the data
            description table.
          
        Example:
        	
            ms.open('3C273XC1.MS')
            spwInfo = ms.getspectralwindowinfo()
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_getspectralwindowinfo(self)

    def listhistory(self):
        """
        listhistory(self) -> bool

        Summary
        	List history of the measurement set

        Description
        	
            This function lists the contents of the measurement set history
            table.
          
        Example:
        	
            
              ms.open('3C273XC1.MS')
              ms.listhistory()
            
            The history table contents are listed in the logger.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_listhistory(self)

    def writehistory(self, *args, **kwargs):
        """
        writehistory(self, message=string(""), parms=string(""), origin=string("MSHistoryHandler::addMessage()"), 
            msname=string(""), app=string("ms")) -> bool

        Summary
        	Add a row of arbitrary information to the measurement set history table

        Description
        	
            This function adds a row to the history table of the specified
            measurement set containing any message that the user wishes to
            record.  By default the history entry is written to the history
            table of the measurement set that is currently open, the message
            origin is recorded as 'MSHistoryHandler::addMessage()', the originating
            application is 'ms' and the input parameters field is empty.
          

        Input Parameters:
        	message		 Message to be recorded in message field 
        	parms		 String to be written to input parameter field 
        	origin		 String to be written to origin field MSHistoryHandler::addMessage() 
        	msname		 name of selected measurement set 
        	app		 String to be written to application field ms 
        	
        Example:
        	
            
              ms.open('3C273XC1.MS')
              ms.writehistory('an arbitrary history message')
              ms.listhistory()
            
            A row is appended to the measurement set history table.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_writehistory(self, *args, **kwargs)

    def statistics(self, *args, **kwargs):
        """
        statistics(self, column=string(""), complex_value=string(""), useflags=True, spw=string(""), field=string(""), 
            baseline=string(""), uvrange=string(""), time=string(""), correlation=string(""), 
            scan=string(""), array=string(""), obs=string("")) -> record *

        Summary
        	Get statistics on the selected measurement set

        Description
        	
            This function computes descriptive statistics on the measurement set.
            It returns the statistical values as a python dictionary.  The given 
            column name must be a numerical column.
            If it is a complex valued column, the parameter complex\_value defines
            which derived real value is used for the statistics computation.
          

        Input Parameters:
        	column		 Column name 
        	complex_value	 Which derived value to use for complex columns (amp, amplitude, phase, imag, real, imaginary) 
        	useflags	 Use the data flags true 
        	spw		 Spectral Window Indices or names : example : '1,2' 
        	field		 Field indices or source names : example : '2,3C48' 
        	baseline	 Baseline number(s): example: '2\&3;4\&5' 
        	uvrange		 UV-distance range, with a unit : example : '2.0-3000.0 m' 
        	time		 Time range, as MJDs or date strings : example : 'xx.x.x.x.x~yy.y.y.y.y' 
        	correlation	 Correlations/polarizations : example : 'RR,LL,RL,LR,XX,YY,XY,YX' 
        	scan		 Scan number : example : '1,2,3' 
        	array		 Array Indices or names : example : 'VLAA' 
        	obs		 Observation ID(s): examples : '' or '1~3' 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              ms.statistics(column='DATA', antenna='2')
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_statistics(self, *args, **kwargs)

    def range(self, *args, **kwargs):
        """
        range(self, items=std::vector< string >(1, ""), useflags=True, blocksize=10) -> record *

        Summary
        	Get the range of values in the measurement set

        Description
        	
            This function will return the range of values in the currently
            selected measurement set for the items specified.  Possible items
            include most scalar columns, interferometer number
            (1000*antenna1+antenna2), uvdist(ance), u, v, w, amplitude, phase,
            real and imaginary components of the data (and corrected and model
            versions of these - if these columns are present). See the table
            at the top of the document to find the exact list.

            You specify items in which you are interested using a string
            vector where each element is a case insensitive item name.  This
            function will then return a record that has fields corresponding
            to each of the specified items. Each field will contain the range
            of the specified item. For many items the range will be the
            minimum and maximum values but for some it will be a list of
            unique values. Unrecognized items are ignored.
            
            By default the FLAG column is used to exclude flagged data before
            any ranges are determined, but you can set useflags=False to include
            flagged data in the range.  However, if you average in frequency, 
            flagging will still be applied.

            You can influence the memory use and the reading speed using 
            the blocksize argument - it specifies how big a block of data
            to read at once (in MB). For large datasets on machines with lots
            of memory you may speed things up by setting this higher than the
            default (10 MB).

            For some items, as indicated with an \S\ in table
            ref{ms:tblItems} (in the general description of this tool), you
            need to call selectinit to select a portion of the data with a
            unique shape prior to calling this function.

            Items prefixed with corrected, model, residual or
            obs\_residual and the imaging\_weight item are not available unless
            your measurement set has been processed either with the imager or
            calibrator tools.
          

        Input Parameters:
        	items		 Item names 
        	useflags	 Use the data flags true 
        	blocksize	 Set the blocksize in MB 10 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              ms.selectinit(datadescid=0)
              ms.range(['time','uvdist','amplitude','antenna1'])
        #{'amplitude': array([  2.60339398e-02,   3.38518333e+01]),
        # 'antenna1': array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 11, 12, 13,
        #                    14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]),
        # 'time': array([  4.12162940e+09,   4.12164267e+09]),
        # 'uvdist': array([   46.26912101,  3727.97385983])}
            
            In this example the minimum and maximum observation times,
            uvdistances, data amplitudes are returned as well as a list of all the
            antennas in the antenna1 column. 

            For this dataset the selectinit function did not need to be
            called as all the data is of one shape.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_range(self, *args, **kwargs)

    def lister(self, *args, **kwargs):
        """
        lister(self, options=string(""), datacolumn=string("data"), field=string(""), spw=string(""), 
            antenna=string(""), timerange=string(""), correlation=string(""), scan=string(""), 
            feed=string(""), array=string(""), observation=string(""), uvrange=string(""), 
            average=string(""), showflags=False, msselect=string(""), pagerows=50, 
            listfile=string("")) -> bool

        Summary
        	List measurement set visibilities

        Description
        	

        This tool lists measurement set visibility data under a number of
        input selection conditions.  The measurement set data columns that
        can be listed are: the raw data, corrected data, model data, and
        residual (corrected - model) data.

        The output table format is dynamic.  Field, Spectral Window, and
        Channel columns are not displayed if the column contents are uniform.
        For example, if ``spw = `1' '' is specified, the spw column will not be
        displayed.  When a column is not displayed, a message is sent to the
        logger and terminal indicating that the column values are uniform and
        listing the uniform value.

        Table column descriptions:

        egin{tabular}{ll}
        \hline\hline
        Column Name \& Description \
        \hline
        Date/Time   \& Average date and time of data sample interval \
        Intrf       \& Interferometer baseline (antenna names) \
        UVDist      \& uv-distance (units of wavelength) \
        Fld         \& Field ID \
        SpW         \& Spectral Window ID \
        Chn         \& Channel number \
        (Correlated \& Correlated polarizations (eg: RR, LL, XY) \
          polarization) \&   Sub-columns are: Amp, Phs, Wt, F \
        Amp         \& Visibility amplitude \
        Phs         \& Visibility phase \
        Wt          \& Weight of visibility measurement \
        F           \& Flag: `F' = flagged datum; ` ' = unflagged \
        \hline\hline
        nd{tabular}
          
          

        Input Parameters:
        	options		 Output options (not yet implemented) 
        	datacolumn	 Column to list: data, model, corrected, residual data 
        	field		 Fields 
        	spw		 Spectral Windows 
        	antenna		 Antenna/Baselines 
        	timerange	 Time range 
        	correlation	 Polarization correlations 
        	scan		 Scan 
        	feed		 Feed (not yet implemented) 
        	array		 Array 
        	observation	 Select by observation ID(s) 
        	uvrange		 uv-distance (output units: wavelength) 
        	average		 Average mode (not yet implemented) 
        	showflags	 Showflags (not yet implemented) false 
        	msselect	 TaQL expression 
        	pagerows	 Rows per page 50 
        	listfile	 Output file 
        	
        Example:
        	

            
              ms.open('AZ136.ms')
              ms.lister()
            
            These commands yeild the following listing: 
            
        Date/Time:                         RR:                      RL:                      LR:                      LL:                     
        2001/12/01/  Intrf UVDist Fld SpW      Amp   Phs       Wt F     Amp   Phs       Wt F     Amp   Phs       Wt F     Amp   Phs       Wt F
        ------------|-----|------|---|---|-------------------------|------------------------|------------------------|------------------------
          19:30:05.0  0- 1   1400   0   0:   0.002-102.7   229035 F   0.003-178.3   239694 F   0.001 136.0   208264 F   0.001 -79.7   263599 F
          19:30:05.0  0- 2   7203   0   0:   0.002 127.3   267464 F   0.001 165.0   305192 F   0.003-118.2   265174 F   0.002  16.3   307829 F
          19:30:05.0  0- 3   9621   0   0:   0.002 -55.9   179652 F   0.002 -27.1   230130 F   0.001 -94.9   199954 F   0.003 -89.3   206764 F
          19:30:05.0  0- 4   1656   0   0:   0.001 133.3   199677 F   0.002  80.6   258140 F   0.001 -35.1   224291 F   0.003  23.9   229812 F
          19:30:05.0  0- 5   3084   0   0:   0.002 -18.4   197565 F   0.001 -83.1   228541 F   0.002 -85.1   198574 F   0.002 -28.5   227381 F
          19:30:05.0  0- 6   5020   0   0:   0.001-173.2   236475 F   0.002-104.0   257575 F   0.000   0.0   223800 F   0.000-142.5   272162 F
          19:30:05.0  0- 7  12266   0   0:   0.003 -34.6   264977 F   0.002   5.3   280113 F   0.001-152.7   243383 F   0.002 -78.8   304966 F
            .  
            .  
            .  
            

            Notice that the channel column is not displayed.  This measurement set
            contains only one channel; since the channel column values are uniform,
            the channel column is not displayed.  Instead, message 
            'All selected data has CHANNEL = 0' is sent to the console.

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_lister(self, *args, **kwargs)

    def metadata(self, cachesize=50):
        """
        metadata(self, cachesize=50) -> casac::msmetadata *

        Summary
        	Get the MS metadata associated with this MS.

        Description
        	Get the MS metadata associated with this MS.

        Input Parameters:
        	cachesize	 Maximum cache size, in megabytes, to use. 50 
        	
        Example:
        	
                # get the number of spectral windows in the specified MS
                ms.open'my.ms')
                metadata = ms.metadata()
                ms.done()
                nspw = metadata.nspw()
                metadata.done()
            
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_metadata(self, cachesize)

    def selectinit(self, datadescid=0, reset=False):
        """
        selectinit(self, datadescid=0, reset=False) -> bool

        Summary
        	Initialize the selection of an ms

        Description
        	
            A measurement set can contain data with a variety of different
            shapes (as described in the overall description to this tool).  To
            allow functions to return data in fixed shape arrays you need to
            select, using this function, rows that contain the same data
            shape. You do not need to use this function if all the data in
            your measurement set has only one shape.

            The DATA\_DESC\_ID column in the measurement set contains a
            value that maps to a particular row in the POLARIZATION and
            SPECTRAL\_WINDOW subtables. Hence all rows with the same
            value in the DATA\_DESC\_ID column must have the same data
            shape. To select all the data where the DATA\_DESC\_ID value
            is $N$ you call this function with the datadescid argument set to
            $N$. 

            It is possible to have a measurement set with differing values in
            the DATA\_DESC\_ID column but where all the data is a fixed
            shape. For example this will occur if the reference frequency
            changes but the number of spectral channels is fixed. In cases
            like this all the data can be selected, using this function with
            an argument of zero.  If the data shape does change and you call
            this function with an datadescid set to zero  the return value will be False. In all other cases it will be
            True.

            To return to the completely unselected measurement set, set the
            reset argument to True. This will allow you to access the full
            range of rows in the measurement set, rather than just the
            selected measurement set.

            The datadescid must always be a non-negative integer.
          

        Input Parameters:
        	datadescid	 Data description id 0 
        	reset		 Reset to unselected state false 
        	
        Example:
        	
            
              ms.open('3C273XC1.MS')
              ms.selectinit(datadescid=0)
              print ms.range(['uvdist'])
              ms.selectinit(reset=True)
              print ms.range('uvdist')
            

            In this example we display the range of uv distances for the data
            in the specified measurement set. The first print statement will
            only use data where the DATA\_DESC\_ID column is 0. This will
            correspond to a specific spectral window and polarization
            setup. The second print statement will print the range of uv
            distances for all the data in the measurement set (which is the
            same in this case).

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_selectinit(self, datadescid, reset)

    def msselect(self, *args, **kwargs):
        """
        msselect(self, items=initialize_record(""), onlyparse=False) -> bool

        Summary
        	Use the MSSelection module for data selection.

        Description
        	
               A retun value of True implies that the combination of all selection expressions
               resulted in a non-Null combined TaQL expression. False implies
               that the combined TaQL could not be formed (i.e. it is Null,
               and the 'selected MS' will be the same as the input MS).

               The details of selection expressions are desribed in the
               MSSelection Memo.

               Note that this function can be called multiple times but the
               result is cumulative.  I.e. selection will work on the data
               already selected from all previous calls of this function.  Use
               the function reset() to reset all selections to NULL (original
               database).
             

        Input Parameters:
        	items		 Record with fields contain the selection experessions. Keys recognized in the record are: 'spw', 'time', 'field', 'baseline', 'scan', 'scanintent', 'polarization', 'observation', 'array', 'uvdist' and 'taql'. 
        	onlyparse	 If set to True, expressions will only be parsed but not applied to the MS for selection. When set to False, a selected MS will also be generated internally. Default is False. When only parsing is requested, the selected-MS is the same as the original MS. false 
        	
        Example:
        	
               CASA: staql={'field':'3C286', 'spw':'0~7:10~55'};
               CASA: ms.open(MSNAME);
               CASA: ms.msselect(staql, onlyparse=True); # For only getting the list
                                                         # of indices correspoding to the selection
               CASA: ndx=ms.msselectedindices();
               CASA: ndx['field']
                 Out[5]: array([1], dtype=int32)
                  :
                  :
               CASA: ms.msselect(staql);  # To do the actual selection.
                                          # From this point on, the ms-tool is
                                          # attached to the selected MS.
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_msselect(self, *args, **kwargs)

    def msselectedindices(self):
        """
        msselectedindices(self) -> record *

        Summary
        	
               Return the selected indices of the MS database.  The keys in
               the record are the same as those used in msselect function
               (i.e. 'spw', 'time', 'field', 'baseline', 'scan', 'scanintent',
               'polarization' and 'uvdist').
             

        Description
        	
               The return indices are the result of parsing the MSSelection
               expressions provided in
               the msselect
               function.
             
        Example:
        	
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_msselectedindices(self)

    def select(self, *args, **kwargs):
        """
        select(self, items=initialize_record("")) -> bool

        Summary
        	Select a subset of the measurement set.

        Description
        	
            This function will select a subset of the current measurement set
            based on the range of values for each field in the input
            record. The range function will return a record that can be
            altered and used as the argument for this function.  A successful
            selection returns True. Allowable fields are tabulated in
            table~ref{ms:tblItems} (in the general description of this
            tool). Unrecognized fields are ignored.

            You need to call selectinit before
            calling this function. If you haven't then selectinit will be
            called for you with default arguments.

            Repeated use of this function, with different arguments, will
            further refine the selection, resulting in a successively smaller
            selected measurement set. If the selected measurement set does not
            contain any rows then this function will return False and send a
            warning message in the logger. Otherwise this function will return
            True. To undo all the selections you need to use the selectinit
            function (with reset=True).
          

        Input Parameters:
        	items		 record with fields contain ranges and enumerations 
        	
        Example:
        	
            
              ms.open('3C273XC1.MS')
              ms.selectinit(datadescid=0)
              ms.select({'antenna1':[1,3,5],'uvdist':[1200.,1900.]})
              ms.select({'time':[4121629420.,4121638290.]})
              start = qa.getvalue(qa.convert(qa.quantity('1989/06/27/01:03:40'),'s'))
              stop = qa.getvalue(qa.convert(qa.quantity('1989/06/27/03:31:30'),'s'))
              rec = {}
              rec['time'] = [start, stop]
              ms.select(items=rec)
            
            This example selects all the data from the measurement set where
            the value in the DATA\_DESC\_ID column is zero. This
            corresponds to a particular spectral window and polarization
            setup. It then selects all the data where the first antenna in the
            interferometer is number one, three or five and where the uv
            distance is between 1200 and 1900 meters.  Finally it selects all
            the data which was observed between 4121629420 seconds and
            4121638290 seconds (since zero hours on the day where the modified
            Julian day is zero). Since this time in seconds is quite obscure I
            have also illustrated how to use the quanta tool to convert a
            date/time string into seconds which can then be used to perform
            the same time selection.

            The selections are cumulative so that at the end of this example
            only data in the specified time range, with the specified,
            interferometers, uv distances, spectral window and polarization
            setup are selected.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_select(self, *args, **kwargs)

    def selecttaql(self, *args, **kwargs):
        """
        selecttaql(self, msselect=string("")) -> bool

        Summary
        	Select a subset of the measurement set.

        Description
        	
            This function will select a subset of the current measurement set
            based on the standard TaQL selection string given.

            Repeated use of this function, with different arguments, will
            further refine the selection, resulting in a successively smaller
            selected measurement set. If the selected measurement set does not
            contain any rows then this function will return False and send a
            warning message in the logger. Otherwise this function will return
            True. To undo all the selections you need to use the selectinit
            function (with reset=True).
            Note that index values used in the TaQL string are zero-based
            as are all tool indices.

          

        Input Parameters:
        	msselect	 TaQL selection string 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              ms.selectinit(datadescid=0)
              ms.select({'antenna1':[0,2,4],'uvdist':[1200.,1900.]})
              ms.selecttaql('ANTENNA1==2')
              ms.range(['ANTENNA1','ANTENNA2'])
              # {'antenna1': array([2]),
              #  'antenna2': array([ 6,  9, 11, 18, 20, 21, 24])}
            
            This example selects all the data from the measurement set where
            the value in the DATA_DESC_ID column is zero. This
            corresponds to a particular spectral window and polarization
            setup. It then selects all the data where the first antenna in the
            interferometer is number zero, two or four and where the uv
            distance is between 1200 and 1900 meters.  Finally it uses a query
            to select all the data for which the ANTENNA1 column is 2 (this
            selects the middle antenna of the previous, zero-based, selection).
            The selections are cumulative so that at the end of this example
            only data in the specified time range, with the specified,
            interferometers, uv distances, spectral window and polarization
            setup are selected.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_selecttaql(self, *args, **kwargs)

    def selectchannel(self, nchan=1, start=0, width=1, inc=1):
        """
        selectchannel(self, nchan=1, start=0, width=1, inc=1) -> bool

        Summary
        	Select and average frequency channels

        Description
        	
            This function allows you to select a subset of the frequency
            channels in the current measurement set.  This function can also
            average, over frequency channels, prior to providing the values to
            the user.

            Selection on channels is not allowed using either the select or
            command functions as they can only select entire rows in a
            measurement set. Channel selection involves accessing only some of
            the values in a row. Like all the selection functions this
            function does not change the current measurement but updates the
            measurement set selection parameters so that functions like
            getdata will return the desired subset of the data.  Repeated use
            of this function will overwrite any previous channel
            selection.

            There are four parameters, the number of output channels, the
            first input channel to use, the number of input channels to
            average into one output channel, and the increment in the input
            spectrum for the next output channel. All four parameters need to
            be specified. 

            This function return True if the selection was successful, and False if
            not. In the latter case an error message will also be sent to the
            logger.

            You need to call selectinit before
            calling this function. If you haven't then selectinit will be
            called for you with default arguments.
          

        Input Parameters:
        	nchan		 Number of output channels, positive integer 1 
        	start		 First input channel to use, positive integer 0 
        	width		 Number of input channels to average together, positive integer 1 
        	inc		 Increment to next (group of) input channel(s), positive integer 1 
        	
        Example:
        	
            
              ms.fromfits('NGC5921.MS',
                          '/usr/lib/casapy/data/demo/NGC5921.fits')
              ms.selectinit(datadescid=0)
              ms.selectchannel(3,2,5,3)
            
            This example selects all the data from the measurement set where
            the value in the DATA_DESC_ID column is zero. This
            corresponds to a particular spectral window and polarization
            setup. It then selects on frequency channels to produce 3 output
            channels, the first output channel is the average of channels
            2,3,4,5,6 in the input, the second output channel is the average
            of channel 5,6,7,8,9 and the third is the average of channels
            8,9,10,11,12.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_selectchannel(self, nchan, start, width, inc)

    def selectpolarization(self, *args, **kwargs):
        """
        selectpolarization(self, wantedpol=std::vector< string >(1, "")) -> bool

        Summary
        	Selection and convertion of polarizations

        Description
        	
            This function allows you to select a subset of the polarizations
            in the current measurement set.  This function can also setup
            conversion to different polarization representations.

            You specify the polarizations using a string vector. Allowable
            strings are include I, Q, U, V, RR, RL, LR, LL, XX, YY, XY,
            YX. These string must be specified in upper case. If the
            polarizations match those present in the measurement set they will
            be selected directly, otherwise all polarizations are read and
            then a conversion step is done. If the conversion cannot be done
            then an error will be produced when you try to access the data.

            This function return True if the selection was successful, and False if
            not.

            You need to call selectinit before
            calling this function. If you haven't then selectinit will be
            called for you with default arguments.
          

        Input Parameters:
        	wantedpol	 The polarizations wanted 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              ms.selectinit(datadescid=0)
              ms.selectpolarization(['I','V'])
              rec = ms.getdata('data')
            
            This example selects all the data from the measurement set where
            the value in the DATA_DESC_ID column is zero. This
            corresponds to a particular spectral window and polarization
            setup. It then selects the I and V polarizations and when the
            getdata function is called the conversion from RR, LL, LR, RL
            polarizations to I and V occurs.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_selectpolarization(self, *args, **kwargs)

    def regridspw(self, *args, **kwargs):
        """
        regridspw(self, outframe=string("LSRK"), mode=string("chan"), restfreq=-3E30, interpolation=string("LINEAR"), 
            start=-3E30, center=-3E30, bandwidth=-1., chanwidth=-1., hanning=True) -> bool

        Summary
        	transform spectral data to different reference frame and/or regrid the frequency channels
           

        Description
        	
          This function permits you to transform the spectral data of your measurement set to a 
          given reference frame. The present reference frame information in the MS is examined and 
          the transformation performed accordingly. Since all such transformations are linear in 
          frequency, a pure change of reference frame only affects the channel boundary definitions.

          In addition, the function permits you to permanently regrid the data, i.e. reduce the 
          channel number and/or move the boundaries using several interpolation methods (selected 
          using parameter 'interpolation'). The new channels are equidistant in frequency 
          (if parameter 'mode' is chosen to be vrad or freq, or equidistant in
          wavelength if  parameter 'mode' is chosen to be vopt or wave).
          If 'mode' is chosen to be 'chan', the regridding is performed by combining
          the existing channels, i.e. not moving but just eliminating channel boundaries where
          necessary.

          The regridding is applied to the channel definition and all data of the MS, i.e. all 
          columns which contain arrays whose dimensions depend on the number of channels. 
          The input parameters are verified before any modification is made to the MS.

          The target reference frame can be set by providing the name of a standard reference 
          frame (LSRK, LSRD, BARY, GALACTO, LGROUP, CMB, TOPO, GEO, or SOURCE, default = no change of 
          frame) in parameter 'outframe'.
          For each field in the MS, the channel frequencies are transformed from their present 
          reference frame to the one given by parameter 'outframe'.

          If the regridding parameters are set, they are interpreted in the 'outframe' reference
          frame. The regridding is applied to the data after the reference frame transformation.

          

        Input Parameters:
        	outframe	 Name of the reference frame to transform to (LSRK, LSRD, BARY, GALACTO, LGROUP, CMB, GEO, TOPO, or SOURCE). SOURCE is meant for solar system work and corresponds to GEO + a radial velocity correction (only available for ephemeris objects). If no reference frame is given, the present reference frame given by the data is used, i.e. the reference frame is not changed. The observatory position is taken as the average of all antenna positions. LSRK 
        	mode		 The quantity (radio velocity (m/s), optical velocity (m/s), frequency (Hz), wavelength (m), or original channels) in which the user would like to give the regridding parameters below ('center', 'chanwidth', 'bandwidth'): vrad, vopt, freq, wave, or chan. chan 
        	restfreq	 Required in case the value of mode is 'vrad' or 'vopt': Rest frequency (Hz) for the conversion of the regrid parameters 'center', 'chanwidth', and 'bandwidth' to frequencies. -3E30 
        	interpolation	 Name of the interpolation method (NEAREST, LINEAR, SPLINE, CUBIC, FFTSHIFT) used in the regridding. Flagging information is combined using 'inclusive or'. LINEAR 
        	start		 Desired lower edge of the spectral window after regridding in the units given by 'mode' and in the reference frame given by 'outframe'. If no value is given, it is determined from 'center' and 'bandwidth'. -3E30 
        	center		 (Alternative to setting the parameter 'start'.) Desired center of the spectral window after regridding in the units given by 'mode' and in the reference frame given by 'outframe'. If no value is given, the center is determined from 'start' and 'bandwidth' or, if 'start' is not given either, it is kept as it is. -3E30 
        	bandwidth	 Desired width of the entire spectral window after regridding in the units given by 'mode' and in the reference frame given by 'outframe'. If no value is given or the given width is larger than the bandwidth of the data, the width will be truncated to the maximum width possible symmetrically around the value given by 'center'. -1. 
        	chanwidth	 Desired width of the channels in the units given by 'mode' and in the reference frame given by 'outframe'. This implies that channels will be equidistant in the unit given by 'mode'. If no value is given and 'mode' is vrad or freq, the function will keep the resolution as it is. If 'mode' is vopt or wave, the total number of channels will be kept as is. -1. 
        	hanning		 If true, perform hanning smoothing before regridding. true 
        	
        Example:
        	
            
              ms.fromfits('NGC5921.MS', '/usr/lib/casapy/data/demo/NGC5921.fits')
              ms.regridspw(outframe='LSRK')
            
            This example reads a measurement set and transforms its spectral axis to
            the LSRK reference frame.
            
              ms.regridspw(outframe='BARY', mode='vrad', 
              center=73961800., chanwidth=50., bandwidth=1000.,
              restfreq=1420405750e6)
            
            In this example, all spectral windows in the MS will be transformed 
            to the BARY reference frame and then be regridded such that the center of the 
            new spectral window is at radio velocity = 73961800. m/s (BARY). If the bandwidth 
            of the observation is large enough the total width of the spectral window will
            be 1000 m/s, i.e. 20 channels of width 50 m/s, 10 on each side of the given
            center.
            
              ms.regridspw(mode='vopt', restfreq=1420405750e6)
            
            In this example the channels are regridded such that they are
            equidistant in optical velocity. The reference frame and number of channels 
            is kept as is.
            
              ms.regridspw(mode='chan', center=64, chanwidth=2,
              bandwidth=102)
            
            In this example, the channels are regridded such that the new bandwidth is
            102 of the original channels centered on the original channel 64, and the new
            channels are twice as wide as the original channels. 
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_regridspw(self, *args, **kwargs)

    def cvel(self, *args, **kwargs):
        """
        cvel(self, mode=string("channel"), nchan=-1, start=initialize_variant("0"), width=initialize_variant("1"), 
            interp=string("linear"), phasec=initialize_variant(""), restfreq=initialize_variant("1.4GHz"), 
            outframe=string(""), veltype=string("radio"), 
            hanning=True) -> bool

        Summary
        	transform spectral data to different reference frame and/or regrid the frequency channels
           

        Description
        	
          This function permits you to transform the spectral data of your measurement set to a 
          given reference frame and/or regrid it. It will combine all spectral windows of the MS into one.
          

        Input Parameters:
        	mode		 'channel', 'velocity', 'frequency', or 'channel\_b', default = 'channel' channel 
        	nchan		 number of channels, default = -1 = all -1 
        	start		 start channel, default = 0 0 
        	width		 new channel width, default = 1 1 
        	interp		 interpolation method 'nearest', 'linear', 'spline', 'cubic', 'fftshift', default = linear linear 
        	phasec		 phase center, default = first field 
        	restfreq	 rest frequency, default = 1.4GHz 1.4GHz 
        	outframe	 LSRK, LSRD, BARY, GALACTO, LGROUP, CMB, GEO, TOPO, or SOURCE default = '' = keep reference frame. 
        	veltype		 radio or optical, default = radio radio 
        	hanning		 If true, perform hanning smoothing before regridding. true 
        	
        Example:
        	
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_cvel(self, *args, **kwargs)

    def cvelfreqs(self, *args, **kwargs):
        """
        cvelfreqs(self, spwids=initialize_vector(1, (int)0), fieldids=initialize_vector(1, (int)0), obstime=string(""), 
            mode=string("channel"), nchan=-1, start=initialize_variant("0"), 
            width=initialize_variant("1"), phasec=initialize_variant(""), restfreq=initialize_variant("1.4GHz"), 
            outframe=string(""), veltype=string("radio"), 
            verbose=True) -> std::vector< double >

        Summary
        	calculate the transformed grid of the SPW obtained by combining a given set of SPWs (MS is not modified)
           

        Description
        	
            Take the spectral grid of a given spectral window, tranform and regrid it as prescribed by the given
            grid parameters (same as in cvel and clean) and return the transformed values as a list.
            The MS is not modified. Useful for tests of gridding parameters before using them in cvel or clean.
          

        Input Parameters:
        	spwids		 The list of ids of the spectral windows from which the input grid is to be taken. 0 
        	fieldids	 The list of ids of the fields which are selected (for observation time determination), default: all 0 
        	obstime		 the observation time to assume, default: time of the first row of the MS = 
        	mode		 'channel', 'velocity', 'frequency', or 'channel\_b', default = channel 
        	nchan		 number of channels, default = all = -1 
        	start		 start channel, default = 0 
        	width		 new channel width, default = 1 
        	phasec		 phase center, default = first field in selection = 
        	restfreq	 rest frequency, default = 1.4GHz 
        	outframe	 LSRK, LSRD, BARY, GALACTO, LGROUP, CMB, GEO, TOPO, or SOURCE default = keep reference frame = 
        	veltype		 radio or optical, default = radio 
        	verbose		 If true, create log output true 
        	
        Example:
        	
            ms.open('my.ms')
            ms.cvelfreqs(spwids=[1], mode='channel', nchan=20, start=2, width=3, outframe='LSRK')

            will take the grid of SPW 1 (i.e. the second in the SPW table), regrid it as in cvel
            with the given grid parameters and return the resulting channel centers as an array.
            The MS is not modified. See help cvel for more details on the grid parameters.

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_cvelfreqs(self, *args, **kwargs)

    def getdata(self, *args, **kwargs):
        """
        getdata(self, items=std::vector< string >(1, ""), ifraxis=False, ifraxisgap=0, increment=1, average=False) -> record *

        Summary
        	Read values from the measurement set.

        Description
        	
            This function will read the specified items from the currently
            selected measurement set and returns them in fields of a record.
            The main difference between this and direct access of the table,
            using the table tool, is that this function reads data from the
            mph{selected} measurement set, it provides access to derived
            quantities like amplitude \& flag\_sum and it can reorder the
            data.

            The items to read are specified, as with the range function, using
            a vector of strings. Table~ref{ms:tblItems} shows the allowable
            items. Unrecognized items will result in a warning being sent to
            the logger.  Duplicate items are silently ignored.

            The record that is returned contains fields that correspond to
            each of the specified items. Most fields will contain an
            array. The array may be one, two or three dimensional depending on
            whether the corresponding row in the measurement set is a scalar,
            one or two dimensional. Unless the ifraxis argument is set to T
            the length of the last axis on these arrays will correspond to the
            number of rows in the selected measurement set.

            If the ifraxis argument is set to True, the row axis is split into an
            interferometer axis and a time axis. For example a measurement set
            with 90 rows, in an array with 6 telescopes (so that there are 15
            interferometers), may have a data array of shape erb|[4,32,90]|
            if ifraxis is False or erb|[4,32,15,6]|, if ifraxis is True (assuming
            there are 4 correlations and 32 channels). If there are missing
            rows as will happen if not all interferometers where used for all
            time-slots then a default value will be inserted.
            
            This splitting of the row axis may not happen for items where
            there is only a single value per row. For some items the returned
            vector will contain only as many values as there are
            interferometers and it is implicit that the same value should be
            used for all time slots. The antenna1, antenna2, feed1, feed2 \&
            ifr\_number items fall in this category. For other items the
            returned vector will have as many values as there are time slots
            and it is implicit that the same value should be used for all
            interefometers. The field\_id, scan\_number, data\_desc\_id \&
            time items fall into this category.

            The axis\_info item provides data labelling information. It
            returns a record with the following fields: corr\_axis,
            freq\_axis, ifr\_axis \& time\_axis. The latter two fields are not
            present if ifr\_axis is set to False. The corr\_axis field contains a
            string vector with elements like 'RR' or 'XY' that indicates which
            polarizations where correlated together to produce the data. The
            length of this vector will always be the same as the length of the
            first axis of the data array. The freq\_axis field contains a
            record with two fields, chan\_freq \& resolution. Each of these
            fields contains vectors which indicate the centre frequency and
            spectral resolution (FWHM) of each channel. The length of these
            vectors will be the same as the length of the second axis in the
            data. The ifr\_axis field contains fields: ifr\_number,
            ifr\_name, ifr\_shortname \& baseline. The ifr\_number is the same
            as returned by the ifr\_item, the ifr\_name \& ifr\_shortname are
            string vecors containing descriptions of the interferometer and
            the baseline is the Euclidian distance, in meters between the two
            antennas. All of these vectors have a length equal to the number
            of interferometers in the selected measurement set ie., to the
            length of the third axis in the data when ifraxis is True. The
            time\_axis field contains the MJD seconds field and optionally the
            HA, UT \& LAST fields. To include the optional fields you need to
            add the ha, last or ut strings to the list of requested items. All
            the fields in the time\_axis record contain vectors that indicate
            the time at the midpoint of the observation and are in
            seconds. The MJD seconds field is since 0 hours on the day having a
            modified julian day number of zero and the rest are since midnight
            prior to the start of the observation.

            An optional gap size can be specified to visually separate groups of 
            interferometers with the same antenna1 index (handy for
            identifying antennas in an interferometer vs time display). The
            default is no gap.

            An optional increment can be specified to return data from every
            row matching the increment only.

            When the average flag is set, the data will be averaged over the
            time axis if the ifraxis is True or the row axis i.e., different
            interferometers and times may be averaged together. In the latter
            case, some of the coordinate information, like antenna\_id, will
            no longer make sense.

            You need to call selectinit before
            calling this function. If you haven't then selectinit will be
            called for you with default arguments.

            Items prefixed with either; corrected, model, residual or
            obs\_residual and the imaging\_weight item are not available unless
            your measurement set has been processed either with the imager or
            calibrator tools.
          

        Input Parameters:
        	items		 Item names 
        	ifraxis		 Create interferometer axis if True false 
        	ifraxisgap	 Gap size on ifr axis when antenna1 changes 0 
        	increment	 Row increment for data access 1 
        	average		 Average the data in time or over rows false 
        	
        Example:
        	
            
        ms.open('3C273XC1.MS')
        ms.selectinit(datadescid=0)
        # The following line causes an EXCEPTION
        # d = ms.getdata(['amplitude','axis_info','ha'],ifraxis=True)
        # so we settle for MJDseconds rather than HA in seconds
        d = ms.getdata(['amplitude','axis_info'],ifraxis=True)
        tstart = min(d['axis_info']['time_axis']['MJDseconds'])
        tstop  = max(d['axis_info']['time_axis']['MJDseconds'])
        maxamp = max(max(d['amplitude'][:,0,0,0]),max(d['amplitude'][0,:,0,0]),
            max(d['amplitude'][0,0,:,0]),max(d['amplitude'][0,0,0,:]))
        print 'MJD start time (seconds) =', tstart
        # MJD start time (seconds) = 4121629400.0
        print 'MJD stop time (seconds) =', tstop
        # MJD stop time (seconds) = 4121642670.0
        # MJDseconds Correlation amplitude
        print 'Maximum correlation amplitude =', maxamp
        # Maximum correlation amplitude = 33.5794372559
        chan = 0
        corr = 0
        freqGHz = d['axis_info']['freq_axis']['chan_freq'][chan]/1.0E9
        baselineStr = d['axis_info']['ifr_axis']['ifr_name'][corr]
        corrStr = d['axis_info']['corr_axis'][corr]
        tcoord = d['axis_info']['time_axis']['MJDseconds']
        acoord = d['amplitude'][0,0,0,:]
        print 'Frequency', freqGHz, 'GHz', 'Baseline', baselineStr, '(', corrStr, ')'
        print 'MJDseconds', 'Correlation amplitude'
        for i in range(len(tcoord)):
            print tcoord[i], acoord[i]
        #
        # Frequency [ 8.085] GHz Baseline 1-2 ( RR )
        # MJDseconds Correlation amplitude
        # 4121629400.0 29.2170944214
        # 4121629410.0 29.1688995361
        # 4121629420.0 29.2497825623
        # 4121629430.0 29.2029647827
        # 4121629440.0 29.166015625
        # 4121629450.0 29.2417526245
        # 4121629460.0 29.2867794037
        # 4121638270.0 0.0
        # 4121638280.0 29.4539775848
        # 4121638290.0 29.472661972
        # 4121638300.0 29.4424362183
        # 4121638310.0 29.4234466553
        # 4121638320.0 29.4018745422
        # 4121638330.0 29.3326053619
        # 4121638340.0 29.3575496674
        # 4121642600.0 31.1411132812
        # 4121642610.0 31.0726108551
        # 4121642620.0 31.1242599487
        # 4121642630.0 31.0505466461
        # 4121642640.0 31.0448284149
        # 4121642650.0 30.9974422455
        # 4121642660.0 31.0648326874
        # 4121642670.0 31.0638961792


            This example selects all the data from the
            measurement set where the value in the DATA_DESC_ID column is
            zero. This corresponds to a particular spectral window and
            polarization setup. It then gets the correlated amplitude, and the
            axis information from this selected measurement set. This is
            returned in the casapy variable d. The remainder of the example
            prints a table of 'hour angle' and corresponding 'correlated
            amplitude' for the first channel, correlation and baseline.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_getdata(self, *args, **kwargs)

    def putdata(self, *args, **kwargs):
        """
        putdata(self, items=initialize_record("")) -> bool

        Summary
        	Write new values into the measurement set

        Description
        	
            This function allows you to write values from casapy variables back
            into the measurement set table. The main difference between this
            and directly accessing the table using the table tool is that this
            function writes data to the mph{selected} measurement set.

            Unlike the getdata function you can only put items that correspond
            to actual table columns. You cannot change the data shape either
            so that the number of correlations, channels and rows (or
            intereferometers/time slots) must match the values in the selected
            measurement set. If the values were obtained using the getdata
            function with ifraxis argument set to True, then any default values
            added to fill in missing intereferometer/timeslots pairs will be
            ignored when writing the modified values back using this function.

            The measurement set has to be opened for read/write access to be
            able to use this function.

            You need to call selectinit before
            calling this function. If you haven't then selectinit will be
            called for you with default arguments.

            Items prefixed with either; corrected, model, residual or
            obs\_residual and the imaging\_weight item are not available unless
            your measurement set has been processed either with the imager or
            calibrator tools.
          

        Input Parameters:
        	items		 Record with items and their new values 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS', nomodify=False)
              ms.selectinit(datadescid=0)
              rec = ms.getdata(['weight','data'])
              rec['weight'][:,:] = 1
              import Numeric
              meanrec = Numeric.average(rec['data'],axis=None)
              print 'Mean data value = ', meanrec
              rec['data'][:,:,:] -= meanrec
              ms.putdata(rec)
            
            This example selects all the data from the measurement set where
            the value in the DATA_DESC_ID column is zero. This
            corresponds to a particular spectral window and polarization
            setup. Note that the measurement set was opened for writing as
            well as reading. The third line reads all the weights and the
            data into the casapy variable rec. The weights are set
            to one. The more obscure syntax is used as typing 
            rec['weight'] = 1 will not preserve the shape of the weight
            array. The data then has its mean subtracted from
            it. The average function is defined in Numeric module. Finally the data
            is written back into the measurement set table. (NOTE: normally
            one should not modify the raw data column.  Such adjustments are more
            appropriate for the corrected_data column, if it exists.)
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_putdata(self, *args, **kwargs)

    def concatenate(self, *args, **kwargs):
        """
        concatenate(self, msfile=string(""), freqtol=initialize_variant("1Hz"), dirtol=initialize_variant("1mas"), 
            weightscale=1., handling=0, destmsfile=string(""), respectname=False) -> bool

        Summary
        	Concatenate two measurement sets

        Description
        	
            This function concatenates two measurement sets together. 

            The data is copied from the measurement set specified in the
            msfile arguement to the end of the measurement set attached to the
            ms tool. If a lot of data needs to be copied this function may
            take some time. You need to open the measurement set for writing
            in order to use this function.

          

        Input Parameters:
        	msfile		 The name of the measurement set to append 
        	freqtol		 Frequency difference within which 2 spectral windows are considered similar; e.g '10Hz' 1Hz 
        	dirtol		 Direction difference within which 2 fields are considered the same; e.g '1mas' 1mas 
        	weightscale	 Scale the weights of the MS to be appended by this factor 1. 
        	handling	 Switch for the handling of the Main and Pointing tables: 0=standard, 1=no Main, 2=no Pointing, 3=no Main and Pointing, 4=virtual 0 0 1 2 3 
        	destmsfile	 Optional support for virtual concat: empty table (no subtables) where to store the appended MS copy 
        	respectname	 If true, fields with a different name are not merged even if their direction agrees false 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS', nomodify=False)
              ms.concatenate('BLLAC.ms', '1GHz', '1arcsec')
              ms.done()
            
            This example appends the data from the BLLAC measurement set to
            the end of the 3C273 measurement set. Its going to assume a
            frequency tolerance of 1GHz and position tolerance of 1 arcsec in
            deciding if the spw and field in the measurementsets are
            similar or not. 
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_concatenate(self, *args, **kwargs)

    def testconcatenate(self, *args, **kwargs):
        """
        testconcatenate(self, msfile=string(""), freqtol=initialize_variant("1Hz"), dirtol=initialize_variant("1mas"), 
            respectname=False) -> bool

        Summary
        	Concatenate only the subtables of two measurement sets excluding the POINTING table (resulting MAIN and POINTING table not useful)

        Description
        	
            This function acts like ms.concatenate() with handling==3 (do not concatenate
            the MAIN and POINTING tables). This is useful for generating, e.g.,
            SPECTRAL\_WINDOW and FIELD tables which contain all used SPW and FIELD ids
            for a set of MSs without having to actually carry out a time-consuming
            concatenation on disk. The MAIN table in the resulting output MS is
            that of the original MS, i.e. it is not touched. 
          

        Input Parameters:
        	msfile		 The name of the measurement set from which the subtables should be appended 
        	freqtol		 Frequency difference within which 2 spectral windows are considered similar; e.g '10Hz' 1Hz 
        	dirtol		 Direction difference within which 2 fields are considered the same; e.g '1mas' 1mas 
        	respectname	 If true, fields with a different name are not merged even if their direction agrees false 
        	
        Example:
        	
            
              tb.open('3C273XC1.MS')
              tb.copy('TEMP.MS', norows=True)
              tb.close()
              ms.open('TEMP.MS', nomodify=False)
              ms.testconcatenate('3C273XC1.ms', '1GHz', '1arcsec')
              ms.testconcatenate('BLLAC.ms', '1GHz', '1arcsec')
              ms.done()
            
            This example makes a copy of the structure of an MS and then
            appends the subtables data from two  measurement sets to the empty structure. 
            Its going to assume a frequency tolerance of 1GHz and position tolerance 
            of 1 arcsec in deciding if the spw and field in the measurementsets are
            similar or not. 
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_testconcatenate(self, *args, **kwargs)

    def virtconcatenate(self, *args, **kwargs):
        """
        virtconcatenate(self, msfile=string(""), auxfilename=string(""), freqtol=initialize_variant("1Hz"), dirtol=initialize_variant("1mas"), 
            weightscale=1., respectname=True) -> bool

        Summary
        	Concatenate two measurement sets virtually

        Description
        	
            This function virtually concatenates two measurement sets together
            such that they can later be turned into a multi-MS with createmultims(). 

            You need to open the measurement set for writing in order to use this function.

          

        Input Parameters:
        	msfile		 The name of the measurement set to append 
        	auxfilename	 The name of a auxiliary file which is needed when more than two MSs are to be concatenated. 
        	freqtol		 Frequency difference within which 2 spectral windows are considered similar; e.g '10Hz' 1Hz 
        	dirtol		 Direction difference within which 2 fields are considered the same; e.g '1mas' 1mas 
        	weightscale	 Scale the weights of the MS to be appended by this factor 1. 
        	respectname	 If true, fields with a different name are not merged even if their direction agrees true 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.ms', nomodify=False)
              ms.virtconcatenate('3C273XC1-2.ms', '3Caux.dat', '1GHz', '1arcsec')
              ms.virtconcatenate('3C273XC1-3.ms', '3Caux.dat', '1GHz', '1arcsec')
              ms.close()
              os.remove('3Caux.dat')
              m.createmultims(concatvis, 
                              ['3C273XC1.ms','3C273XC1-2.ms','3C273XC1-3.ms'],
        		      [],
        		      True, # nomodify
        		      False,# lock
        		      True) # copysubtables from first to all other members
              ms.close()
            
            This example virtually appends the data from the 3C273XC1-2 and 3C273XC1-3 to
            the end of the 3C273XC1 measurement set. Its going to assume a
            frequency tolerance of 1GHz and position tolerance of 1 arcsec in
            deciding if the spw and field in the measurementsets are
            similar or not. The file 3Caux.dat which is created in the process is
            no longer needed after the last call to virtconcatenate() and can
            be deleted.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_virtconcatenate(self, *args, **kwargs)

    def timesort(self, *args, **kwargs):
        """
        timesort(self, newmsname=string("")) -> bool

        Summary
        	Sort the main table of an MS by time

        Description
        	
            This function sorts the main table of the measurement set by the contents
            of the column TIME in ascending order and writes a copy of the MS with the sorted
            main table into newmsfile.

            If no newmsname is given, a sorted copy of the MS is written into a new MS under the name
            x.sorted (where x is the name of the original MS). The original MS is then closed and deleted.
            The new MS is renamed to the name of the original MS and then reopened.
          

        Input Parameters:
        	newmsname	 Name of the output measurement set (default: overwrite original) 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS', nomodify=False)
              ms.timesort()
              ms.done()
            
            This example sorts the main table of 3C273XC1.MS by time.
            The original MS is overwritten by the sorted one.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_timesort(self, *args, **kwargs)

    def sort(self, *args, **kwargs):
        """
        sort(self, newmsname=string(""), columns=std::vector< string >(1, "")) -> bool

        Summary
        	Sort the main table of an MS using a custom set of columns

        Description
        	
            This function sorts the main table of the measurement set by the contents
            of the input set of columns in ascending order and writes a copy of the MS 
            with the sorted main table into newmsfile.

            If no newmsname is given, a sorted copy of the MS is written into a new MS under the name
            x.sorted (where x is the name of the original MS). The original MS is then closed and deleted.
            The new MS is renamed to the name of the original MS and then reopened.
          

        Input Parameters:
        	newmsname	 Name of the output measurement set (default: overwrite original) 
        	columns		 Vector of column names (case sensitive). 
        	
        Example:
        	
            
              
              ms.open('3C273XC1.MS', nomodify=False)
              ms.sort(['ANTENNA1','ANTENNA2'])
              ms.done()
            
            This example sorts the main table of 3C273XC1.MS by ANTENNA1 and then ANTENNA2.
            The original MS is overwritten by the sorted one.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_sort(self, *args, **kwargs)

    def contsub(self, *args, **kwargs):
        """
        contsub(self, outputms=string(""), fitspw=initialize_variant("*"), fitorder=1, combine=string(""), 
            spw=initialize_variant("*"), unionspw=initialize_variant("*"), field=initialize_variant(""), 
            scan=initialize_variant(""), intent=string(""), correlation=string(""), 
            obs=string(""), whichcol=string("CORRECTED_DATA")) -> bool

        Summary
        	Subtract the continuum from the visibilities

        Description
        	
            NOT FULLY IMPLEMENTED YET.  uvcontsub uses the cb tool for now.
            (The only reason to implement it in ms is to save time and disk space.)

            This function estimates the continuum emission of the MS and writes a MS
            with that estimate subtracted, using the ms tool.  The estimate is made,
            separately for the real and imaginary parts of each baseline, by fitting a
            low order polynomial to the unflagged visibilities selected by fitspw
            (depending on combine).
          

        Input Parameters:
        	outputms	 The name of the resulting measurement set 
        	fitspw		 Line-free spectral windows (and :channels) to fit to * 
        	fitorder	 The order of the polynomial to use when fitting. 1 
        	combine		 Ignore changes in these columns (spw, scan, and/or state) when fitting. 
        	spw		 Spectral windows (and :channels) to select * 
        	unionspw	 The union of fitspw and spw, i.e. how much needs to be read. '*' always works, but may be more than you need. * 
        	field		 Fields to include, by names or 0-based ids. ('' =\> all) 
        	scan		 Only use the scan numbers requested using the msselection syntax. 
        	intent		 Only use the requested scan intents. 
        	correlation	 Limit data to specific correlations (LL, XX, LR, XY, etc.). 
        	obs		 Only use the requested observation IDs. 
        	whichcol	 'DATA', 'MODEL\_DATA', 'CORRECTED\_DATA', and/or 'FLOAT\_DATA' CORRECTED\_DATA 
        	
        Example:
        	
          
          ms.open('multiwin.ms')
          ms.contsub('contsub.ms', fitspw='0:0~123;145~211,2:124~255', fitorder=0,
                     field=[0], spw='0,2') 

          In this example the continuum estimates are made by seperately averaging
          channels 0:0~123;145~211 and 2:124~255, and the separate estimates are
          subtracted from spws 0 and 2.  The output only includes field 0 and spws 0
          and 2 (now called 1).

          ms.contsub('contsub.ms', fitspw='0:0~123;145~211,2:124~255', fitorder=0,
                     field=[0], combine='spw')
          ms.close()

          This time the estimate was made by simultaneously averaging channels
          0:0~123;145~211 and 2:124~255, and the continuum is subtracted from all the
          spws, including 1 (treated as a completely line-filled spw).  The output only
          includes field 0.

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_contsub(self, *args, **kwargs)

    def statwt(self, *args, **kwargs):
        """
        statwt(self, dorms=False, byantenna=True, sepacs=True, fitspw=initialize_variant("*"), fitcorr=initialize_variant(""), 
            combine=string(""), timebin=initialize_variant("0s"), 
            minsamp=3, field=initialize_variant(""), spw=initialize_variant("*"), antenna=initialize_variant(""), 
            timerange=string(""), scan=initialize_variant(""), 
            intent=string(""), array=initialize_variant(""), correlation=string(""), 
            obs=string(""), datacolumn=string("corrected_data")) -> bool

        Summary
        	Set WEIGHT and SIGMA from the scatter of the visibilities

        Description
        	
            NOT IMPLEMENTED YET.

            This function estimates the noise from the scatter of the visibilities,
            sets SIGMA to it, and WEIGHT to SIGMA**-2.

            Ideally the visibilities used to estimate the scatter, as selected by
            fitspw and fitcorr, should be pure noise.  If you know for certain that
            they are, then setting dorms to True will give the best result.  Otherwise,
            use False (standard sample standard deviation).  More robust scatter
            estimates like the interquartile range or median absolute deviation from
            the median are not offered because they require sorting by value, which is
            not possible for complex numbers.

            To beat down the noise of the noise estimate, the sample size per estimate
            can be made larger than a single spw and baseline.  (Using combine='spw' is
            to interpolate between spws with line-free channels is recommended when an
            spw has no line-free channels.)  timebin smooths the noise estimate over
            time.  windowtype sets the type of time smoothing.

            WEIGHT and SIGMA will not be changed for samples that have fewer than
            minsamp visibilities.  Selected visibilities for which no noise estimate is
            made will be flagged.  Note that minsamp is effectively at least 2 if dorms
            is False, and 1 if it is True.

          

        Input Parameters:
        	dorms		 How the scatter should be estimated (True -\> rms, False -\> stddev) false 
        	byantenna	 How the scatters are solved for (by antenna or by baseline) true 
        	sepacs		 If solving by antenna, treat autocorrs separately true 
        	fitspw		 Line-free spectral windows (and :channels) to get the scatter from. ('' =\> all) * 
        	fitcorr		 Correlations (V, LL, XX, LR, XY, etc.) to get the scatter from. ('' =\> all) 
        	combine		 Ignore changes in these columns (spw, scan, and/or state) when getting the scatter. 
        	timebin		 Duration of the moving window over which to estimate the scatter. Defaults to 0s, with an effective minimum of 1 integration. 0s 
        	minsamp		 The minimum number of visibilities for a scatter estimate 3 
        	field		 Fields to reweight, by names or 0-based ids. ('' =\> all) 
        	spw		 Spectral windows to reweight. ('' =\> all) * 
        	antenna		 Select data based on antenna/baseline 
        	timerange	 Select data by time range 
        	scan		 Scan numbers to reweight. ('' =\> all) 
        	intent		 Scan intents to reweight. ('' =\> all) 
        	array		 Select (sub)array(s) by array ID number 
        	correlation	 Correlations (LL, XX, LR, XY, etc.) to reweight. ('' =\> all) 
        	obs		 Observation IDs to reweight. ('' =\> all) 
        	datacolumn	 Which data column to calculate the scatter from. corrected\_data 
        	
        Example:
        	
          
          ms.open('multiwin.ms', nomodify=False)
          ms.statwt(fitspw='0:0~123;145~211,2:124~255', field=[0], spw='0,2') 

          In this example the noise estimates are seperately made from and applied 
          to spws 0 and 2.

          ms.statwt(fitspw='0:0~123;145~211,2:124~255', fitorder=0, field=[0],
                    combine='spw')
          ms.close()

          This time the estimate for each baseline is made from the line-free channels
          of spws 0 and 2, and applied to all the spws, including 1 (which could be a
          completely line-filled spw).

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_statwt(self, *args, **kwargs)

    def split(self, *args, **kwargs):
        """
        split(self, outputms=string(""), field=initialize_variant(""), spw=initialize_variant("*"), step=initialize_vector(1, (int)1), 
            baseline=initialize_variant(""), timebin=initialize_variant("-1s"), 
            time=string(""), scan=initialize_variant(""), uvrange=initialize_variant(""), 
            taql=string(""), whichcol=string("DATA"), tileshape=initialize_variant(""), 
            subarray=initialize_variant(""), combine=string(""), 
            correlation=string(""), intent=string(""), obs=string("")) -> bool

        Summary
        	make a new ms from a subset of an existing ms, adjusting subtables and indices

        Description
        	
            This function splits out part of the MS into a new MS. Time and
            channel averaging can be performed in the process (but not in
            the same call).
            
            When splitting multiple spectral windows, the parameters {	t
            nchan, start, step} can be vectors, so that each spectral window
            has its own selection on averaging and number of output
            channels. But the option of using only one value for each of these
            parameters means that it will be replicated for all the spectral
            windows selected.  
              
          

        Input Parameters:
        	outputms	 The name of the resulting measurement set 
        	field		 Fields to include, by names or 0-based ids. ('' =\> all) 
        	spw		 Spectral windows (and :channels) to select * 
        	step		 number of input per output channels - Int vector of length 1 or same as spw 1 
        	baseline	 Antenna names or indices to select ('' =\> all) 
        	timebin		 Duration for averaging. Defaults to no averaging. -1s 
        	time		 Only use data in the given time range, using the msselection syntax. 
        	scan		 Only use the scan numbers requested using the msselection syntax. 
        	uvrange		 Limit data by uv distance using the msselection syntax. 
        	taql		 For the TAQL experts, flexible data selection using the TAQL syntax 
        	whichcol	 'DATA', 'MODEL\_DATA', 'CORRECTED\_DATA', 'FLOAT\_DATA', 'LAG\_DATA', and/or 'all' DATA 
        	tileshape	 Tile shape of the disk data columns, most users should not need to touch this parameter [0] =\> normal tiling, [1] =\> fast mosaic style tile [4,15,351] =\> a tile shape of 4 pol 15 chan and 351 rows 
        	subarray	 Limit data to specific (sub)array numbers. 
        	combine		 Ignore changes in these columns (scan, and/or state) when time averaging. 
        	correlation	 Limit data to specific correlations (LL, XX, LR, XY, etc.). 
        	intent		 Only use the requested scan intents. 
        	obs		 Only use the requested observation IDs. 
        	
        Example:
        	
          
          ms.open('multiwin.ms')
          ms.split('subms.ms', field=[0], spw=[0], nchan=[10],
                   start=[0], step=[5], whichcol='CORRECTED_DATA') 
          
          In this example we split out data from the 1st field and 1st
          spectral window. The output data will have 10 channels which is
          taken from 50 channels from the input data starting at channel 0 and
          averaging every 5.

              
          ms.open('multiwin.ms')
          ms.split('subms.ms', field=[0], spw=[0,1,2,3], nchan=[10],
                   start=[0], step=[5], whichcol='CORRECTED_DATA') 
         
        In this example we split out data from the 1st field and four spectral
        windows. The output data will have 4 spectral windows each of 10
        channels which is taken from 50 channels from the input data starting
        at channel 0 and averaging every 5.

              
          ms.open('multiwin.ms')
          ms.split('subms.ms', field=[0], spw=[0,1,2,3], nchan=[10,10,30,40],
                   start=[0,4,9,9], step=[1,10,5,2], whichcol='CORRECTED_DATA')

        In this example we split out data from the 1st field and four spectral
        windows. There will be four spectral windows in the output data,
        with 10, 10, 30 and 40 channels respectively. These are averages
        of the input spectral windows. The first output spectral window
        will be formed by picking 10 channels, starting at 0 with no
        averaging, of the input spwid 0. The second output spectral window
        will consists of 10 channels and is formed by picking 100 channels
        from spwid 1 of the input data, starting at channel 4, and every
        10 channels to make one output channel.

             
          ms.open('WSRT.ms')
          ms.split('subms.ms', timebin='20s', whichcol='all', combine='scan')
          ms.close()

          This example averages a WSRT MS into 20s bins, selecting whichever of DATA,
          MODEL_DATA, CORRECTED_DATA, or FLOAT_DATA, or LAG_DATA is present.  Normally
          the bins would not cross scans, but in this MS the scan number goes up with
          each integration, making it redundant enough with time that it would defeat
          any time averaging.  Therefore the combine parameter forces the SCAN column
          to be ignored for setting the bins.

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_split(self, *args, **kwargs)

    def partition(self, *args, **kwargs):
        """
        partition(self, outputms=string(""), field=initialize_variant(""), spw=initialize_variant("*"), baseline=initialize_variant(""), 
            timebin=initialize_variant("-1s"), time=string(""), 
            scan=initialize_variant(""), uvrange=initialize_variant(""), taql=string(""), 
            whichcol=string("DATA"), tileshape=initialize_variant(""), subarray=initialize_variant(""), 
            combine=string(""), intent=string(""), obs=string("")) -> bool

        Summary
        	make a new ms from a subset of an existing ms, without changing any subtables

        Description
        	
            This function splits out part of the MS into a new MS. Time averaging can
            be performed in the process.  Unlike split, the subtables and IDs
            (ANTENNA1, DATA\_DESCRIPTION\_ID, etc.) are never changed to account for the
            selection.

            As a side effect of that property, partition cannot select by channel or
            correlation, or average channels.  It CAN select by spectral window(s).   
          

        Input Parameters:
        	outputms	 The name of the resulting measurement set 
        	field		 Fields to include, by names or 0-based ids. ('' =\> all) 
        	spw		 Spectral windows (and :channels) to select * 
        	baseline	 Antenna names or indices to select ('' =\> all) 
        	timebin		 Duration for averaging. Defaults to no averaging. -1s 
        	time		 Only use data in the given time range, using the msselection syntax. 
        	scan		 Only use the scan numbers requested using the msselection syntax. 
        	uvrange		 Limit data by uv distance using the msselection syntax. 
        	taql		 For the TAQL experts, flexible data selection using the TAQL syntax 
        	whichcol	 'DATA', 'MODEL\_DATA', 'CORRECTED\_DATA', 'FLOAT\_DATA', 'LAG\_DATA', and/or 'all' DATA 
        	tileshape	 Tile shape of the disk data columns, most users should not need to touch this parameter [0] =\> normal tiling, [1] =\> fast mosaic style tile [4,15,351] =\> a tile shape of 4 pol 15 chan and 351 rows 
        	subarray	 Limit data to specific (sub)array numbers. 
        	combine		 Ignore changes in these columns (scan, and/or state) when time averaging. 
        	intent		 Only use the requested scan intents. 
        	obs		 Only use the requested observation IDs. 
        	
        Example:
        	
                
          ms.open('multiwin.ms')
          ms.partition('partition.ms', field=[0], spw=[1], whichcol='CORRECTED_DATA') 
          
          In this example we partition out data from the 1st field and 2nd spectral
          window.  Only the CORRECTED_DATA data column will be copied, and it will be
          written to the DATA column of partition.ms.
              

          ms.open('multiwin.ms')
          ms.partition('partition.ms', field=[0], spw=[0,1,2,3],
                       whichcol='CORRECTED_DATA') 
         
          In this example we partition out calibrated data from the 1st field and four
          spectral windows.
              

          ms.open('WSRT.ms')
          ms.partition('partition.ms', timebin='20s', whichcol='all', combine='scan')
          ms.close()

          This example averages a WSRT MS into 20s bins, selecting whichever of DATA,
          MODEL_DATA, CORRECTED_DATA, or FLOAT_DATA, or LAG_DATA is present.  Normally
          the bins would not cross scans, but in this MS the scan number goes up with
          each integration, making it redundant enough with time that it would defeat
          any time averaging.  Therefore combine parameter forces the SCAN column to be
          ignored for setting the bins.

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_partition(self, *args, **kwargs)

    def iterinit(self, *args, **kwargs):
        """
        iterinit(self, columns=std::vector< string >(1, ""), interval=0.0, maxrows=0, adddefaultsortcolumns=True) -> bool

        Summary
        	Initialize for iteration over an ms

        Description
        	
            Specify the columns to iterate over and the time interval to use
            for the TIME column iteration.  The columns are specified by their
            MS column name.  Note that the following columns are always added
            to the specified columns: array\_id, field\_id, data\_desc\_id and
            time. This is so that the iterator can keep track of the
            coordinates associated with the data (field direction, frequency
            etc.) If you want to sort on these columns last instead of first
            you need to include them in the columns specified. If you don't
            want to sort on these columns at all, you can set
            adddefaultsortcolumns to False.
            You need to call selectinit before 
            calling this.  See the example below.
          

        Input Parameters:
        	columns		 Vector of column names (case sensitive). 
        	interval	 Time interval in seconds (greater than 0), to group together in iteration 0.0 
        	maxrows		 Max number of rows (greater than 0) to return in iteration 0 
        	adddefaultsortcolumns	 Add the default sort columns true 
        	
        Example:
        	
            See the example for the iterend function.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_iterinit(self, *args, **kwargs)

    def iterorigin(self):
        """
        iterorigin(self) -> bool

        Summary
        	Set the iterator to the start of the data.

        Description
        	
            Set or reset the iterator to the start of the currently specified
            iteration. You need to call this before attempting to retrieve
            data with getdata. You can set the iteration back to the start
            before you reach the end of the data.  You need to call iterinit
            before calling this.  See the example below.
          
        Example:
        	
            See the example for the iterend function.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_iterorigin(self)

    def iternext(self):
        """
        iternext(self) -> bool

        Summary
        	Advance the iterator to the next lot of data

        Description
        	
            This sets the currently selected table (as accessed with getdata)
            to the next iteration. If there is no more data, the function
            returns False and the selection is reset to that before the
            iteration started.  You need to call iterinit and iterorigin
            before calling this.  See the example below.
          
        Example:
        	
            See the example for the iterend function.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_iternext(self)

    def iterend(self):
        """
        iterend(self) -> bool

        Summary
        	End the iteration and reset the selected table

        Description
        	
            This sets the currently selected table (as accessed with
            getdata) to the table that was selected
            before iteration started.  Use this to end the iteration
            prematurely.  There is no need to call this if you continue
            iterating until iternext returns False.

            See the example below.
          
        Example:
        	
            
              
              ms.open('3C273XC1.MS')
              ms.selectinit(datadescid=0)
              ms.iterinit(['ANTENNA1','ANTENNA2','TIME'],60.0)
              ms.iterorigin()
              rec=ms.getdata(['u','v','data'])
              ms.iternext()
              ms.iterend()
            
            We open the MS, select an array and spectral window and then
            specify an iteration over interferometer and time, with a 60s time
            interval.  We then set the iterator to the start of the data and
            get out some data. Finally we advance the iterator to the next lot
            of data and then end the iteration.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_iterend(self)

    def fillbuffer(self, *args, **kwargs):
        """
        fillbuffer(self, item=string(""), ifraxis=False) -> bool

        Summary
        	Fill the internal buffer with data and flags.

        Description
        	
        Read the specified data item from the table, including its flags
        and keep the results in an internal buffer


        Input Parameters:
        	item		 data derived item 
        	ifraxis		 Create interferometer axis if True false 
        	
        Example:
        	

        ms.open('3C273XC1.MS')
        ms.select({'antenna1':[3]})
        ms.fillbuffer('PHASE',True)



        We open the MS for reading, select a subset and then 
        read the DATA, FLAG and FLAG\_ROW column, extract the PHASE,
        reorder the data to add an interferometer axis,
        and keep the results around in an internal buffer.


        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_fillbuffer(self, *args, **kwargs)

    def diffbuffer(self, *args, **kwargs):
        """
        diffbuffer(self, direction=string("TIME"), window=1) -> record *

        Summary
        	Differentiate or difference the internal buffer.

        Description
        	
        Subtract the previous point from each data point in the buffer (for
        window equal 2), or subtract the average over a window (for window
        greater than 2) from each point. The window can be in the time / row
        direction or the frequency / channel direction. The input data can be
        float or complex but the output is always float.  The function returns
        statistics over the buffer: median for each time and channel, the
        average absolute deviation from the median in time and channel
        direction and over all pixels.


        Input Parameters:
        	direction	 choose between time or channel direction: TIME or CHANNEL TIME 
        	window		 width of averaging window in timeslots or channels; integer greater than 0 1 
        	
        Example:
        	

        ms.open('3C273XC1.MS')
        ms.select({'antenna1':[3]})
        ms.fillbuffer('DATA')
        ms.diffbuffer('TIME',15)
        # {'aad': array([[ 0.58959275],
        #       [ 0.20988081],
        #       [ 0.15907532],
        #       [ 0.58837521]]),
        # 'median': array([[ 2.67179847],
        #       [ 0.32471114],
        #       [ 0.37952924],
        #       [ 2.60897708]])}



        We open the MS for reading, select a subset and then 
        read the DATA, FLAG and FLAG\_ROW column, 
        we then subtract the average over a 15 point time-window from each
        data point.


        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_diffbuffer(self, *args, **kwargs)

    def getbuffer(self):
        """
        getbuffer(self) -> record *

        Summary
        	Return the internal buffer as a Record for access from the intrepreter.

        Description
        	
        Returns the internal buffer with either 'raw' or differenced data,
        flags and buffer statistics (if a difference operation was performed).

        Example:
        	

        ms.open('3C273XC1.MS')
        ms.select({'antenna1':[3]})
        ms.fillbuffer('PHASE')
        rec=ms.getbuffer()



        We open the MS for reading, select a subset and then 
        read the DATA, FLAG and FLAG\_ROW column, extract the PHASE
        and then obtain the results in a record.


        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_getbuffer(self)

    def clipbuffer(self, pixellevel=0.0, timelevel=0.0, channellevel=0.0):
        """
        clipbuffer(self, pixellevel=0.0, timelevel=0.0, channellevel=0.0) -> bool

        Summary
        	(NON-FUNCTIONAL???) Clip the internal buffer with specified limits.

        Description
        	
        This sets flags in the internal buffer based on the clip levels
        specified. You can flag times, channels and individual pixels based on
        their deviation from the median. The cliplevel is specified in units of
        the corresponding average absolute deviation (a robust version of rms).


        Input Parameters:
        	pixellevel	 cliplevel for pixels (greater than 0) 0.0 
        	timelevel	 cliplevel for time slots (greater than 0) 0.0 
        	channellevel	 cliplevel for channels (greater than 0) 0.0 
        	
        Example:
        	

        ms.open('3C273XC1.MS')
        ms.select({'antenna1':[3]})
        ms.fillbuffer('DATA')
        stats=ms.diffbuffer('TIME',15)
        ms.clipbuffer(6,5,5)
        #2008-05-28 17:15:27  SEVERE  casa::ms::open
        #  Exception Reported: RecordInterface: field medTmeF is unknown
        #---------------------------------------------------------------------------
        #type 'exceptions.StandardError'         Traceback (most recent call last)
        #
        #/home/aips2mgr/testing/ipython console in module()
        #
        #type 'exceptions.StandardError': RecordInterface: field medTmeF is unknown



        We open the MS for reading, select a subset and
        read the data into the buffer. We then remove the average over a 15
        point time window and clip the resulting data at 6 times the average
        absolute deviation from the median for individual pixels, and at 5
        times this for channels and timeslots.


        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_clipbuffer(self, pixellevel, timelevel, channellevel)

    def asdmref(self, *args, **kwargs):
        """
        asdmref(self, abspath=string("")) -> string

        Summary
        	Test if the MS was imported with option lazy=True in importasdm and optionally change the ASDM reference

        Description
        	
           If the MS is imported from an ASDM  with option lazy=True, the DATA column of the MS is virtual
           and directly reads the visibilities from the ASDM. A reference to the original ASDM is stored
           with the MS. If the ASDM needs to be moved to a different path, the reference to it in the MS
           needs to be updated. This can be achieved with ms.asdmref().
           When called with an empty string (default), the method just reports the currently set ASDM path.

           Return value is a string containing the new path if the path was successfully set or 
           (in the case abspath was empty) the MS indeed contains a ASDM reference, i.e. was lazily imported.

           If the ASDM does not contain an ASDM reference, the method returns an empty string.
           If abspath is not empty and there was an error setting the new reference, the method throws
           an exception.
           

        Input Parameters:
        	abspath		 new absolute path of the ASDM to be referenced (empty string = report current setting) 
        	
        Example:
        	
             Set the path to the referenced ASDM to '/home/alma/myanalysis/uid___A12345_X678_X910':     
                ms.open('uid___A12345_X678_X910.ms',False)
                ms.asdmref('/home/alma/myanalysis/uid___A12345_X678_X910')
                ms.close()

             Test if the MS was imported with lazy=True and therefore references an ASDM:
                ms.open('uid___A12345_X678_X910.ms')
                myref = ms.asdmref()
                ms.close()
                if myref=='':
                  print 'This MS does not reference an ASDM.'
                else:
                  print 'This MS references the ASDM ', myref
           
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_asdmref(self, *args, **kwargs)

    def setbufferflags(self, *args, **kwargs):
        """
        setbufferflags(self, flags=initialize_record("")) -> bool

        Summary
        	Set the flags in the buffer

        Description
        	
             Replace the flag and flag\_row fields in the internal
             buffer with those in the input record.
             The input record can be e.g., a modified version of the record
             returned by getbuffer(). The other fields in the record are ignored.
           

        Input Parameters:
        	flags		 record with flag and flag\_row 
        	
        Example:
        	
             
             ms.open('3C273XC1.MS',False)
             ms.select({'antenna1':[3]})
             ms.fillbuffer('PHASE')
             rec=ms.getbuffer()
             rec['flag_row'][17]=True
             ms.setbufferflags(rec)
             
             
               We open the MS for reading, select a subset and
               read the data. We get the data into casapy, flag timeslot 17 and put
               the modified flags back into the buffer.
             
           
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_setbufferflags(self, *args, **kwargs)

    def writebufferflags(self):
        """
        writebufferflags(self) -> bool

        Summary
        	Write the flags in the internal buffer back to the table.

        Description
        	
               Takes the flag and flag\_row field in the internal buffer and writes
               them back to the FLAG and FLAG\_ROW column in the currently selected
               table.
             
        Example:
        	
               
               ms.open('3C273XC1.MS',False)
               ms.select({'antenna1':[3]})
               ms.fillbuffer('PHASE')
               rec=ms.getbuffer()
               rec['flag_row'][17]=True
               ms.setbufferflags(rec)
               ms.writebufferflags()
               

               
        	 We open the MS for reading, select a subset and
        	 read the data. We get the data into casapy, flag timeslot 17 and put
        	 the modified flags back into the buffer. We then write the buffer
        	 flags back to the table, causing the corresponding data to be
        	 marked flagged on subsequent access.
               
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_writebufferflags(self)

    def clearbuffer(self):
        """
        clearbuffer(self) -> bool

        Summary
        	Clear the internal buffer.

        Description
        	
        Clears the internal buffer, returning the memory.
        This can be used after the (final) clipping/flagging operations have
        been performed.

        Example:
        	

        ms.open('3C273XC1.MS',False)
        ms.select({'antenna1':[3]})
        ms.fillbuffer('PHASE')
        rec=ms.getbuffer()
        rec['flag_row'][17]=True
        ms.setbufferflags(rec)
        ms.writebufferflags()
        ms.clearbuffer()



        We open the MS for reading, select a subset and
        read the data. We get the data into casapy, flag timeslot 17 and put
        the modified flags back into the buffer. We then write the buffer
        flags back to the table, causing the corresponding data to be
        marked flagged on subsequent access. Finally we clear the internal
        buffer. This step can be omitted if you are about to do another fillbuffer().


        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_clearbuffer(self)

    def continuumsub(self, *args, **kwargs):
        """
        continuumsub(self, field=initialize_variant(""), fitspw=initialize_variant(""), spw=initialize_variant(""), 
            solint=initialize_variant("int"), fitorder=0, mode=string("subtract")) -> bool

        Summary
        	Continuum fitting and subtraction in uv plane

        Description
        	 
        This function provides a means of continuum determination and
        subtraction by fitting a polynomial of desired order to a subset of
        channels in each time-averaged uv spectrum.  The fit is used to model
        the continuum in all channels (not just those used in the fit), for
        subtraction, if desired.  Use the {	t fitspw} parameter to limit the
        spectral windows processed and the range of channels used to estimate 
        the continuum  in each (avoid channels containing spectral lines).  The 
        default solution interval 'int' will result in per-integration continuum
        fits for each baseline.  The {	t mode} parameter indicates 
        how the continuum model (the result of the fit) should be used: 
        {	t 'subtract'} will store the continuum
        model in the MODEL\_DATA column and subtract it from the CORRECTED\_DATA
        column; {	t 'replace'} will replace the CORRECTED\_DATA column with
        the continuum model (useful if you want to image the continuum model
        result); and {	t 'model'} will only store the continuum model in the
        MODEL\_DATA column (the CORRECTED\_DATA is unaffected).

        It is important to start the ms tool with {	t nomodify=False} so that
        changes to the dataset will be allowed (see example below).

        For now, the only way to recover the un-subtracted CORRECTED\_DATA column
        is to use calibrater.correct() again.

        Note that the MODEL\_DATA and CORRECTED\_DATA columns must be present
        for {	t continuumsub} to work correctly.  The function will warn the user
        if they are not present, and abort.  To add these scratch columns (for
        now), close the ms tool, then start a calibrater or an imager
        tool, which will add the scratch columns.  Then restart the ms tool,
        and try {	t continuumsub} again.

        Options for shifting known bright sources to the phase center and
        for editing based on the rms fit will be added in the near future.

          

        Input Parameters:
        	field		 Select fields to fit 
        	fitspw		 Spectral windows/channels to use for fitting the continuum; default all spectral windows in all channels 
        	spw		 Select spectral windows and channels from which to subtract a continuum estimate; default: all channels in all spectral windows for which the continuum was estimated 
        	solint		 Continuum fit timescale (units optional) int 
        	fitorder	 Polynomial order for fit 0 
        	mode		 Desired use of fit model (see below) subtract 
        	
        Example:
        	
            
         ms.fromfits('ngc5921.ms','/aips++/data/demo/NGC5921.fits')
         ms.close()
         cb.open('ngc5921.ms')  # add MODEL_DATA, CORRECTED_DATA columns
         cb.close()
         ms.open('ngc5921.ms',nomodify=False);    # writable!
         ms.continuumsub(fldid=2,fitspw='0:5~9;50~59',
                         solint=0.0,fitorder=1,mode='sub')
         ms.done()
            
            This example will fit a linear continuum to channels 5-9 and 50-59 in 
            spectral window 0 in each scan-averaged spectrum for field 2, and 
            store the result in the MODEL\_DATA column and subtract it from the 
            CORRECTED\_DATA column.

          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_continuumsub(self, *args, **kwargs)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Closes the ms tool

        Description
        	
            You should call close() when you are finished using the ms
            	ool\  
            to close the measurement set table and free any associated file
            locks. The measurement set is not deleted. 
          
        Example:
        	
            
              ms.open('3C273XC1.MS')
              ...
              ms.done()
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_done(self)

    def msseltoindex(self, *args, **kwargs):
        """
        msseltoindex(self, vis=string(""), spw=initialize_variant(""), field=initialize_variant(""), baseline=initialize_variant(""), 
            time=initialize_variant(""), scan=initialize_variant(""), 
            uvrange=initialize_variant(""), observation=initialize_variant(""), 
            polarization=initialize_variant(""), taql=string("")) -> record *

        Summary
        	Returns ids of the selection used

        Description
        	 
         Utility function that will return the ids of the selection used. 
          

        Input Parameters:
        	vis		 Measurementset for which this selection applies 
        	spw		 Spectral Window Ids (0 relative) to select; -1 interpreted as all 
        	field		 Field Ids (0 relative) or Field names (msselection syntax and wilcards are used) to select 
        	baseline	 Antenna Ids (0 relative) or Antenna names (msselection syntax and wilcards are used) to select 
        	time		 Limit data selected to be within a given time range. Syntax is the defined in the msselection link 
        	scan		 Limit data selected on scan numbers. Syntax is the defined in the msselection link 
        	uvrange		 Limit data selected on uv distance. Syntax is the defined in the msselection link 
        	observation	 Select data by observation ID(s). The syntax is the same as for scan numbers. 
        	polarization	 Select data by polarization(s). 
        	taql		 For the TAQL experts, flexible data selection using the TAQL syntax 
        	
        Example:
        	
             a= ms.msseltoindex(vis='3C273XC1.MS', field='3C*')
             print a['field']
             # [0]
             print a
             #{'antenna1': array([], dtype=int32),
             # 'antenna2': array([], dtype=int32),
             #  'channel': array([], shape=(0, 0), dtype=int32),
             #  'field': array([0]),
             #  'scan': array([], dtype=int32),
             #  'spw': array([], dtype=int32),
             #  'obsids': array([], dtype=int32)}
            

          Field name '3C*', in this case 3C273, corresponds to field id 0.

          N.B.: The return values of unspecified fields (like antenna* and spw in the
                above example) will be left empty - this does not mean that selection
                excludes all antennas!

                Some fields (like 'field') are checked against the subtables of vis,
                but others are not.  For example, field='123~132' will produce an error
                if vis does not have fields 123 to 132, but for scan and obsids
                '123~132' would just return an array of integers from 123 to 132
                regardless of whether vis has those scan or observation IDs.  (The
                difference comes from it being quicker to check a subtable than the
                main table.)
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_msseltoindex(self, *args, **kwargs)

    def hanningsmooth(self, *args, **kwargs):
        """
        hanningsmooth(self, datacolumn=string("corrected")) -> bool

        Summary
        	Hanning smooth the frequency channels to remove Gibbs ringing.

        Description
        	
            This function Hanning smooths the frequency channels with a
            weighted running average of smoothedData[i] =
            0.25*correctedData[i-1] + 0.50*correctedData[i] +
            0.25*correctedData[i-1].  The first and last channels are flagged.
            Inclusion of a flagged value in an average causes that averaged data value
            to be flagged.
          

        Input Parameters:
        	datacolumn	 the name of the MS column into which to write the smoothed data corrected 
        	
        Example:
        	
            
            ms.open('ngc5921.ms',nomodify=False)
            ms.hanningsmooth('data')
            ms.close()
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_hanningsmooth(self, *args, **kwargs)

    def uvsub(self, reverse=False):
        """
        uvsub(self, reverse=False) -> bool

        Summary
        	Subtract model from the corrected visibility data.

        Description
        	
            This function subtracts model visibility data from corrected visibility
            data leaving the residuals in the corrected data column.  If the parameter
            reverse is set True, this process is reversed.
          

        Input Parameters:
        	reverse		 When False subtracts model from visibility data; when True adds model to visibility data false 
        	
        Example:
        	
          The following example subtracts a model from the visibility data leaving
          the residuals in the corrected data column.
            
           ms.open('ngc5921.ms',nomodify=False)
           ms.uvsub()
           ms.close()    
            
           The following example adds the model back into the residuals.
            
           ms.open('ngc5921.ms',nomodify=False)
           ms.uvsub(reverse=True)
           ms.close()    
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_uvsub(self, reverse)

    def moments(self, *args, **kwargs):
        """
        moments(self, moments=initialize_vector(1, (int)0), antenna=initialize_variant(""), field=initialize_variant(""), 
            spw=initialize_variant(""), includemask=initialize_vector(1, (double)-1), 
            excludemask=initialize_vector(1, (double)-1), peaksnr=0.0, 
            stddev=0.0, doppler=string(""), outfile=string(""), overwrite=False, async=False) -> casac::table *

        Summary
        	Calculate moments from MS with FLOAT_DATA column.

        Description
        	
             This function generates moments from the MS data. It is only applicable 
             for single-dish MS, i.e., the MS must have FLOAT\_DATA column. Results are 
             stored separate MSs for each moment. The function returns a table object 
             of the MS that stores a first moment in its FLOAT\_DATA column.

             This is defined by analogy with ia.moments(). It allows to generate moments 
             along any axis (spectral axis, direction, and polarization), while ms.moments() 
             only accepts to generate moments along the spectral axis.

             The available moments are:

             egin{itemize}
             \item{$-1$} -- the mean value of the spectrum 
             egin{displaymath}
             { {1\over n}  {\sum {I_i}}}
             nd{displaymath}
             \medskip

             \item{0} -- the integrated value of the spectrum 
             egin{displaymath}
             M_0 = \Delta v \sum I_i
             nd{displaymath}

             where $\Delta v$ is the width (in world coordinate units) of a pixel
             along the moment axis  
             \medskip

             \item{1} -- the intensity weighted coordinate (this is
             traditionally used to get 'velocity fields')

             egin{displaymath}
             M_1 = { {\sum {I_i v_i}} \over {M_0}}
             nd{displaymath}
             \medskip

             \item{2} -- the intensity weighted dispersion of the coordinate 
             (this is traditionally used to get 'velocity dispersion fields')

             egin{displaymath}
             \sqrt{ { {\sum {I_i \left(v_i - M_1right)^2}} \over {M_0}}}
             nd{displaymath}
             \medskip

             \item{3} -- the median of $I$
             \medskip

             \item{4} -- the median coordinate.  Here we treat the spectrum as a
             probability distribution, generate the cumulative distribution, and then
             find the coordinate corresponding to the 50\% value.  This moment is not
             very robust, but it is useful for quickly generating a velocity field in
             a way that is not sensitive to noise.  However, it will only give
             sensible results under certain conditions.  The generation of the
             cumulative distribution and the finding of the 50\% level really only
             makes sense if the cumulative distribution is monotonic.  This
             essentially means only selecting pixels which are positive or negative. 
             For this reason, this moment type is only supported with the basic
             method (see below -- i.e.  no smoothing, no windowing, no fitting) with
             a pixel selection range that is either all positive, or all negative
             \medskip

             \item{5} -- the standard deviation about the mean of the spectrum 
             egin{displaymath}
             \sqrt{ {1\over {\left(n-1right)}}  \sum{\left(I_i - ar{I}right)^2 }}
             nd{displaymath}
             \medskip

             \item{6} -- the root mean square of the spectrum 
             egin{displaymath}
             \sqrt{ {1 \over n} \sum{I_i^2}}
             nd{displaymath}
             \medskip

             \item{7} -- the absolute mean deviation of the spectrum 
             egin{displaymath}
             {1 \over n} \sum {|(I_i - ar{I})|}
             nd{displaymath}
             \medskip

             \item{8} -- the maximum value of the spectrum
             \medskip
             \item{9} -- the coordinate of the maximum value of the spectrum
             \medskip
             \item{10} -- the minimum value of the spectrum
             \medskip
             \item{11} -- the coordinate of the minimum value of the spectrum
             \medskip
             nd{itemize}

          

        Input Parameters:
        	moments		 A list of moments that you want to compute. Default is an integrarted spectrum. 0 
        	antenna		 antenna name or id 
        	field		 field name or id 
        	spw		 spectral window id 
        	includemask	 A range of masks to be included when moments are computed. Default is -1 (all channels). -1 
        	excludemask	 A range of masks to be excluded when moments are computed. Default is -1 (do not exclude channels). -1 
        	peaksnr		 The SNR ratio that is a lower limit to be included a moment calculation (not implemented yet). 0.0 
        	stddev		 Standard deviation of the noise signal in the spectra (used by the window and fit functions only). 0.0 
        	doppler		 Velocity doppler definition for velocity computations along spectral axes. 
        	outfile		 Output MS file name (or root for multiple moments). Default is input + an auto-determined suffix. 
        	overwrite	 Overwrite existing output file. false 
        	async		 Run asynchronously? false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_moments(self, *args, **kwargs)

    def addephemeris(self, *args, **kwargs):
        """
        addephemeris(self, id=-1, ephemerisname=string(""), comment=string(""), field=initialize_variant("")) -> bool

        Summary
        	Connect an ephemeris table with the MS FIELD table

        Description
        	

          

        Input Parameters:
        	id		 The unique id number to give to this ephemeris (will overwrite pre-existing ephemeris of same id, -1 will use next unused id) -1 
        	ephemerisname	 The name of the ephemeris table which is to be copied into the MS 
        	comment		 Comment string (no spaces, will be part of a file name) 
        	field		 Field id(s) (0-based) or fieldname(s) to connect this ephemeris to 
        	
        Example:
        	
            
              ms.addephemeris(id=0, ephemerisname='Titan_55002-55003dUTC.tab', comment='JPLTitan', field='Titan')
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_addephemeris(self, *args, **kwargs)

    def ngetdata(self, *args, **kwargs):
        """
        ngetdata(self, items=std::vector< string >(1, ""), ifraxis=False, ifraxisgap=0, increment=1, average=False) -> record *

        Summary
        	
               Read values from the measurement set.  Use this method instead of
               the older getdata() method which is marked for deprecation.
             

        Description
        	
               This method extracs the data as specified in the items
               parameter.  The data is returned as a record with each item
               as a separate key in the record (all in lower case).

               Unless the iterator was initialized with a niterinit(), this
               method initializes the iterator
               as niterinit(['..'],0.0,0,False). 
             

        Input Parameters:
        	items		 Item names (NOT USED) 
        	ifraxis		 Create interferometer axis if True (NOT USED) false 
        	ifraxisgap	 Gap size on ifr axis when antenna1 changes (NOT USED) 0 
        	increment	 Row increment for data access (NOT USED) 1 
        	average		 Average the data in time or over rows (NOT USED) false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_ngetdata(self, *args, **kwargs)

    def niterinit(self, *args, **kwargs):
        """
        niterinit(self, columns=std::vector< string >(1, ""), interval=0.0, maxrows=0, adddefaultsortcolumns=True) -> bool

        Summary
        	
               Initialize for iteration over an ms.  Use
               this method instead of the older iterinit() method which is
               marked for deprecation.
             

        Description
        	
             

        Input Parameters:
        	columns		 Vector of column names (case sensitive). This parameter is not used and is here only for backwards compatibility with the iterinit() method. 
        	interval	 Time interval in seconds (greater than 0), to group together in iteration 0.0 
        	maxrows		 Max number of rows (greater than 0) to return in iteration. 0 
        	adddefaultsortcolumns	 Add the default sort columns true 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_niterinit(self, *args, **kwargs)

    def niterorigin(self):
        """
        niterorigin(self) -> bool

        Summary
        	
               Set the iterator to the start of the data.  Use this method
               instead of the older iterorigin() method which is marked for
               deprecation.
             

        Description
        	
               Set or reset the iterator to the start of the currently
               specified iteration. You need to call this before attempting to
               iteratively retrieve data with ngetdata. You can set the
               iteration back to the start before you reach the end of the
               data.  You need to call iterinit before calling this.  See the
               example below.
             
        Example:
        	
               See the example for the niterend function.
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_niterorigin(self)

    def niternext(self):
        """
        niternext(self) -> bool

        Summary
        	
               Advance the iterator to the next lot of data.  Use
               this method instead of the older iternext() method which is
               marked for deprecation.
             

        Description
        	
               This sets the currently selected table (as accessed with
               ngetdata) to the next iteration. If there is no more data, the
               function returns False.  You need to call iterinit and
               iterorigin before calling this.  See the example below.
             
        Example:
        	
               See the example for the niterend function.
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_niternext(self)

    def niterend(self):
        """
        niterend(self) -> bool

        Summary
        	
               Query if there are more iterations left in the iterator.  Use
               this method instead of the older iterend() method which is marked
               for deprecation.
             

        Description
        	
               The serves redundant purpose and is here only for backward
               compatibility.
               
               This method returns True if there are no more iterations left.
               I.e., the iterations have ended.  This same information is also
               returned by niternext().

               With the use of the VisibilityIterator in the niterinit(),
               niterorigin(), niternext() methods, the iterator is set to the
               original state by calling niterinit() at any time.

               See the example below.
             
        Example:
        	
               ms.open('3C273XC1.MS')
               staql={'baseline':'1 & 2'};
               ms.msselect(staql);
               ms.niterinit([' '],60.0)
               ms.niterorigin()
               while (!ms.niterend()):
                  rec=ms.ngetdata(['u','v','data'])
                  ms.niternext()
               ms.close()
               
               We open the MS, select a baseline and then specify an iteration
               over time, with a 60s time interval.  We then set the iterator
               to the start of the data and get out some data.  We advance the
               iterator to the next lot of data and continue till the end of
               iterations is indicated.  Finally, we close the ms tool which
               restores the tool to its original state.
             
        --------------------------------------------------------------------------------
        	      
        """
        return _ms.ms_niterend(self)

ms_swigregister = _ms.ms_swigregister
ms_swigregister(ms)

# This file is compatible with both classic and new-style classes.


