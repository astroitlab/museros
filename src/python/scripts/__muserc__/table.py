# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_table', [dirname(__file__)])
        except ImportError:
            import _table
            return _table
        if fp is not None:
            try:
                _mod = imp.load_module('_table', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _table = swig_import_helper()
    del swig_import_helper
else:
    import _table
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class table(_object):
    """Proxy of C++ casac::table class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, table, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, table, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> table"""
        this = _table.new_table()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _table.delete_table
    __del__ = lambda self : None;
    def fromfits(self, *args, **kwargs):
        """
        fromfits(self, tablename, fitsfile, whichhdu=1, storage=string("standard"), convention=string("none"), 
            nomodify=True, ack=True) -> table

        Summary
        	Create a casa table from a binary FITS file

        Description
        	
        Create a table from binary FITS format. This generates a CASA table
        from the binary FITS table in the given HDU (header unit) of the
        FITS file. Note that other FITS formats ({m e.g.}
        Image FITS and UVFITS) are read by other means.
        \It is possible to specify the storage manager to use for the table:
        \	exttt{standard} is the default storage manager.
        \	exttt{incremental} is efficient for slowly varying data.
        \	exttt{memort} is for in memory use for e.g to grab given columns via getcol.


        Input Parameters:
        	tablename	 Name of table to be created 
        	fitsfile	 Name of FITS file to be read 
        	whichhdu	 Which HDU to read (0-relative to primary HDU i.e. 1 is the smallest valid value) 1 
        	storage		 Storage manager to use (standard or incremental or memory) standard standard incremental memory 
        	convention	 Convention to use (sdfits or none) none 
        	nomodify	 Open Read-only? true 
        	ack		 Acknowledge creations, etc true 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_fromfits(self, *args, **kwargs)

    def fromascii(self, *args, **kwargs):
        """
        fromascii(self, tablename, asciifile, headerfile=string(""), autoheader=False, autoshape=initialize_vector(1, (int)-1), 
            sep=string(""), commentmarker=string(""), firstline=0, 
            lastline=-1, nomodify=True, columnnames=std::vector< string >(1, ""), datatypes=std::vector< string >(1, "")) -> bool

        Summary
        	Create a casa table from a file containing data in ASCII format

        Description
        	
        Create a table from an ASCII file. Columnar data as well as
        table and column keywords may be specified.
        \Once the table is created from the ASCII data, it is opened in the
        specified mode by the table tool. 

        The table columns are filled from a file containing the data values
        separated by a separator (one line per table row). The default
        separator is a blank. Blanks after the separator are ignored.
        \If a non-blank separator is used, values can be empty. Such values
        default to 0, empty string, or F depending on the data type. E.g.
        1,,2, has 4 values of which the 2nd and 4th are empty and default to 0.
        Similarly if fewer values are given than needed, the missing values
        get the default value.

        Either the data format can be explicitly specified or it can be found
        automatically. The former gives more control in ambiguous situations.
        Both scalar and array columns can be generated from the ASCII input.
        The format string determines the type and optional shape.

        In automatic mode (	exttt{autoheader=True}) the first line
        of the ASCII data is analyzed
        to deduce the data types. Only the types I, D, and A can be
        recognized. A number without decimal point or exponent is I (integer),
        otherwise it is D (double). Any other string is A (string).
        Note that a number may contain a leading sign (+ or -).
        The 	exttt{autoshape} argument can be used to specify if the input
        should be stored as multiple scalars (the default) or as a single
        array. In the latter case one axis in the shape can be defined as
        variable length by giving it the value 0. It means that the actual
        array shape in a row is determined by the number of values in the
        corresponding input line.
        Columns get the names 	exttt{Column1}, 	exttt{Column2}, etc..
        \For example:
        egin{enumerate}
        \item
        	exttt{autoshape=[]} (which is the default) means that all values
        are to be stored as scalar columns.
        \item
        	exttt{autoshape=0} means that all values in a row are to be stored as
        a variable length vector.
        \item
        	exttt{autoshape=10} defines a fixed length vector. If an input
        line contains less than 10 values, the vector is filled with default
        values. If more than 10 values, the latter values are ignored.
        \item
        	exttt{autoshape=[5,0]} defines a 2-dim array of which the 2nd axis is
        variable. Note that if an input line does not contain a multiple of 5
        values, the array is filled with default values.
        nd{enumerate}

        If the format of the table is explicitly specified, it has to be done
        either in the first two lines of the data file (named by the
        argument filename), or in a separate header file (named by the
        argument headerfile). In both forms, table keywords may also be
        specified before the column definitions.
        The column names and types can be described by two lines:

        egin{enumerate}
        \item The first line contains the names of the columns.
        These names may be enclosed in quotes (either single or double). 
        \item The second line contains the data type and optionally the shape
        of each column. Valid types are: 
        egin{itemize}
        \item S for Short data 
        \item I for Integer data 
        \item R for Real data 
        \item D for Double Precision data 
        \item X for Complex data (Real followed by Imaginary) 
        \item Z for Complex data (Amplitude then Phase) 
        \item DX for Double Precision Complex data (Real followed by Imaginary) 
        \item DZ for Double Precision Complex data (Amplitude then Phase) 
        \item A for ASCII data (a value must be enclosed in single or double quotes
                if it contains whitespace) 
        \item B for Boolean data (False are empty string, 0, or any string
                starting with F, f, N, or n).
        nd{itemize}
        nd{enumerate}
        If a column is an array, the shape has to be given after the data type
        without any whitespace. E.g. 	exttt{I10} defines an integer vector
        of length 10. 	exttt{A2,5} defines a 2-dim string array with shape
        [2,5]. Note that 	exttt{I} is not the same as 	exttt{I1} as the
        first one defines a scalar and the other one a vector with length 1.
        The last column can have one variable length axis denoted by the value
        0. It 'consumes' the remainder of the input line.

        If the argument headerfile is set then the header information is
        read from that file instead of the first lines of the data file.

        To give a simple example of the form where the header information
        is located at the top of the data file:

        egin{verbatim}
        COLI   COLF   COLD       COLX        COLZ       COLS
         I      R      D          X           Z          A
        1      1.1    1.11       1.12 1.13   1.14 1.15  Str1
        10     11     12         13   14     15   16    ''
        nd{verbatim}
        Note that a complex number consists of 2 numbers.
        \Also note that an empty string can be given.

        Let us now give an example of a separate header file that one might use to get
        interferometer data into \casa:

        egin{verbatim}
        U     V      W         TIME        ANT1       ANT2      DATA
        R     R      R          D           I          I        X1,0
        nd{verbatim}

        The data file would then look like:

        egin{verbatim}
        124.011 54560.0  3477.1  43456789.0990    1      2        4.327 -0.1132
        34561.0 45629.3  3900.5  43456789.0990    1      3        5.398 0.4521
        nd{verbatim}
        Note that the DATA column is defined as a 2-dim array of 1
        correlation and a variable number of channels, so the actual number of
        channels is determined by the input. In this example both rows will
        have 1 channel (note that a complex value contains 2 values).

        Tables may have keywords in addition to the columns. The keywords
        are useful for holding information that is global to the entire
        table (such as author, revision, history, {m etc,}).
        \The keywords in the header definitions must preceed the column descriptions.
        They must be enclosed between a line that starts with '.key...' and
        a line that starts with '.endkey...' (where ... can be anything).
        Between these two lines each
        line should contain the following as listed below.
        A table keywordset and column keywordsets can be specified.
        The latter can be specified by specifying the column name after the
        .keywords string.

        egin{itemize}
        \item The keyword name, e.g., ANYKEY 
        \item The datatype and optional  shape of the keyword
              (cf. list of valid types above) 
        \item The value or values for the keyword (the keyword may contain 
        a scalar or an array of values). e.g., 3.14159 21.78945 
        nd{itemize}

        Thus to continue the example above, one might wish to add keywords
        as follows:

        egin{verbatim}
        .keywords
        DATE        A  '97/1/16'
        REVISION    D 2.01
        AUTHOR      A 'Tim Cornwell'
        INSTRUMENT  A 'VLA'
        .endkeywords
        .keywords TIME
        UNIT A 's'
        .endkeywords
        U     V      W         TIME        ANT1       ANT2      DATA
        R     R      R          D           I          I        X1,0
        nd{verbatim}
        Similarly to the column format string, the keyword formats can also
        contain shape information. The only difference is that if no shape is
        given, a keyword can have multiple values (making it a vector).

        It is possible to ignore comment lines in the header and data file
        by giving the 	exttt{commentmarker}. It indicates that lines
        starting with the given marker are ignored. Note that the marker can
        be a regular expression (e.g. texttt{' *//'} tells that lines starting
        with // and optionally preceeded by blanks have to be ignored).

        With the arguments 	exttt{firstline} and 	exttt{lastline} one can
        specify which lines have to be taken from the input file. A negative value
        means 1 for 	exttt{firstline} or end-of-file for 	exttt{lastline}.
        Note that if the headers and data are combined in one file,
        these line arguments apply to the whole file. If headers and data are in
        separate files, these line arguments apply to the data file only.

        Also note that ignored comment lines are counted, thus are used to
        determine which lines are in the line range.

        The number of rows is determined by the number of lines read from the data
        file. 


        Input Parameters:
        	tablename	 Name of table to be created 
        	asciifile	 Name of ASCII file to be read 
        	headerfile	 Name of an optional file defining the format 
        	autoheader	 Determine header information automatically false 
        	autoshape	 Shape to be used if autoheader=True -1 
        	sep		 Value separator 
        	commentmarker	 Regex indicating comment line 
        	firstline	 First line to use 0 
        	lastline	 Last line to use -1 
        	nomodify	 Open Read-only? true 
        	columnnames	 Column Names 
        	datatypes	 Data types 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_fromascii(self, *args, **kwargs)

    def open(self, *args, **kwargs):
        """
        open(self, tablename=string(""), lockoptions=initialize_record("default"), nomodify=True) -> bool

        Summary
        	open an existing table

        Description
        	
        	Opens a disk file containing an existing \casa\ Table.

        Most of the time you just need to specify the tablename and perhaps
        nomodify.

        A table can be shared by multiple processes by using the appropriate
        locking options. The possible options are:
        \- auto: let the system take care of locking. At regular time
        intervals these autolocks are released to give other processes the
        opportunity to access the table. 
        \- autonoread: as auto, but no read locking is needed. This must be
        used with care, because it means that reading can be done while
        the table tool is not synchronized with the table file (as is
        normally done when a lock is acquired). The function 	exttt{resync}
        can be used to explicitly synchronize the table tool
        \- user: the user takes care by explicit calls to lock and unlock
        \- usernoread: as user and the no readlocking behaviour of autonoread.
        \- permanent: use a permanent lock; the constructor fails when the table is
        already in use in another process
        \- permanentwait: as above, but wait until the other process
        releases its lock
        \- default: this is the default option.
        If the given table is already open, the locking option in use is not
        changed. Otherwise it reverts to auto.
        \When auto locking is used, it is possible to give a record containing
        the fields option, interval, and/or maxwait. In this way advanced
        users have full control over the locking options. In practice this is
        hardly ever needed.




        Input Parameters:
        	tablename	 
        	lockoptions	 locking to be used default 
        	nomodify	 true 
        	
        Example:
        	


          # First let's make a table for testing
          def maketesttable():
              # Get path to CASA home directory by stipping name from '$CASAPATH'
              pathname=os.environ.get('CASAPATH').split()[0]
              # This is where the 3C273XC1.fits data should be
              fitsdata=pathname+'/data/demo/3C273XC1.fits'
              # Remove old table if present
              !rm -rf 3C273XC1.MS
              ms.fromfits('3C273XC1.MS',fitsdata)
              ms.close()

          maketesttable()
          tb.open('3C273XC1.MS')
          tb.browse()
          tb.close()


        The first line opens an existing table 3C273XC1.MS, the second browses
        it using the browse function.


          tb.open('3C273XC1.MS', nomodify=False, lockoptions='user')
          tb.lock();
          tb.addrows();
          tb.unlock();


        In this example explicit user locking is used. The function lock
        is needed to acquire a (write) lock before the addrows is done.
        Thereafter the lock is released to give other processes the chance
        to operate on the table.
        \Note that releasing a lock implies flushing the table, so doing
        that very often can be quite expensive.


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_open(self, *args, **kwargs)

    def create(self, *args, **kwargs):
        """
        create(self, tablename=string(""), tabledesc=initialize_record(""), lockoptions=initialize_record("default"), 
            endianformat=string(""), memtype=string(""), nrow=0, dminfo=initialize_record("")) -> bool

        Summary
        	create a new table

        Description
        	
        	Create a new \casa\ Table.

        Most of the time you just need to specify the table's name and a description of
        its format.

        A table can be shared by multiple processes by using the appropriate
        locking options. The possible options are:
        \- auto: let the system take care of locking. At regular time
        intervals these autolocks are released to give other processes the
        opportunity to access the table. 
        \- autonoread: as auto, but no read locking is needed. This must be
        used with care, because it means that reading can be done while
        the table tool is not synchronized with the table file (as is
        normally done when a lock is acquired). The function 	exttt{resync}
        can be used to explicitly synchronize the table tool
        \- user: the user takes care by explicit calls to lock and unlock
        \- usernoread: as user and the no readlocking behaviour of autonoread.
        \- permanent: use a permanent lock; the constructor fails when the table is
        already in use in another process
        \- permanentwait: as above, but wait until the other process
        releases its lock
        \- default: this is the default option.
        If the given table is already open, the locking option in use is not
        changed. Otherwise it reverts to auto.
        \When auto locking is used, it is possible to give a record containing
        the fields option, interval, and/or maxwait. In this way advanced
        users have full control over the locking options. In practice this is
        hardly ever needed.




        Input Parameters:
        	tablename	 
        	tabledesc	 description of the table's format 
        	lockoptions	 locking to be used default 
        	endianformat	 
        	memtype		 
        	nrow		 0 
        	dminfo		 Data Manager information 
        	
        Example:
        	


          # First let's get sample descriptions of a table and its data managers.
          import os, shutil

          def get_tabledesc_and_dminfo(tabname='3C273XC1.MS'):
              made_copy = False

              # Fetch new table if tabname not present
              if not os.path.isdir(tabname):
                  # Get path to CASA root directory by stripping name from '$CASAPATH'
                  pathname = os.environ.get('CASAPATH').split()[0]

                  # There should be some data here
                  fitsdata = pathname + '/data/demo/3C273XC1.fits'
                  tabname = '3C273XC1.MS'

                  ms.fromfits(tabname, fitsdata)
                  ms.close()
                  made_copy = True

              tb.open(tabname)
              tabdesc = tb.getdesc()
              dminfo  = tb.getdminfo()
              print tabname, 'has', tb.nrows(), 'rows.'
              tb.close()

              # Clean up
              if made_copy:
                  shutil.rmtree(tabname)

              return tabdesc, dminfo

          tabdesc, dmi = get_tabledesc_and_dminfo()
          tabdesc  # prints tabdesc
          dmi      # prints dmi

          # You could alter tabdesc and/or dmi at this point.

          # Unnecessary, but just to show there is nothing up my sleeve...
          tb.close()

          tb.create('myempty.ms', tabdesc, dminfo=dmi)
          tb.nrows()     # 0L
          tb.addrows(5)  # Add the rows _before_ filling the columns.
          tb.putcol('ARRAY_ID', numpy.array([0 for i in range(5)]))
          tb.putcol('ANTENNA1', numpy.array(range(5)))
          tb.putcol('ANTENNA2', numpy.array(range(1,6)))
          tb.browse()    # Still mostly, but not completely, empty.
          tb.close()


        This creates a CASA table using a description of a table and its data managers from an existing MS.


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_create(self, *args, **kwargs)

    def flush(self):
        """
        flush(self) -> bool

        Summary
        	flush the current contents to disk

        Description
        	
        Until a flush is performed, the results of all operations
        are not reflected in any change to the
        disk file. Hence you {m must} do a flush to write the changes
        to disk.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_flush(self)

    def fromASDM(self, *args, **kwargs):
        """
        fromASDM(self, tablename, xmlfile) -> bool

        Summary
        	Create an CASA table from an ASDM table

        Description
        	
        .keywords
        DATE        A  '07/7/23'
        REVISION    D 0 
        AUTHOR      A 'Paulo C. Cortes'
        INSTRUMENT  A 'ALMA'
        .endkeywords

        The main function for this task is to create a CASA::Table from a XML  ASDM Table. The classes asdmCasaXMLUtil and asdmCasaSaxHandler are the main objects which
        implement the task. The asdmCasaSaxHandler encapsulate all the operations 
        returning a reference to a CASA::Table. The class uses xerces-c to parse the
        XML table and creates the CASA::Table. The implementation assumes the integrity
        of the XML data, it not attempting to check whether the XML  data meets a 
        column format or not. In detail, an ArrayString column should agree with
        the following format: nd nx ... data, where nd is the number of dimensions,
        nx is the size of the first dimension (implemented upto a cube, i.e. nx,ny,nz),
        and data is the array itself which should have the appropiate number of 
        elements. For example, a VectorString column could be: 1 2 'I' 'Q' or 
        dimension 1, size 2, and two string elements. Due to the lack of data type
        spefication in the XML tables, the column names are hardcoded into the 
        asdmCasaSaxHandler based on the ASDM specification (see 
        http://aramis.obspm.fr/~alma/ASDM/ASDMEntities/index.html). 
        While missing data from a table column will be accepted by the task, 
        any new column beyond the specification has to be added into the class, also,
        any change in data types form the specificatin will produce a crash, CASA
        is picky with data types integrity. So far, the list of tables included in 
        the class is:

        AlmaCorrelatorMode.xml,
        Antenna.xml
        ConfigDescription.xml,
        DataDescription.xml,
        ExecBlock.xml,
        Feed.xml,
        Field.xml,
        Main.xml,
        Polarization.xml,
        Processor.xml,
        Receiver.xml,
        SBSummary.xml,
        Scan.xml,
        Source.xml,
        SpectralWindow.xml,
        State.xml,
        Station.xml,
        Subscan.xml,
        SwitchCycle.xml,
        CalCurve.xml,
        CalData.xml,
        CalPhase.xml

        more tables will follow. The usage of fromASDM is simple, it gets two
        string, tablename and xmlfile, where tablename is the CASA::Table to be
        written and xmlfile represents the ASDM XML table. To call it do:
        tb.fromasdm(tablename,xmlfile)



        Input Parameters:
        	tablename	 Name of table to be created 
        	xmlfile		 Name of the XML file to be read 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_fromASDM(self, *args, **kwargs)

    def resync(self):
        """
        resync(self) -> bool

        Summary
        	resync the table tool with table file

        Description
        	
        Acquiring a read or write lock automatically synchronizes the internals
        of the table tool with the actual contents of the table files.
        In this way different processes accessing the same table always
        use the same table data.
        \However, a table can be used without read locking. In that case
        the table tool internals are not synchronized automatically.
        The resync function offers a way to do explicit synchronization.
        It is only useful if the table is opened with locking mode
        	exttt{autonoread} or 	exttt{usernoread}.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_resync(self)

    def close(self):
        """
        close(self) -> bool

        Summary
        	close the table tool

        Description
        	
        First a flush is done, then the table is closed inside casapy and
        is no longer available for use.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_close(self)

    def copy(self, *args, **kwargs):
        """
        copy(self, newtablename, deep=False, valuecopy=False, dminfo=initialize_record(""), endian=string("aipsrc"), 
            memorytable=False, returnobject=False, norows=False) -> table

        Summary
        	copy a table

        Description
        	
        Copy the table. All subtables are also copied.
        References to another table are preserved.

        The argument 	exttt{deep} determines how a reference table (i.e. the
        result of a query) is copied. By default
        a file copy is made, thus the resulting table still contains
        references and no actual data. If, however, 	exttt{deep=True} is given,
        a deep copy is made which means that the actual data are copied. Also
        all subtables are copied.
        \Normally a plain table is copied by copying the files. However,
        if 	exttt{deep=True} and 	exttt{valuecopy=True} are given, a plain table is
        copied by copying all its values and subtables. This is useful to
        reorganize the tables, i.e. to regain file space that is wasted by
        frequent updates to a table.
        \The argument 	exttt{dminfo} can be used to specify explicit data
        manager info for the columns in the new plain table. It can be used to
        change, for example, a storage manager from IncrStMan to StandardStMan.
        The 	exttt{dminfo} is a record as returned by the
        getdminfo
        If 	exttt{dminfo} is a non-empty record, it forces 	exttt{valuecopy=True}.

        The standard operation is make the copy to a plain table. It is,
        however, possible to copy to a memory table by giving 	exttt{memorytable=True}.

        The endian format for the newly created table can be specified. This
        is only meaningful if a deep copy is made to a plain table.
        The possible values are:
        \- big: big endian format (as used on e.g. SUN)
        \- little: little endian format (as used on e.g. PC)
        \- local: use the endian format of the machine being used
        \- aipsrc: use the endian format specified in aipsrc variable
        table.endianformat (which defaults to big).
        \The default is aipsrc.

        Normally the 	exttt{copy} function only copies the table and does not
        create a new table tool object. The user can do that by opening the newly
        created table in the standard way. However, it is possible to get an
        object back by using 	exttt{returnobject=True}. An object is always
        returned if the copy is made to a memory table.


        Input Parameters:
        	newtablename	 Name of newtable on disk 
        	deep		 Make a deep copy of a reference table? false 
        	valuecopy	 Make a deep copy of any table? false 
        	dminfo		 Data manager info for new table 
        	endian		 Endian format of new table aipsrc 
        	memorytable	 Hold new table in memory? false 
        	returnobject	 Return a tool object for the new table false 
        	norows		 Don't copy any rows (useful for copying only the table structure) false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_copy(self, *args, **kwargs)

    def copyrows(self, *args, **kwargs):
        """
        copyrows(self, outtable, startrowin=0, startrowout=-1, nrow=-1) -> bool

        Summary
        	copy rows from this table to another

        Description
        	
        Copy rows from this table to another. By default all rows of this
        table are appended to the output table. It is possible though to
        control which rows are copied.
        \Rows are added to the output table as needed.
        Because no rows can be added to a reference table, it is only possible
        to overwrite existing rows in such tables.

        Only the data of columns existing in both tables will be copied.
        Thus by making a reference table consisting of a few columns, it
        is possible to copy those columns only.


        Input Parameters:
        	outtable	 table object of output table 
        	startrowin	 First row to take from input table 0 
        	startrowout	 First row to write in output table, -1 (=end) -1 
        	nrow		 Nr of rows to copy, -1 (=all) -1 
        	
        Example:
        	
        This example appends rows to the table itself, thus doubles the number
        of rows.

          tb.open('3C273XC1.MS',nomodify=False)
          tb.copyrows('3C273XC1.MS')
          tb.close()

        This example copies 10 rows of the selected subset of the MS to the
        beginning of the output MS.

          !rm -rf in.MS out.MS
          ms.fromfits('in.MS','3C273XC1.fits')       #Make two MSs
          ms.fromfits('out.MS','3C273XC1.fits')      #for example
          ms.close()
          tb.open('in.MS')
          t1 = tb.query('ANTENNA1==0')
          tb.close()
          t1.copyrows('out.MS',nrow=10,startrowout=0)
          t1.close()


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_copyrows(self, *args, **kwargs)

    def done(self):
        """
        done(self) -> bool

        Summary
        	end the table tool

        Description
        	
        Effectively a synonym for function close.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_done(self)

    def iswritable(self):
        """
        iswritable(self) -> bool

        Summary
        	is the table writable?

        Description
        	
        Test if the table is opened for write.


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_iswritable(self)

    def endianformat(self):
        """
        endianformat(self) -> string

        Summary
        	get the endian format used for this table

        Description
        	
        Get the endian format used for this table.
        It returns a string with value 'big' or 'little'.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_endianformat(self)

    def lock(self, write=True, nattempts=0):
        """
        lock(self, write=True, nattempts=0) -> bool

        Summary
        	acquire a lock on the table

        Description
        	
        Try to acquire a read or write lock on the table. Nothing will be
        done if the table is already correctly locked by this process.
        It is only needed when user locking is used.
        When the lock is acquired, the internal caches will be synchronized
        with the (possibly changed) contents of the table.
        \It is possible to specify the number of attempts to do (1 per
        second) in case the table is locked by another process. The default 0
        is trying indefinitely.


        Input Parameters:
        	write		 Write lock? (F=read lock) true 
        	nattempts	 Nr of attempts 0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_lock(self, write, nattempts)

    def unlock(self):
        """
        unlock(self) -> bool

        Summary
        	unlock and flush the table

        Description
        	
        The table is flushed and the lock on the table is released.
        This function is only needed when user locking is used.
        However, it is also possible to use it with auto locking. In that case
        the lock will automatically be re-acquired before the next table operation.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_unlock(self)

    def datachanged(self):
        """
        datachanged(self) -> bool

        Summary
        	has data changed in table?

        Description
        	
        This function tests if data in the table have changed (by another
        process) since the last call to this function.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_datachanged(self)

    def haslock(self, write=True):
        """
        haslock(self, write=True) -> bool

        Summary
        	has this process a lock on the table?

        Description
        	
        Has this process a read or write lock on the table?


        Input Parameters:
        	write		 Has it a write lock? (F=read lock) true 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_haslock(self, write)

    def lockoptions(self):
        """
        lockoptions(self) -> record *

        Summary
        	get the lock options used for this table

        Description
        	
        Get the lock options used for this table.
        It returns a record with the fields: option, interval and maxwait.
        The record can be used as the lockoptions argument when opening a table.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_lockoptions(self)

    def ismultiused(self, checksubtables=False):
        """
        ismultiused(self, checksubtables=False) -> bool

        Summary
        	is the table in use in another process?

        Description
        	
        Is the table still in use in another process?
        If so, the table cannot be deleted.


        Input Parameters:
        	checksubtables	 check if subtables are multiused?) false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_ismultiused(self, checksubtables)

    def browse(self):
        """
        browse(self) -> bool

        Summary
        	browse a table using a graphical browser

        Description
        	
        To start the browser, the environment variable
        DISPLAY must be set.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_browse(self)

    def name(self):
        """
        name(self) -> string

        Summary
        	return name of table on disk

        Description
        	
        Gives the name of the \casa\ table on disk that the
        table tool has open.

        Example:
        	

          tb.open('3C273XC1.MS')
          tb.name()
        # 3C273XC1.MS


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_name(self)

    def createmultitable(self, *args, **kwargs):
        """
        createmultitable(self, outputTableName, tables, subdirname) -> bool

        Summary
        	
        	Create a virtually concatenated table
        	

        Description
        	
                

        Input Parameters:
        	outputTableName	 name of the concatenated table 
        	tables		 list of the names of the tables to be concatenated 
        	subdirname	 optional name of the subdirectory into which the input tables are moved 
        	
        Example:
        	
                
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_createmultitable(self, *args, **kwargs)

    def toasciifmt(self, *args, **kwargs):
        """
        toasciifmt(self, asciifile, headerfile=string(""), columns=std::vector< string >(1, ""), sep=string("")) -> bool

        Summary
        	Write casa table into an ASCII format 

        Description
        	
        Write a table into an ASCII format approximately compatible with fromascii except that in order to permit variable shaped arrays (as they often occur in MSs), array values are output enclosed in square brackets. 
        The separator between values can be specified and defaults to a blank. Note that columns containing
        invalid data or record type data are ignored and a warning is issued.

        If the argument headerfile is set then the header information is
        written to that file instead of the first two lines of the data file.


        Input Parameters:
        	asciifile	 Name of ASCII file to be written 
        	headerfile	 Name of an optional file defining the format 
        	columns		 Names of columns to be written, default is all 
        	sep		 Value separator, default is one blank 
        	
        Example:
        	

        tb.toasciifmt(asciifile='myfile3.dat', headerfile='myfile3.head', columns=['SOURCE_ID', 'NAME', 'PROPER_MOTION'], sep=', ')


        will produce a comma separated ASCII output of the three columns 'SOURCE_ID', 'NAME', and 'PROPER_MOTION' in file 'myfile3.dat'
        and a format description in 'myfile3.head'. 


        tb.toasciifmt(asciifile='myfile.dat')


        will produce a space separated ASCII output of all table columns into file 'myfile.dat'
        with the first two lines containing a format description. 

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_toasciifmt(self, *args, **kwargs)

    def taql(self, *args, **kwargs):
        """
        taql(self, taqlcommand=string("TaQL expression")) -> table

        Summary
        	Make a table from a TaQL command. 

        Description
        	This method Expose TaQL to the user.
        		Details on TaQL maybe found at http://www.astron.nl/aips++/docs/notes/199

        Input Parameters:
        	taqlcommand	 TaQL expression TaQL expression 
        	
        Example:
        	
        	For more information on TaQL see http://www.astron.nl/aips++/docs/notes/199

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_taql(self, *args, **kwargs)

    def query(self, *args, **kwargs):
        """
        query(self, query=string("String"), name=string(""), sortlist=string(""), columns=string(""), 
            style=string("")) -> table

        Summary
        	Make a table from a query

        Description
        	
        Make a table from a query applied to the current table.  It is possible to
        specify column(s) and/or expressions to sort on and to specify the
        columns to be contained in the output table.  See the example below.
        A new 'on-the-fly' table tool is returned. The new (reference) table
        can be given a name and will then be written to disk. Note that the
        resulting table is just a reference to the original table.  One can
        make a deep copy of the query result using the copy function (see example).




        Input Parameters:
        	query		 Query string String 
        	name		 Name of resulting reference table 
        	sortlist	 Sort string (one or more expressions separated by commas) 
        	columns		 List of column names separated by commas 
        	style		 How to handle numeric ranges and order axes 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          subt=tb.query('OBSERVATION_ID==0',
                        sortlist='ARRAY_ID', columns='TIME, DATA, UVW')
          print subt.ncols()
        # 23
          tb.close()
          copyt = subt.copy ('3C273XC1_spw1.MS', True)
          subt.close()
          copyt.close()

        From the original table corresponding to the disk file 3C273XC1.MS, only rows
        with OBSERVATION\_ID equal to 0 are selected and sorted by ARRAY\_ID. Only the
        columns TIME DATA UVW are written. Thereafter a deep copy of the result is
        made.  This table query command is equivalent to the Table Query Language
        (TaQL) command

          SELECT TIME, DATA, UVW
          FROM 3C273XC1.MS
          WHERE OBSERVATION_ID==0
          ORDERBY ARRAY_ID

        See http://www.astron.nl/casacore/trunk/casacore/doc/notes/199.html for an explanation of TaQL.

        If 'style' is not blank, 'using style \<style\> ' is prepended to the
        query.  See
        http://www.astron.nl/casacore/trunk/casacore/doc/notes/199.html#x1-50002.2 for
        an explanation and list of choices for style.  The default (glish) style is
        1-based, inclusive end, and Fortran ordering.  You may prefer python (0-based,
        exclusive end, and C order) style.

        tb.open('any_data')
        tsel = tb.selectrows([0])
        print tsel.nrows() # returns 1
        tsel = tb.query('ROWNUMBER()==0')
        print tsel.nrows() # returns 0
        tsel = tb.query('ROWNUMBER()==0', style='python')
        print tsel.nrows() # returns 1
        tb.close()

        Note that style had no effect on the 'OBSERVATION_ID==0' query above.


        Example:
        	
        The sortlist argument can be used to sort in ascending or descending
        order (or a mix of them) on one or more columns. Default is ascending.
        It is also possible to remove duplicate values using the word
        NODUPLICATES at the beginning.

        E.g.:


          sortlist='TIME desc'
          sortlist='noduplicates ANTENNA1,ANTENNA2'
          sortlist='ANTENNA1 desc, ANTENNA2 asc'
          sortlist='desc ANTENNA1, ANTENNA2, TIME'


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_query(self, *args, **kwargs)

    def calc(self, *args, **kwargs):
        """
        calc(self, expr, prefix=string("using style base0, endincl, fortranorder"), showtaql=False) -> variant *

        Summary
        	 TaQL expression with calc to calculate an expression on a table

        Description
        	


        Get the result from the calculation of an expression on a table

        The expression can be any expression that can be given in the WHERE
        clause of a SELECT expression (thus including subqueries).
        The given expression determines if the result is a scalar, a vector,
        or a record containing arrays. See the examples below.


        Input Parameters:
        	expr		 Expression string 
        	prefix		 TaQL prefix for style and ordering etc ...check TaQL note 199 for usage using style base0, endincl, fortranorder 
        	showtaql	 Show the full taql command used false 
        	
        Example:
        	


        tb.calc('[select from ngc5921.ms  giving [mean(abs(DATA))]]')

        find the mean of the abs of each row of the  DATA column of the MeasurementSet ngc5921.ms 

        returns a (potentially enormous) record where a field contains the
        value of the expression for the row with that number. Note that it
        returns a record because for each row the expression results in an array.
        It should be clear that this example is useless. However, something
        like this could be useful for a column with (very) small arrays.

        tb.calc('[select from ngc5921.ms.contsub giving  [ntrue(FLAG)]]')
         

        returns for each row the number of flags set. The result is a vector,
        because for each row the expression results in a scalar.


        tb.calc('sum([select from ngc5921.ms.contsub giving  [ntrue(FLAG)]])')

        returns the total number of flags set in the table (in a single
        scalar).

        using subrow array 
        tb.calc('median([select from ngc5921.ms where ANTENNA1==3 && ANTENNA2==5 giving [abs(DATA[0,31])]])')

        The above will find the median channel 31 and 0th pol of the requested  baseline formed with antennas 3 and 5.
        Note that the that the default casa order of arrays is fortran order ...pol axis is before channel axis

        tb.calc('median([select from ngc5921.ms where ANTENNA1==3 && ANTENNA2==5 giving [abs(DATA[31, 0])]])', prefix='using style python')

        Now the same is as the above but using the python style of axis ordering access



        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_calc(self, *args, **kwargs)

    def selectrows(self, *args, **kwargs):
        """
        selectrows(self, rownrs, name=string("")) -> table

        Summary
        	Make a table from a selection of rows

        Description
        	
        Create a (reference) table containing a given subset of rows.
        It is, for instance, useful when a selection is done
        on another table containing the row numbers in the main table.
        It can be useful to apply the casapy function unique to those
        row numbers, otherwise the same row might be included multiple
        times (see example).



        It is possible to give a name to the resulting table. If given,
        the resulting table is made persistent with that table name.
        Otherwise the table is transient and disappears when closed or when
        casapy exits.

        The rownumbers function returns a
        vector containing the row number in the main table for each row in the
        selection table.
        Thus given a row number vector 	exttt{rownrs}, the following is
        always true.
        egin{verbatim}
          rownrs == tb.selectrows(rownrs).rownumbers()
        nd{verbatim}
        However, it is not true when selectrows is used on a selection table.
        because 	exttt{rownumbers} does not return the row number in that
        selection table but in the main table.
        \It means that one has to take great care when using
        	exttt{selectrows} on a selection table.


        Input Parameters:
        	rownrs		 0-based Row Numbers 
        	name		 Name of resulting table 
        	
        Example:
        	

        # EXAMPLE NOT VERIFIED SINCE query IS BROKEN
        #   Do the query on the main table.
          tb.open('SOMENAME')
          scantable = tb.query(command)
        #   Get the column containing the 0-based row numbers in the BACKEND table.
        #   Make the row numbers unique.  NEED TO REPLACE GLISH unique FUNCTION HERE!
          backrows = unique(scantable.getcol('NS_GBT_BACKEND_ID'))
        #   Form the table subset of the BACKEND table containing those rows.
          tb.close()
          tb.open('SOMENAME/GBT_BACKEND')
          scanback = tb.selectrows(backrows);
        #   Do something with that table.
          print scanback.nrows();





        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_selectrows(self, *args, **kwargs)

    def info(self):
        """
        info(self) -> record *

        Summary
        	get the info record

        Description
        	
        The info record contains information on the table. 


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_info(self)

    def putinfo(self, *args, **kwargs):
        """
        putinfo(self, value) -> bool

        Summary
        	set the info record

        Description
        	
        The info record contains information on the table. It is
        written by applications, and used  to determine what type of
        information is stored in a table.



        Input Parameters:
        	value		 Info record 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putinfo(self, *args, **kwargs)

    def addreadmeline(self, *args, **kwargs):
        """
        addreadmeline(self, value) -> bool

        Summary
        	add a readme line to the info record

        Description
        	
        A readme line is part of the info record associated with a table.
        It is to inform the user, and is not used by any application directly.


        Input Parameters:
        	value		 readme line 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_addreadmeline(self, *args, **kwargs)

    def summary(self, recurse=False):
        """
        summary(self, recurse=False) -> bool

        Summary
        	summarize the contents of the table

        Description
        	
        A (terse) summary of the table contents is sent to the defaultlogger.


        Input Parameters:
        	recurse		 Summarize subtables recursively false 
        	
        Example:
        	

          tb.open('tcal')
          tb.summary()
        # successful nomodify open of table  tcal :  9 columns, 11 rows
        # Table summary: tcal
        # Shape: 9 columns by 11 rows
        # Info: [type=Calibration, subType=T Jones, readme=]
        # Table keywords: [Type=T Jones, Interval=30, DeltaT=1]
        # Columns: StartTime StopTime Gain SolutionOK Fit FitWeight
        # iSolutionOK iFit iFitWeight


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_summary(self, recurse)

    def colnames(self):
        """
        colnames(self) -> std::vector< std::string >

        Summary
        	return the names of the columns

        Description
        	
        The names of the columns in the table are returned as a vector
        of Strings.

        Example:
        	

          tb.open('tcal')
          tb.colnames()
        # StartTime StopTime Gain SolutionOK Fit FitWeight iSolutionOK iFit iFitWeight


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_colnames(self)

    def rownumbers(self, *args, **kwargs):
        """
        rownumbers(self, tab=initialize_record(""), nbytes=0) -> std::vector< int >

        Summary
        	!!!INPUT PARAMETERS IGNORED!!! return the row numbers in the (reference) table

        Description
        	

        !!!NOTE INPUT PARAMETERS IGNORED!!!

        This function can be useful after a selection or a sort.
        It returns the row numbers of the rows in this table with respect
        to the given table. If no table is given, the original table is used.
        \For example:
        egin {verbatim}
        !!!NOTE INPUT PARAMETERS IGNORED!!!

          tb.open('3C273XC1.MS')
          t1=tb.selectrows([1,3,5,7,9])
          t1.rownumbers()
        # [1L, 3L, 5L, 7L, 9L]
          t2=t1.selectrows([2,4])
          t2.rownumbers(t1)
        # [2L, 4L]
          t2.rownumbers(tb.name())
        # [5L, 9L]
          t2.rownumbers()
        # [5L, 9L]
        nd{verbatim}
        The last statements show that the function returns the row numbers
        referring to the given table. Table t2 contains rows 2 and 4 in table t1,
        which are rows 5 and 9 in table '3C273XC1.MS'.

        Note that when a table is opened using its name, that table can
        be a reference table. Thus in the example above
        the last 2 statements may give different results depending on the fact
        if 3C273XC1.MS is a reference table or not.
        \The function should always be called with a table argument.
        The ability of omitting the argument is only present for backward
        compatibility.

        The function can be useful to get the correct values from the result of a
        getcol or getcolslice on the original table.

        !!!NOTE INPUT PARAMETERS IGNORED!!!


        Input Parameters:
        	tab		 Table to which the row numbers refer 
        	nbytes		 Maximum cache size in bytes 0 
        	
        Example:
        	

        !!!NOTE INPUT PARAMETERS IGNORED!!!
          tb.open('3C273XC1.MS')
          tb.nrows()
        #7669L
          data=tb.getcolslice('DATA', [0,0], [0,0])
          data.shape
        #(1, 1, 7669)
          selt=tb.query('ANTENNA1==1')
          selt.nrows()
        #544L
          print len(selt.rownumbers())
        #544L


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_rownumbers(self, *args, **kwargs)

    def setmaxcachesize(self, *args, **kwargs):
        """
        setmaxcachesize(self, columnname, nbytes) -> bool

        Summary
        	set maximum cache size for column in the table

        Description
        	
        It can sometimes be useful to limit the size of the cache used by
        a column stored with the tiled storage manager.
        This function requires some more knowledge about the table system
        and is not meant for the casual user.


        Input Parameters:
        	columnname	 Name of column 
        	nbytes		 Maximum cache size in bytes 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.nrows()
        # 7669L
          tb.setmaxcachesize ('DATA', 4*1024*1024);
        # True


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_setmaxcachesize(self, *args, **kwargs)

    def isscalarcol(self, *args, **kwargs):
        """
        isscalarcol(self, columnname) -> bool

        Summary
        	is the specified column scalar?

        Description
        	
        A column may contain either scalars or arrays in each cell. 
        This tool function tests if the specified column has scalar contents.


        Input Parameters:
        	columnname	 Name of column 
        	
        Example:
        	

          tb.open('tcal')
          tb.isscalarcol('StartTime')
        # True
          tb.open('tcal')
          tb.isscalarcol('Gain')
        # False


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_isscalarcol(self, *args, **kwargs)

    def isvarcol(self, *args, **kwargs):
        """
        isvarcol(self, columnname) -> bool

        Summary
        	tell if column contains variable shaped arrays

        Description
        	
        This functions tells if the column contains variable shaped arrays.
        If so, the function 	exttt{getvarcol} should be used to get the
        entire column. Otherwise 	exttt{getcol} can be used.


        Input Parameters:
        	columnname	 Name of column 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_isvarcol(self, *args, **kwargs)

    def coldatatype(self, *args, **kwargs):
        """
        coldatatype(self, columnname) -> string

        Summary
        	return the column data type

        Description
        	
        A column may contain various data types. This tool function returns the
        type of the column as a string.


        Input Parameters:
        	columnname	 Name of column 
        	
        Example:
        	

          tb.open('tcal')
          tb.coldatatype('StartTime')
        # double
          tb.open('tcal')
          tb.coldatatype('Gain')
        # complex


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_coldatatype(self, *args, **kwargs)

    def colarraytype(self, *args, **kwargs):
        """
        colarraytype(self, columnname) -> string

        Summary
        	return the column array type

        Description
        	
        The possible column array types are defined as:
        egin{description}
        \item[FixedShape]  FixedShape means that the shape of the array must be the
        same in each cell of the column. If not given, the array
        shape may vary. Option Direct forces FixedShape. 
        \item[Direct] Direct means that the data is directly stored in the 
        table. Direct forces option FixedShape. If not given, the array is
        indirect, which implies that the data will be stored in a
        separate file.  
        nd{description}


        Input Parameters:
        	columnname	 Name of column 
        	
        Example:
        	

          tb.open('tcal')
          tb.colarraytype('Gain')
        # Direct,FixedShape


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_colarraytype(self, *args, **kwargs)

    def ncols(self):
        """
        ncols(self) -> int

        Summary
        	return number of columns
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.ncols()
        # 23L


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_ncols(self)

    def nrows(self):
        """
        nrows(self) -> int

        Summary
        	return number of rows

        Description
        	
        Note that rows are numbered starting at 0.

        Example:
        	

          tb.open('3C273XC1.MS')
          tb.nrows()
        # 7669L


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_nrows(self)

    def addrows(self, nrow=1):
        """
        addrows(self, nrow=1) -> bool

        Summary
        	add a specified number of rows

        Description
        	
        Rows can be added to the end of a table that was opened nomodify=False.
        The new rows are empty.


        Input Parameters:
        	nrow		 Number of rows to add 1 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_addrows(self, nrow)

    def removerows(self, *args, **kwargs):
        """
        removerows(self, rownrs) -> bool

        Summary
        	remove the specified rows

        Description
        	
        Remove the row numbers specified in the vector from the table.
        It fails when the table does not support row removal.


        Input Parameters:
        	rownrs		 Row numbers to remove 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_removerows(self, *args, **kwargs)

    def addcols(self, *args, **kwargs):
        """
        addcols(self, desc, dminfo=initialize_record("")) -> bool

        Summary
        	!!!REQUIRES COLUMN DESCRIPTION FUNCTIONS THAT HAVE NOT BEEN IMPLEMENTED!!!
        add one or more columns

        Description
        	
        Columns can be added to a table that was opened nomodify=False.
        The new columns will be filled with a default value (0 or blank).


        !!!THESE COLUMN DESCRIPTION FUNCTIONS HAVE NOT BEEN IMPLEMENTED!!!
        \For each column to be added a column description has to be setup
        using function
        tablecreatescalarcoldesc or
        tablecreatearraycoldesc.
        When multiple columns are used, they have to be combined in a single
        record using
        tablecreatedesc. 
        \It is possible to specify data manager info in order to define a
        data manager (storage manager or virtual column engine) for the
        columns to be added.


        Input Parameters:
        	desc		 Description of one or more columns 
        	dminfo		 Optional description data manager to use 
        	
        Example:
        	

        !!!REQUIRES COLUMN DESCRIPTION FUNCTIONS THAT HAVE NOT BEEN IMPLEMENTED!!!
          tb.open('mytable', nomodify=False)
          dc3=tablecreatescalarcoldesc('C3', 'a')   
          dc4=tablecreatescalarcoldesc('C4', as_float(0))
          dc5=tablecreatearraycoldesc('C5', as_double(0), 2, [10,20])
          tb.addcols(dc3)
        # True
          tb.addcols(tablecreatedesc(dc4, dc5))
        # True

        A single column can be added as such, but multiple columns have
        to be combined.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_addcols(self, *args, **kwargs)

    def renamecol(self, *args, **kwargs):
        """
        renamecol(self, oldname, newname) -> bool

        Summary
        	rename a column

        Description
        	
        A column can be renamed in a table that was opened nomodify=False.
        \However, renaming is not possible in a (reference) table resulting
        from a select or sort operation.


        Input Parameters:
        	oldname		 name of column to be renamed 
        	newname		 new name of column 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          tb.renamecol ('DATA', 'DATA2')
        # T
          print tb.colnames()
          tb.renamecol ('DATA2', 'DATA')
        # T
          print tb.colnames()

        Column 	exttt{DATA} is renamed to 	exttt{DATA2} and then back to
        	exttt{DATA} again..

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_renamecol(self, *args, **kwargs)

    def removecols(self, *args, **kwargs):
        """
        removecols(self, columnames) -> bool

        Summary
        	remove one or more columns

        Description
        	
        Columns can be removed from a table that was opened nomodify=False.
        \It may not always be possible to remove a column, because some data
        managers do not support column removal. However, if all columns of
        a data manager are removed, it will always succeed. It results in the
        removal of the entire data manager (and its possible files).
        \Note that function getdminfo
        can be used to find which columns are served by which data manager.


        Input Parameters:
        	columnames	 names of columns to be removed 
        	
        Example:
        	

          tb.open('mytable', nomodify=False)
          tb.removecols ('col1 col2')
        # T
          print tb.colnames()

        Two columns are removed.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_removecols(self, *args, **kwargs)

    def iscelldefined(self, *args, **kwargs):
        """
        iscelldefined(self, columnname, rownr=0) -> bool

        Summary
        	test if a specific cell contains a value

        Description
        	
        A column containing variable shaped arrays can have an empty cell
        (if no array has been put into it). This function tests if a cell
        is defined (thus is not empty).
        Note that a scalar column and a fixed shape array column cannot have
        empty cells.


        Input Parameters:
        	columnname	 Name of column 
        	rownr		 Row number, starting at 0 0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_iscelldefined(self, *args, **kwargs)

    def getcell(self, *args, **kwargs):
        """
        getcell(self, columnname, rownr=0) -> variant *

        Summary
        	get a specific cell

        Description
        	
        A cell is the value at one row in one column. It may be a scalar
        or an array.


        Input Parameters:
        	columnname	 Name of column 
        	rownr		 Row number, starting at 0 0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcell(self, *args, **kwargs)

    def getcellslice(self, *args, **kwargs):
        """
        getcellslice(self, columnname, rownr, blc, trc, incr=initialize_vector(1, (int)1)) -> variant *

        Summary
        	get a slice from a specific cell

        Description
        	
        A cell is the value at one row in one column. It must be an array.
        The slice must be specified as blc, trc with an optional stride.
        \In blc and trc -1 can be used to indicate all values for a dimension
        (-1 in blc is equivalent to 0, so -1 is especially useful for trc).


        Input Parameters:
        	columnname	 Name of column 
        	rownr		 Row number, starting at 0 
        	blc		 Bottom left corner (e.g. [0,0,0] is start of 3D array) 
        	trc		 Top right corner 
        	incr		 Stride (defaults to 1 for all axes) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          data=tb.getcellslice('DATA', 0, [0,0], [1,0])
          print data.shape
        # [2 1]


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcellslice(self, *args, **kwargs)

    def getcol(self, *args, **kwargs):
        """
        getcol(self, columnname, startrow=0, nrow=-1, rowincr=1) -> variant *

        Summary
        	get a specific column

        Description
        	
        The entire column (or part of it) is returned. Warning: it might be big!
        The functions can only be used if all arrays in the column have the
        same shape. That is guaranteed for columns containing scalars or fixed
        shaped arrays. For columns containing variable shaped arrays it only
        succeeds if all those arrays happen to have the same shape.
        \Note that function 	exttt{getvarcol} can be used to get a column of
        arbitrary shaped arrays, which also handles empty cells correctly.
        Function 	exttt{isvarcol} tells if a column contains variable shaped arrays.
        shaped 


        Input Parameters:
        	columnname	 Name of column 
        	startrow	 First row to read (default 0) 0 
        	nrow		 Number of rows to read (default -1 means till the end) -1 
        	rowincr		 Increment in rows to read (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
        # True
          gain=tb.getcol('DATA')
          print gain.shape
        # (4, 1, 7669)


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcol(self, *args, **kwargs)

    def getvarcol(self, *args, **kwargs):
        """
        getvarcol(self, columnname, startrow=0, nrow=-1, rowincr=1) -> record *

        Summary
        	get a specific column (for variable arrays)

        Description
        	
        Function 	exttt{getcol} can only used if values in the column cells to get
        have the same shape. Function 	exttt{getvarcol} addresses this limitation by
        returning the values as a record instead of an array. Each field in
        the record contains the value for a column cell. If the value is
        undefined (i.e. the cell does not contain a value), the unset value is
        put in the record. Each field name is the letter r followed by the
        row number. The length of the record is the number of rows to get.
        \Note that the function 	exttt{isvarcol} tells if a column contains
        variable shaped arrays.


        Input Parameters:
        	columnname	 Name of column 
        	startrow	 First row to read (default 0) 0 
        	nrow		 Number of rows to read (default -1 means till the end) -1 
        	rowincr		 Increment in rows to read (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          gain=tb.getvarcol('DATA')
          print len(gain)
        # 7669


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getvarcol(self, *args, **kwargs)

    def getcolslice(self, *args, **kwargs):
        """
        getcolslice(self, columnname, blc, trc, incr, startrow=0, nrow=-1, rowincr=1) -> variant *

        Summary
        	get a slice from a specific column

        Summary
        	array

        Description
        	
        A slice from the entire column (or part of it) is returned.
        Warning: it might be big!
        \In blc and trc -1 can be used to indicate all values for a dimension
        (-1 in blc is equivalent to 1, so -1 is especially useful for trc).
        Note that blc and trc should not contain the row number, only the
        blc and trc of the arrays in the column.


        Input Parameters:
        	columnname	 Name of column 
        	blc		 Bottom left corner (e.g. [0,0,0] is start of 3D array) 
        	trc		 Top right corner 
        	incr		 Stride (defaults to 1 for all axes) 
        	startrow	 First row to read (default 0) 0 
        	nrow		 Number of rows to read (default -1 means till the end) -1 
        	rowincr		 Increment in rows to read (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          data=tb.getcolslice('DATA', [0,0], [1,0])
          data.shape
        # (2 1 7669)


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcolslice(self, *args, **kwargs)

    def putcell(self, *args, **kwargs):
        """
        putcell(self, columnname, rownr, thevalue) -> bool

        Summary
        	put a specific cell

        Description
        	
        A cell is the the value at one row in one column. It
        may be a scalar or an array.


        Input Parameters:
        	columnname	 Name of column 
        	rownr		 Row number(s) (0-relative) 
        	thevalue	 Value 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putcell(self, *args, **kwargs)

    def putcellslice(self, *args, **kwargs):
        """
        putcellslice(self, columnname, rownr, value, blc, trc, incr=initialize_vector(1, (int)1)) -> bool

        Summary
        	put a slice into a specific cell

        Description
        	
        A cell is the value at one row in one column. It must be an array.
        The slice must be specified as blc, trc with an optional stride.
        \In blc and trc -1 can be used to indicate all values for a dimension
        (-1 in blc is equivalent to 0, so -1 is especially useful for trc).


        Input Parameters:
        	columnname	 Name of column 
        	rownr		 Row number, starting at 0 
        	value		 Value 
        	blc		 Bottom left corner (e.g. [0,0,0] is start of 3D array) 
        	trc		 Top right corner 
        	incr		 Stride (defaults to 1 for all axes) 1 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putcellslice(self, *args, **kwargs)

    def putcol(self, *args, **kwargs):
        """
        putcol(self, columnname, value, startrow=0, nrow=-1, rowincr=1) -> bool

        Summary
        	put a specific column

        Input Parameters:
        	columnname	 Name of column 
        	value		 Array 
        	startrow	 First row to put (default 0) 0 
        	nrow		 Number of rows to put (default -1 means till the end) -1 
        	rowincr		 Increment in rows to put (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS',nomodify=False)
          data=tb.getcol('DATA')
          # [could modify data here]
          tb.putcol('DATA', data)
          tb.flush()


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putcol(self, *args, **kwargs)

    def putvarcol(self, *args, **kwargs):
        """
        putvarcol(self, columnname, value, startrow=0, nrow=-1, rowincr=1) -> bool

        Summary
        	put a specific column (for variable arrays)

        Description
        	
        	exttt{putcol} can only used if values in the column cells to put
        have the same shape. 	exttt{putvarcol} addresses this limitation by
        passing the values as a record instead of an array. Each field in
        the record contains the value for a column cell. So the length of the
        record has to match the number of rows to put. If a value is the unset
        value, no put is done for that row.


        Input Parameters:
        	columnname	 Name of column 
        	value		 Record with values 
        	startrow	 First row to put (default 0) 0 
        	nrow		 Number of rows to put (default -1 means till the end) -1 
        	rowincr		 Increment in rows to put (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS',nomodify=False)
          gain=tb.getvarcol('DATA', 0, 10)
          tb.putvarcol('Gain', gain, 10, 10)
          tb.flush()

        This example copies the values from row 0-9 to row 10-19.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putvarcol(self, *args, **kwargs)

    def putcolslice(self, *args, **kwargs):
        """
        putcolslice(self, columnname, value, blc, trc, incr=initialize_vector(1, (int)1), startrow=0, nrow=-1, 
            rowincr=1) -> bool

        Summary
        	put a slice into a specific column

        Description
        	
        In blc and trc, -1 can be used to indicate all values for a dimension
        (-1 in blc is equivalent to 0, so -1 is especially useful for trc).
        Note that blc and trc should not contain the row number, only the
        blc and trc of the arrays in the column.


        Input Parameters:
        	columnname	 Name of column 
        	value		 Array 
        	blc		 Bottom left corner (e.g. [0,0,0] is start of 3D array) 
        	trc		 Top right corner 
        	incr		 Stride (defaults to 1 for all axes) 1 
        	startrow	 First row to put (default 0) 0 
        	nrow		 Number of rows to put (default -1 means till the end) -1 
        	rowincr		 Increment in rows to put (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS',nomodify=False)
          data_all=tb.getcolslice('DATA', [-1,-1], [-1,=1])
          print data_all.shape
          # (4, 1, 7669)
          data=tb.getcolslice('DATA', [0,0],[3,0])
          # can modify data here
          tb.putcolslice('DATA', data, [0,0],[3,0])
          tb.flush()


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putcolslice(self, *args, **kwargs)

    def getcolshapestring(self, *args, **kwargs):
        """
        getcolshapestring(self, columnname, startrow=0, nrow=-1, rowincr=1) -> std::vector< std::string >

        Summary
        	get shape of arrays in a specific column

        Description
        	
        The shapes of the arrays in the entire column (or part of it) are
        returned as strings like [20,3]. When the column contains fixed shaped
        arrays, a single string is returned. Otherwise a vector of strings is
        returned.


        Input Parameters:
        	columnname	 Name of column 
        	startrow	 First row to read (default 0) 0 
        	nrow		 Number of rows to read (default -1 means till the end) -1 
        	rowincr		 Increment in rows to read (default 1) 1 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          shapes=tb.getcolshapestring('DATA'))
          print len(shapes)


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcolshapestring(self, *args, **kwargs)

    def getkeyword(self, *args, **kwargs):
        """
        getkeyword(self, keyword) -> variant *

        Summary
        	get value of specific table keyword

        Description
        	
        The value of the given table keyword is returned. The value can be of any
        type, including a record and a table.
        \If a keyword is a table, its value is returned as a string containing
        the table name prefixed by 'Table: '. 
        \It is possible that the value of a keyword is a record itself
        (arbitrarily deeply nested). A field in such a subrecord can be
        read by separating the name with dots.


        Input Parameters:
        	keyword		 Name or seqnr of keyword: string or int 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.getkeywords()
          tb.getkeyword('MS_VERSION')
        # 2.0
          tb.close()
          tb.open('tcal')
          tb.getkeyword('rec.fld')     # get field from a record
        # 3.14


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getkeyword(self, *args, **kwargs)

    def getkeywords(self):
        """
        getkeywords(self) -> record *

        Summary
        	get values of all table keywords

        Description
        	
        The values of all table keywords are returned. The values can be of any
        type, including a record and a table.
        \If a keyword is a table, its value is returned as a string containing
        the table name prefixed by 'Table: '. 

        Example:
        	

          tb.open('3C273XC1.MS')
          tb.getkeywords()
        #{'ANTENNA': 'Table: /home/aips2mgr/testing/3C273XC1.MS/ANTENNA',
        # 'DATA_DESCRIPTION': 'Table: /home/aips2mgr/testing/3C273XC1.MS/DATA_DESCRIPTION',
        # 'FEED': 'Table: /home/aips2mgr/testing/3C273XC1.MS/FEED',
        # 'FIELD': 'Table: /home/aips2mgr/testing/3C273XC1.MS/FIELD',
        # 'FLAG_CMD': 'Table: /home/aips2mgr/testing/3C273XC1.MS/FLAG_CMD',
        # 'HISTORY': 'Table: /home/aips2mgr/testing/3C273XC1.MS/HISTORY',
        # 'MS_VERSION': 2.0,
        # 'OBSERVATION': 'Table: /home/aips2mgr/testing/3C273XC1.MS/OBSERVATION',
        # 'POINTING': 'Table: /home/aips2mgr/testing/3C273XC1.MS/POINTING',
        # 'POLARIZATION': 'Table: /home/aips2mgr/testing/3C273XC1.MS/POLARIZATION',
        # 'PROCESSOR': 'Table: /home/aips2mgr/testing/3C273XC1.MS/PROCESSOR',
        # 'SOURCE': 'Table: /home/aips2mgr/testing/3C273XC1.MS/SOURCE',
        # 'SPECTRAL_WINDOW': 'Table: /home/aips2mgr/testing/3C273XC1.MS/SPECTRAL_WINDOW',
        # 'STATE': 'Table: /home/aips2mgr/testing/3C273XC1.MS/STATE'}


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getkeywords(self)

    def getcolkeyword(self, *args, **kwargs):
        """
        getcolkeyword(self, columnname, keyword) -> variant *

        Summary
        	get value of specific column keyword

        Description
        	
        The value of the given column keyword is returned. The value can be of any
        type, including a record and a table.
        \If a keyword is a table, its value is returned as a string containing
        the table name prefixed by 'Table: '. 
        \It is possible that the value of a keyword is a record itself
        (arbitrarily deeply nested). A field in such a subrecord can be
        read by separating the name with dots.


        Input Parameters:
        	columnname	 Name of column 
        	keyword		 Name or seqnr of keyword: string or int 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.getcolkeyword('UVW', 'QuantumUnits')
        #array(['m', 'm', 'm'],
        #      dtype='|S2')


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcolkeyword(self, *args, **kwargs)

    def getcolkeywords(self, *args, **kwargs):
        """
        getcolkeywords(self, columnname) -> variant *

        Summary
        	get values of all keywords for a column

        Description
        	
        The values of all keywords for the given column are returned.
        The values can be of any type, including a record and a table.
        \If a keyword is a table, its value is returned as a string containing
        the table name prefixed by 'Table: '. 


        Input Parameters:
        	columnname	 Name of column 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.getcolkeywords('UVW')
        #{'MEASINFO': {'Ref': 'ITRF', 'type': 'uvw'},
        # 'QuantumUnits': array(['m', 'm', 'm'],
        #      dtype='|S2')}


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcolkeywords(self, *args, **kwargs)

    def putkeyword(self, *args, **kwargs):
        """
        putkeyword(self, keyword, value, makesubrecord=False) -> bool

        Summary
        	put a specific table keyword

        Description
        	
        Put a table keyword. The value of the keyword can be a scalar or
        an array of any type or it can be a record.
        \It is possible to define a keyword holding a subtable. In that
        case a special string containing the name of the subtable will be
        passed to the table client.
        \It is possible that the value of a keyword is a record itself
        (arbitrarily deeply nested). A field in such a subrecord can be
        written by separating the name with dots. If a subrecord does not
        exist, an error is returned unless 	exttt{makesubrecord=True} is given.
        In such a case intermediate records are created when needed.


        Input Parameters:
        	keyword		 Name or seqnr of keyword: string or int 
        	value		 Value of keyword 
        	makesubrecord	 Create intermediate records false 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          tb.putkeyword('VERSION', '1.66')
        # True
        #      define ANTENNA subtable
          tb.putkeyword('ANTENNA', 'Table: 3C273XC1.MS/ANTENNA')
          tb.flush()
        # True
        #      write a field in a record and create subrecords when needed
          tb.putkeyword('REC.SUB.FLD', 'val', True)
        # True
        #      write a keyword with a record value
          tb.putkeyword('REC', {'SUB': {'FLD': 'val'}})
        # True

        Note that the last example does the same as the previous one (assuming
        that 	exttt{REC} does not exist yet with other fields).

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putkeyword(self, *args, **kwargs)

    def putkeywords(self, *args, **kwargs):
        """
        putkeywords(self, value) -> bool

        Summary
        	!!!BROKEN!!! put multiple table keywords

        Description
        	
        Put multiple table keywords. All fields in the given record are put
        as table keywords. The value of each field can be a scalar or
        an array of any type or it can be a record.
        \It is also possible to define a keyword holding a subtable.
        This can be done by giving the keyword a string value consisting of
        the subtable name prefixed by 'Table: '. 


        Input Parameters:
        	value		 Record of keyword=value pairs 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          kw=tb.getkeywords()
          print kw['MS_VERSION']
        # 2.0
          kw['MS_VERSION']=2.1
          tb.putkeywords(kw)
        # !!!BROKEN. Keywords containing float are not handled properly!!!
          tb.flush()
        # True


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putkeywords(self, *args, **kwargs)

    def putcolkeyword(self, *args, **kwargs):
        """
        putcolkeyword(self, columnname, keyword, value) -> bool

        Summary
        	put a specific keyword for a column

        Description
        	
        Put a keyword in the given column.
        The value of the keyword can be a scalar or
        an array of any type or it can be a record.
        \It is possible to define a keyword holding a subtable. In that
        case a special string containing the name of the subtable will be
        passed to the table client.
        \It is possible that the value of a keyword is a record itself
        (arbitrarily deeply nested). A field in such a subrecord can be
        written by separating the name with dots. If a subrecord does not
        exist, an error is returned unless 	exttt{makesubrecord=True} is given.
        In such a case intermediate records are created when needed.


        Input Parameters:
        	columnname	 Name of column 
        	keyword		 Name or seqnr of keyword,string or int 
        	value		 Value of keyword 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          ckw=tb.getcolkeyword('UVW','QuantumUnits')
          print ckw
          # modify ckw as desired
          tb.putcolkeyword('UVW','QuantumUnits',ckw)
        # True
          tb.flush()
        # True


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putcolkeyword(self, *args, **kwargs)

    def putcolkeywords(self, *args, **kwargs):
        """
        putcolkeywords(self, columnname, value) -> bool

        Summary
        	put multiple keywords for a column

        Description
        	
        Put multiple keywords in the given column.
        All fields in the given record are put
        as column keywords. The value of each field can be a scalar or
        an array of any type or it can be a record.
        \It is also possible to define a keyword holding a subtable.
        This can be done by giving the keyword a string value consisting of
        the subtable name prefixed by 'Table: '. 


        Input Parameters:
        	columnname	 Name of column 
        	value		 Record of keyword=value pairs 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          kws = tb.getcolkeywords('UVW')
          kws
        #{'MEASINFO': {'Ref': 'ITRF', 'type': 'uvw'},
        # 'QuantumUnits': array(['m', 'm', 'm'],
        #      dtype='|S2')}
          kws['MEASINFO']['Ref']='B1950'
          tb.putcolkeywords(kws)
        # True


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_putcolkeywords(self, *args, **kwargs)

    def removekeyword(self, *args, **kwargs):
        """
        removekeyword(self, keyword) -> bool

        Summary
        	remove a specific table keyword

        Input Parameters:
        	keyword		 Name or seqnr of keyword: string or int 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          tb.removekeyword('MS_VERSION')
        # True
          tb.flush()
        # True


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_removekeyword(self, *args, **kwargs)

    def removecolkeyword(self, *args, **kwargs):
        """
        removecolkeyword(self, columnname, keyword) -> bool

        Summary
        	remove a specific keyword for a column

        Input Parameters:
        	columnname	 Name of column 
        	keyword		 Name or seqnr of keyword: string or int 
        	
        Example:
        	

          tb.open('3C273XC1.MS', nomodify=False)
          tb.removecolkeyword('UVW', 'QuantumUnits')
        # True
          tb.flush()
        # True


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_removecolkeyword(self, *args, **kwargs)

    def getdminfo(self):
        """
        getdminfo(self) -> record *

        Summary
        	get the info about data managers

        Description
        	
        This function returns the types and names of the data managers used.
        For each data manager it also returns the names of the columns served by it.
        The information is returned as a record containing a subrecord for
        each data manager. Each subrecord contains the fields TYPE, NAME and
        COLUMNS.

        Example:
        	

          tb.open('3C273XC1.MS')
          rec = tb.getdminfo()

        Print the output record shows that the table uses 9 storage managers.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getdminfo(self)

    def keywordnames(self):
        """
        keywordnames(self) -> std::vector< std::string >

        Summary
        	get the names of all table keywords

        Description
        	
        This function returns a vector of strings containing the names
        of all table keywords.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_keywordnames(self)

    def fieldnames(self, *args, **kwargs):
        """
        fieldnames(self, keyword=string("")) -> std::vector< std::string >

        Summary
        	get the names of fields in a table keyword

        Description
        	
        This function returns a vector of strings containing the names
        of all fields in the given table keyword.
        It is only valid if the keyword value is a record.
        \If no keyword name is given, the names of all table keywords are returned.


        Input Parameters:
        	keyword		 keyword name 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_fieldnames(self, *args, **kwargs)

    def colkeywordnames(self, *args, **kwargs):
        """
        colkeywordnames(self, columnname) -> std::vector< std::string >

        Summary
        	get the names of all keywords in a column

        Description
        	
        This function returns a vector of strings containing the names
        of all keywords in the column with the given name..


        Input Parameters:
        	columnname	 column name 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.colkeywordnames('UVW')


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_colkeywordnames(self, *args, **kwargs)

    def colfieldnames(self, *args, **kwargs):
        """
        colfieldnames(self, columnname, keyword=string("")) -> std::vector< std::string >

        Summary
        	get the names of fields in a keyword in a column

        Description
        	
        This function returns a vector of strings containing the names
        of all fields in the given keyword in the given column.
        It is only valid if the keyword value is a record.
        \If no keyword name is given, the names of all keywords in the column
        are returned.


        Input Parameters:
        	columnname	 column name 
        	keyword		 keyword name 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_colfieldnames(self, *args, **kwargs)

    def getdesc(self, actual=True):
        """
        getdesc(self, actual=True) -> record *

        Summary
        	get the table description

        Description
        	
        The table description is a casapy record that contains a complete 
        description of the layout
        of the table (except for the number of rows). 
        \
        By default the actual table description is returned (thus telling the
        actual shapes and data managers used). It is also possible to get
        the table description used when creating the table.


        Input Parameters:
        	actual		 actual table description? true 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.getdesc()


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getdesc(self, actual)

    def getcoldesc(self, *args, **kwargs):
        """
        getcoldesc(self, columnname) -> record *

        Summary
        	get the description of a specific
        column

        Description
        	
        The column description is a casapy record that contains a complete 
        description of the layout
        of a specified column (except for the number of rows). It can be used 
        to construct a table description.


        Input Parameters:
        	columnname	 Name of column 
        	
        Example:
        	

          tb.open('3C273XC1.MS')
          tb.getcoldesc('DATA')
        #{'comment': 'The data column',
        # 'dataManagerGroup': 'TiledData',
        # 'dataManagerType': 'TiledShapeStMan',
        # 'maxlen': 0,
        # 'ndim': 2,
        # 'option': 0,
        # 'valueType': 'complex'}


        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_getcoldesc(self, *args, **kwargs)

    def ok(self):
        """
        ok(self) -> bool

        Summary
        	Is the table tool ok?

        Description
        	
        Perform a number of sanity checks and return T if ok.
        Failure (returning F) is a sign of a bug.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_ok(self)

    def clearlocks(self):
        """
        clearlocks(self) -> bool

        Summary
        	Clears any table lock associated with the current process

        Description
        	
        	Occasionally a table will be inretrievably locked to another process no matter how much closing is done.
        	So clearLocks will unlock all the files in the table cache that use AutoLocking.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_clearlocks(self)

    def listlocks(self):
        """
        listlocks(self) -> bool

        Summary
        	Lists any table lock associated with the current process

        Description
        	
        	Occasionally a table will be inretrievably locked to another process no matter how much closing is done.
        	So listLocks will list the offending tables (and unoffending ones, too), so we can figure out where the problem might be.

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_listlocks(self)

    def statistics(self, *args, **kwargs):
        """
        statistics(self, column, complex_value=string(""), useflags=True) -> record *

        Summary
        	Get statistics on the selected table column

        Description
        	
            This function computes descriptive statistics on the table column.
            It returns the statistical values as a dictionary.  The given 
            column name must be a numerical column.
            If it is a complex valued column, the parameter complex\_value defines
            which derived real value is used for the statistics computation.
          

        Input Parameters:
        	column		 Column name 
        	complex_value	 Which derived value to use for complex columns (amp, amplitude, phase, imag, real, imaginary) 
        	useflags	 Use the data flags true 
        	
        Example:
        	
            
              
              tb.open('ggtau.1mm.amp.gcal')
              s = tb.statistics(column='GAIN', complex_value='phase')
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_statistics(self, *args, **kwargs)

    def showcache(self, verbose=True):
        """
        showcache(self, verbose=True) -> std::vector< std::string >

        Summary
        	show the contents of the table cache

        Description
        	
        Show the contents of the table cache.


        Input Parameters:
        	verbose		 true 
        	
        Example:
        	
        tb.showcache()

        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_showcache(self, verbose)

    def testincrstman(self, *args, **kwargs):
        """
        testincrstman(self, column) -> bool

        Summary
        	Checks consistency of an Incremental Store Manager bucket layout

        Description
        	
                
                Checks consistency of an Incremental Store Manager bucket layout
                
                In case of corruption it returns False and a SEVERE msg is posted containing information about the location of the corrupted bucket
                
                

        Input Parameters:
        	column		 Column name 
        	
        Example:
        	
                
                	mytb = tbtool()
                	mytb.open('uid___A002_X841035_X203.ms.split')
                	mytb.testincrstman('FLAG_ROW')        
                
                
        --------------------------------------------------------------------------------
        	      
        """
        return _table.table_testincrstman(self, *args, **kwargs)

table_swigregister = _table.table_swigregister
table_swigregister(table)

# This file is compatible with both classic and new-style classes.


