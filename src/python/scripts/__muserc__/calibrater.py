# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_calibrater', [dirname(__file__)])
        except ImportError:
            import _calibrater
            return _calibrater
        if fp is not None:
            try:
                _mod = imp.load_module('_calibrater', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _calibrater = swig_import_helper()
    del swig_import_helper
else:
    import _calibrater
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class calibrater(_object):
    """Proxy of C++ casac::calibrater class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, calibrater, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, calibrater, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> calibrater"""
        this = _calibrater.new_calibrater()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _calibrater.delete_calibrater
    __del__ = lambda self : None;
    def open(self, *args, **kwargs):
        """
        open(self, filename, compress=False, addcorr=True, addmodel=True) -> bool

        Summary
        	Attach MeasurementSet to the calibrater tool

        Description
        	
        Attaches a MeasurementSet to the {	t calibrater} tool for further processing with
        other methods.



        Input Parameters:
        	filename	 MeasurementSet file name. No default 
        	compress	 Compress calibration columns? false 
        	addcorr		 Add scratch columns? true 
        	addmodel	 Add MODEL\_DATA column along with CORRECTED\_DATA ? true 
        	
        Example:
        	

        cb.open('ngc5921.ms');


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_open(self, *args, **kwargs)

    def selectvis(self, *args, **kwargs):
        """
        selectvis(self, time=initialize_variant(""), spw=initialize_variant(""), scan=initialize_variant(""), 
            field=initialize_variant(""), intent=initialize_variant(""), observation=initialize_variant(""), 
            baseline=initialize_variant(""), uvrange=initialize_variant(""), 
            chanmode=string("none"), nchan=1, start=0, step=1, mstart=Quantity(std::vector<double>(1, 0.0),"km/s"), 
            mstep=Quantity(std::vector<double>(1, 0.0),"km/s"), 
            msselect=string("")) -> bool

        Summary
        	Set the data selection for subsequent processing

        Description
        	

        This function provids for selection of the visibility data from the MS 
        which will be treated by subsequent execution of the {\stfaf solve} and 
        {\stfaf correct} functions.  Note that data selection is not cumulative, i.e., 
        any selection made in a previous call to {\stfaf selectvis} will be overridden
        by the the current call.

        Most of the {\stfaf selectvis} parameters use the standardized MS Selection
        syntax.

        The parameters are described below.  The selected data will satisfy the
        logical AND of all non-trivially specified parameters.  Note that the
        old-fashioned strided channel selection parameters are deprecated (and
        will soon be removed); use spw instead.  Running {\stfaf selectvis} with
        no specified parameters restores selection of the entire MS.


        egin{description}
        \item[time] is used to specify time ranges in a stardard format

        \item[spw] is used to specify spectral window and channel selection.  Currently,
        only a single channel range can be specified per spw.

        \item[scan] is used to specify scan numbers and ranges

        \item[observation] is used to specify observation ID(s).

        \item[field] is used to specify field names or indices

        \item[baseline] is used to specify antenna and baseline combinations

        \item[uvrange] is used to specify baseline length ranges

        \item[chanmode] is deprecated (use spw)
        \item[nchan] is deprecated (use spw)
        \item[start] is deprecated (use spw)
        \item[step] is deprecated (use spw)
        \item[mstart] is deprecated (use spw)
        \item[mstep] is deprecated (use spw)

        \item[msselect] is used to specify a subselection of data according to
        Measurement Set columns in conditional combinations not possible
        with the standard parameters above.  This parameter should be specified
        as a valid \htmladdnormallink{TaQL}{../../notes/199/199.html} expression.
        If both msselect and the standard selection parameter are used together,
        they are combined with a logical AND, i.e., the data must jointly satisfy
        all {\stfaf selectvis} parameters.

        nd{description}



        Input Parameters:
        	time		 Select on time 
        	spw		 Select on spectral window 
        	scan		 Select on scan 
        	field		 Select on field 
        	intent		 Select on intent or state 
        	observation	 Select by observation ID(s) 
        	baseline	 Select on antennas/baselines 
        	uvrange		 Select by uvrange 
        	chanmode	 Type of data selection: channel or velocity channel velocity none 
        	nchan		 Number of channels to select (mode='channel') 1 
        	start		 Start channel (0-relative) (mode='channel') 0 
        	step		 Step in channel number (mode='channel') 1 
        	mstart		 Start velocity (e.g. '20Km/s') 0.0 
        	mstep		 Step in velocity (e.g. '100m/s') 0.0 
        	msselect	 TAQL selection string. Default (empty) is no specific selection. 
        	
        Example:
        	

        Open and select a field:


        cb.open('ngc5921.ms');
        cb.selectvis(field='N5921_2');  # by complete name
        cb.selectvis(field='N5921*');   # with wildcard
        cb.selectvis(field='2');        # by index


        Select a field and a channel range:


        cb.selectvis(spw='0:10~40',field='N5921*');


        Select using all MS Selection parameters (these parameters are
        over-specified somewhat, i.e., scan 6 contains only field N5921_2,
        etc.):


        cb.selectvis(time='>1995/04/13/10:40:00',   # times greater than this
                     spw='0:20~40',                 # channels 20-40 in spw 0
                     scan='6',                      # scan 6 only
                     field='N59*',                  # fields matching N59*
                     baseline='1 \& *',              # baselines to antenna 1
                     uvrange='>0.0klambda')         # baselines greater than zero length



        Reset selection to the entire dataset


        cb.selectvis()



        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_selectvis(self, *args, **kwargs)

    def setmodel(self, *args, **kwargs):
        """
        setmodel(self, modelimage) -> bool

        Summary
        	Set the sky model used to compute the model visibilities

        Description
        	
        Name of the model image to be used as a sky model for model visibility
        computations.  For now, this is used only by EP-Jones solver.


        Input Parameters:
        	modelimage	 Name of the model image. 
        	
        Example:
        	
        cb.setmodel('mymodel');

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setmodel(self, *args, **kwargs)

    def setptmodel(self, *args, **kwargs):
        """
        setptmodel(self, stokes=initialize_vector(4,(double)0.0, (double)0.0, (double)0.0, (double)0.0)) -> bool

        Summary
        	Set the point source model Stokes parameters to be used to compute the model visibilities

        Description
        	
        Set a global point source model Stokes parameters to use in solving operations.


        Input Parameters:
        	stokes		 Vector of Stokes parameters. 0.0 0.0 0.0 0.0 
        	
        Example:
        	
        cb.setmodel([1,1,0,0]);

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setptmodel(self, *args, **kwargs)

    def setapply(self, *args, **kwargs):
        """
        setapply(self, type=string(""), t=0.0, table=string(""), field=initialize_variant(""), interp=string("linear"), 
            select=string(""), calwt=False, spwmap=initialize_vector(1, (int)-1), 
            opacity=initialize_vector(1, (double)0.0)) -> bool

        Summary
        	Arrange to apply calibration

        Description
        	

        This function is used to specify the calibration components which should be
        applied during subsequent execution of the {\stfaf solve} and 
        {\stfaf correct} functions.  This function should be executed as many
        times as necessary to specify all desired calibration components.

        Each calibration component represents a separate calibration matrix
        correction included in the measurement equation. The different types
        correspond to different instrumental and atmospheric effects.
        Calibration components are available as calibration tables generated
        by previous {\stfaf solve} executions (types 'B','BPOLY','G','GSPLINE',
        'D','DF','T','M','MF','X'), or are calculated analytically on
        the fly (types 'P', 'TOPAC', 'GAINCURVE').  Upon execution
        of {\stfaf solve} or {\stfaf correct}, the group of specified 
        calibration components will be applied in the order prescribed
        by the Measurement Equation formalism.  

        The parameters are as follows:

        egin{description}

        \item[type] The calibration type being specified.  This is only required
        for analytic types ('P','TOPAC','GAINCURVE').  When specifying an existing 
        pre-solved calibration table, it is not necessary to explicitly specify the 
        {\stfaf type}; this will be discerned from the table.  (Specifying the 
        {\stfaf type} as well as the {\stfaf table} will force a check that the 
        table contains solutions of the specified type.

        For {\stfaf type='GAINCURVE'}, an elevation-dependent correction
        will be applied using parameters read from the data repository.
        Currently, this is only supported for the VLA.

        \item[t] This parameter will be used in a future release to control
        the range of applicability of the specified calibration.  Currently,
        it is ignored.

        \item[table] For pre-solved calibration, the file name of the table
        to apply.

        \item[field] The fields to select from the specified table, using
        MS Selection syntax (as in selectvis).

        \item[interp] The desired type of time-dependent interpolation.  Use 
        {\stfaf interp='nearest'} to calibrate each datum with the calibration 
        value nearest in time.  Use {\stfaf interp='linear'} to calibrate each 
        datum with calibration phases and amplitudes linearly interpolated 
        from neighboring (in time) values.  In the case of phase, this mode 
        will assume that phase jumps greater than 180 degrees between neighboring 
        points indicate a cycle slip, and the interpolated value will follow 
        this change in cycle accordingly (i.e., the implied rate will always
        be less than 180 degrees per sample).  Use {\stfaf interp='aipslin'} 
        to emulate the basic interpolation mode used in classic AIPS, i.e., 
        linearly interpolated amplitudes, with phases derived from linear 
        interpolation of the complex calibration values.  While this method 
        avoids having to track cycle slips (which is unstable for solutions 
        with very low SNR), it will yield a phase interpolation which becomes 
        increasingly non-linear as the spanned phase difference increases.  The 
        non-linearity mimics the behavior of {\stfaf interp='nearest'} as 
        the spanned phase difference approaches 180 degrees (the phase of the 
        interpolated complex calibration value initially changes very slowly, 
        then rapidly jumps to the second value at the midpoint of the interval). 
        If the uncalibrated phase is changing this rapidly, a 'nearest' interpolation 
        is not desirable.  Usually, {\stfaf interp='linear'} is the best choice.
        The {\stfaf interp} parameter is applicable to any calibration type,
        as long as there are sufficient solutions available to perform the
        interpolation.  Note that calibration solutions which have been
        determined for only one timestamp will default to 'nearest'.  More
        interpolation options (e.g., 'cubic') will be added in the future.

        \item[select] Used to specify general selection of a subset of 
        calibration measurements from the table to be applied to the
        visibility data.  Arbitrary cross-calibration is possible by combining
        this function with the {\stfaf setdata} function.  The string
        specified must be a valid \htmladdnormallink{TaQL}{../../notes/199/199.html} 
        expression.

        \item[spwmap] This parameter is used to indicate how solutions
        derived from different spectral windows should be applied to other
        spectral windows.  Nominally, data in each spectral window will be
        corrected by solutions derived from the same spectral window.  This is
        the default behavior of {\stfaf spwmap}, i.e., if {\stfaf spwmap} is
        not specified, calibrater will insist that data be corrected by
        solutions from the same spw.  Otherwise, {\stfaf spwmap} takes a
        vector of integers indicating which spectral window {m solutions} to
        apply to which spectral window {m data}, such that {	t spwmap[j]=i}
        causes solutions derived from the i-th spectral window to be used to
        correct the j-th spectral window.  For example, if (say) bandpass
        solutions are available for spws 0 \& 2, and it is desired that these
        be applied to spws 1 \& 3 (as well as 0 \& 2), respectively, use
        {\stfaf spwmap=[0,0,2,2]}.  Even if some spws do not require an
        explicit {\stfaf spwmap} setting, yet one or more does, it is safest
        to specify it explicitly for all, e.g., {\stfaf spwmap=[0,1,3,3]}
        indicates that spw 2 will be corrected with solutions from spw 3, and
        the others will behave nominally.  Note that if no solutions exist 
        for any of the spws specified in {\stfaf spwmap}, an error message
        will result.

        \item[calwt] If set True, the data weights will be calibrated
        along with the data.  This is usually desirable.

        \item[opacity] For {\stfaf type='TOPAC'}, an elevation-dependent 
        opacity correction will be applied according to the zenith opacity value 
        supplied in the {\stfaf opacity} parameter.  Currently, only one zenith 
        opacity value can be supplied, and it is used for all antennas.

        nd{description}

        Use the {\stfaf state} function to review the list of calibration
        components that have been set for application.  

        Pending improvements:

        egin{itemize}
        \item Enable variety of interpolation modes and timescales
        \item Allow for antenna- and time-dependent opacities
        nd{itemize}



        Input Parameters:
        	type		 Component type B BPOLY G GSPLINE D P T TOPAC GAINCURVE 
        	t		 Interpolation interval (seconds) 0.0 
        	table		 Calibration table name 
        	field		 Select on field 
        	interp		 Interpolation type (in time) aipslin nearest linear 
        	select		 TAQL selection string. Default is no selection. 
        	calwt		 Calibrate weights? false 
        	spwmap		 Spectral windows to apply -1 
        	opacity		 Array-wide zenith opacity per antenna (for type='TOPAC') 0.0 
        	
        Example:
        	

        cb.open('ngc5921.ms')
        cb.selectvis(field='N5921*')            
        cb.setapply (type='G', table='gcal', field='1445*') 
        cb.setapply (type='P')     
        cb.correct();
        cb.close();


        In this example, we apply parallactic angle corrections and a gain
        calibration derived from a field whose name matches '1445*' in a caltable
        called 'gcal' to data for a field matching 'N5921*'

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setapply(self, *args, **kwargs)

    def setcallib(self, *args, **kwargs):
        """
        setcallib(self, callib=initialize_record("")) -> bool

        Summary
        	Arrange to apply calibration via a Cal Library

        Description
        	

        TBD



        Input Parameters:
        	callib		 A calibration library record 
        	
        Example:
        	

        TBD


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setcallib(self, *args, **kwargs)

    def validatecallib(self, *args, **kwargs):
        """
        validatecallib(self, callib=initialize_record("")) -> bool

        Summary
        	Validate a Cal Library record

        Description
        	

        TBD



        Input Parameters:
        	callib		 A calibration library record 
        	
        Example:
        	

        TBD


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_validatecallib(self, *args, **kwargs)

    def setsolve(self, *args, **kwargs):
        """
        setsolve(self, type=string("MF"), t=initialize_variant(""), table=string(""), append=False, preavg=-1.0, 
            phaseonly=False, apmode=string("AP"), refant=initialize_variant(""), 
            minblperant=4, solnorm=False, minsnr=0.0, combine=string(""), fillgaps=0, 
            cfcache=string(""), painc=360.0, fitorder=0, fraction=0.1, numedge=-1) -> bool

        Summary
        	Arrange to solve for calibration

        Description
        	
        This function specifies the calibration component that will be solved for
        by the {\stff solve} function.  Currently, only one type can 
        be solved for at one time.

        Each calibration component represents a separate calibration matrix
        correction included in the measurement equation. The different types
        correspond to different instrumental and atmospheric effects.
        Currently, the solvable calibration components are types 'G','T','B', 'D'
        and 'DF', which are antenna-based, and, 'M' and 'MF', which are
        baseline-based.  Arrange to pre-apply any existing calibration components (of
        types other than the solved-for one) using the {\stfaf setapply}
        function.

        The parameters are:

        egin{description}
        \item[type] Specify the calibration type you want to solve for, from
        'G','T','B','D','DF','M','MF'.

        \item[t] Specify the solution interval.  This can be specified as an
        integer (units of seconds assumed) or as a string containing a value
        and units (e.g., '30s', '45min', '2h') or 'inf' (infinite) or 'int'
        (per data integration).  A solution interval of 0 (with or without
        units) is the same as 'int' (per integration), and negative solution
        intervals are treated as 'inf' (infinite).

        \item[table] Specify the output calibration table name in which to
        store the calibration solve result.  Existing tables will be
        deleted and replaced.

        \item[append] Append the solutions to an existing table.  

        \item[preavg] Specify the amount of pre-average (in time) within
        the solution interval.  By default, data are averaged up to
        the solution interval (or up to 5 minutes for 'D' solving).  

        \item[phaseonly] This parameter is deprecated, use apmode.

        \item[apmode] Control generation of amplitude-only ('a'), 
        phase-only ('p'), or amplitude-and-phase ('ap', the default) solutions.

        \item[refant] Specify an antenna (using data selection syntax)
        for referencing the solutions. 

        \item[solnorm] Normalize the solutions by their mean post-solve. For
        'B', and 'MF', this is a complex normalization per solution spectrum.
        For other types, this is a global (per-spw) normalization of the 
        amplitudes only.

        \item[minsnr] Specify the SNR below which solution are rejected.

        \item[combine] Specify which data axes (spw, field, scan, or some
        combination) on which the data should be combined to generate
        a single solution.  E.g., combine='spw' will force combination
        of many spws to form a single solution (per solution interval). 
        Similarly, combine='scan' with a long solution interval 
        will force the combination of scans to yield individual solutions
        (per field and spw).  Ordinarily, solutions are always broken
        at scans boundaries.  Separate multiple combine options with 
        commas.

        \item[fillgaps] For 'B' solutions, specify the largest solution
        channel gap (which arise due to flagged data) that will be filled 
        post-solve via interpolation.  Such solution gaps remain flagged
        by default.

        nd{description}

        Pending improvements:

        egin{itemize}
        \item{Change t to solint?}
        \item{Permit flexible specification of preavg (as for t)}
        nd{itemize}



        Input Parameters:
        	type		 Component type G T B D M MF 
        	t		 Solution interval (units optional) 
        	table		 Output calibration table name 
        	append		 Append to existing table? false 
        	preavg		 Pre-averaging interval (in sec) -1.0 
        	phaseonly	 Solve only for phase? false 
        	apmode		 Solve for 'AP', 'A' (amp-only) or 'P' (phase-only) AP 
        	refant		 Reference antenna. Default is none. 
        	minblperant	 Minimum number of baselines per ant for solving 4 
        	solnorm		 Normalize solution after solve false 
        	minsnr		 SNR threshold for accepting solutions 0.0 
        	combine		 Data axes on which to combine solving (scan, spw, and/or field) 
        	fillgaps	 0 
        	cfcache		 Name of the directory to be used for convolution function disk cache. This is used when type=EP. 
        	painc		 Parallactic Angle increment used to trigger computation of a new convolution function. This is used when type=EP. Default value implies that only one convolution function will be computed for the entire range of observation. 360.0 
        	fitorder	 Order of the polynomial fit, used when type='A'. 0 
        	fraction	 [SINGLE-DISH SPECIFIC] Edge detection parameter for otfraster/otf calibration. This is a number of edge points as a fraction of total number of points. 0.1 
        	numedge		 [SINGLE-DISH SPECIFIC] Edge detection parameter for otfraster calibration. This is a number of edge points. The value specified here comes before fraction. Note that edge points will be detected from both side of each raster row so that number of edge points is effectively twice of the specified value in each raster row. Default (-1) is to use fraction. -1 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.setapply (type='P');
        cb.setsolve (type='G',t='300s', refant=3, table='gcal');
        cb.solve();
        cb.close();


        In this example, analytic (non-solvable) parallactic angle corrections
        are pre-applied before G solutions are obtained on a timescale of 300 
        seconds.  The resulting solutions are phase-referenced to antenna 3, 
        and stored in a calibration table called 'gcal'.


        cb.reset();
        cb.setapply (type='P',t=5.0);
        cb.setapply (type='G',table='gcal');
        cb.setsolve (type='D',t=86400.0, preavg=60.0, refant=3, table='dcal');
        cb.solve();
        cb.close();


        In this example, the solve/apply state of the calibrater tool is reset
        and then the P and G corrections (from above) are applied before
        solving for D solutions on a diurnal timescale.  Note that the data
        will be averaged only to 60 seconds before the solution.  The resulting
        D solutions are stored in a table called 'dcal'.


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setsolve(self, *args, **kwargs)

    def setsolvegainspline(self, *args, **kwargs):
        """
        setsolvegainspline(self, table=string(""), append=False, mode=string("PHAS"), splinetime=10800, preavg=0.0, 
            npointaver=10, phasewrap=250, refant=initialize_variant("")) -> bool

        Summary
        	Specialization of setsolve for
        cubic spline G (time-dependent gain) solving

        Description
        	

        This function is a specialization of the {\stfaf setsolve} method which
        should be used when cubic spline G solutions are desired, e.g., when
        SNR on calibrators is very low.  Currently, this solving mode treats
        dual polarization data on a per-polarization basis.  The option to 
        obtain a joint solution (a la 'T') will be provided in the future.

        The visibility data are averaged in frequency (for multi-channel data)
        prior to the solution.  

        This method uses many of the basic parameters as the generic
        {\stfaf setsolve}.  Parameters unique to the spline solver are:

        egin{description}

        \item[mode] For phase solutions only, use {\stfaf mode='PHAS'}.  For
        amplitude solutions only, use {\stfaf mode='AMP'}.  If both are
        desired, use {\stfaf mode='PHASAMP'}, and both will be solved for
        using the same spline timescale (this mode also assumes that all
        calibrators have the correct relative flux densities).  If solving for
        phase and amplitude separately (usually in this order), it is usually
        desirable to apply the first one when solving for the second
        one. Spline solution so obtained will be stored in separate
        calibration tables.  In the near future, the {\stfaf mode} parameter
        will be consolidated with the generic {\stfaf apmode} parameter.

        \item[splinetime] The spline timescale (time between knots) is
        specified here. The default is 10800 seconds (3 hours).  In future
        this parameter will be consolidated with the generic {\stfaf t}
        parameter.  The {\stfaf preavg} parameter should be set to a value at
        least 4X shorter than the spline time (an error will occur if there is
        insufficient sampling within the {\stfaf splinetime} timescale), and
        consistent with the expected coherence.  Consistent with these constraints,
        use the largest possible value for {\stfaf preavg} to optimize the SNR of 
        the pre-solve phase-tracking algorithm.

        \item[npointaver and phasewrap] These parameters tune the
        phase-unwrapping algorithm when {\stfaf mode $=$ 'PHAS'}.  Cycle slips
        are detected (and removed before the spline solve) when the median
        phase a sequence of length {\stfaf npointaver} (in integrations)
        differs by more than {\stfaf phasewrap} degrees from the previous
        sequence.

        nd{description}

        Pending improvements:

        egin{itemize}
        \item Consolidate more parameters with the generic {\stfaf setsolve}
        \item Introduce the generic combine options
        \item Improve phase-tracking algorithm
        nd{itemize}



        Input Parameters:
        	table		 Output calibration table name 
        	append		 Append to existing table? false 
        	mode		 Phase or Amplitude mode? AMP PHASAMP PHAS 
        	splinetime	 Spline timescale (sec) 10800 
        	preavg		 Pre-averaging interval (in sec) 0.0 
        	npointaver	 10 
        	phasewrap	 250 
        	refant		 Reference antenna. Default is none. 
        	
        Example:
        	

        cb.open('ngc5921.ms')
        cb.selectvis(field='1445*')
        cb.setsolvegainspline (table='gcalph',mode='PHAS',splinetime=3600.0,preavg=60.0)cb.solve()

        cb.setsolvegainspline (table='gcalamp',mode='AMP',splinetime=10800.0);
        cb.solve();
        cb.close();


        In this example, a spline solution is first found for phase on a hourly timescale, then for amplitude on a three-hour timescale.

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setsolvegainspline(self, *args, **kwargs)

    def setsolvebandpoly(self, *args, **kwargs):
        """
        setsolvebandpoly(self, table=string(""), append=False, t=initialize_variant(""), combine=string(""), degamp=3, 
            degphase=3, visnorm=False, solnorm=True, maskcenter=0, maskedge=5.0, 
            refant=initialize_variant("")) -> bool

        Summary
        	Specialization of setsolve for
        polynomial B (bandpass) solving

        Description
        	

        This function is a specialization of the {\stfaf setsolve} method
        which should be used to arrange for bandpass solving when polynomial
        solutions for B are desired, e.g., when per-channel SNR on calibrators
        is too low to obtain a useful sampled bandpass. 

        Prior to the solution, the visibility data are averaged in time, 
        and the solution is performed for both phase and amplitude.

        This method uses most of the same parameters as the generic 
        {\stfaf setsolve}, with a few unique additions:

        egin{description}

        \item[degamp and degphase] The parameters permit specification
        of the polynomial order to use in amp and phase.  Specifying
        0 (zero) yields constant solutions.

        \item[visnorm] This parameter is used to normalize the assembled
        spectral data, in a per baseline manner.  If set True, this will have
        the effect of removing any non-frequency-dependent closure errors
        (e.g., as caused by source structure, or introduced by the instrument)
        from the data, and should be used with caution.  The resulting
        solutions will be effectively normalized as well.  When {\stfaf
        visnorm=F} is used, closure errors in the data (as supplied to the
        solver) may be visible in the form of offsets between the data and
        solutions.  For bandpass calibration, this is usually ok, as the {m
        shape} of the bandpass is the most important aspect of the solution.
        In future this parameter will be generalized and made available
        for other solve types. (NB: Use of {\stfaf solnorm=True} still
        provides for post-solve normalization of the solutions.)

        \item[maskcenter and maskedge] These parameters control how many
        channels are ignored on-the-fly, at the center and edges of each input
        spectral window, respectively.  To avoid edge channels, it is almost
        always better to flag these channels directly, or select against them
        in {\stfaf setdata}.  Aggressive use of maskedge (large values), will
        yield polynomial solutions which will tend to diverge at the edges
        (especially when the polynomial degree is also high), because maskedge
        does not change the frequency domain of the solutions.  Such solutions
        should be used with caution in subsequent operations.  (It is best to
        avoid use of maskedge.)
        nd{description}

        The BPOLY solution is performed for both phase and amplitude, and the
        result will be stored in the same table.  The frequency domain of the
        solutions is limited to only the range of frequencies selected in
        {\stfaf selectvis}.  When correcting data with these solutions (for
        other solves or with {\stfaf correct}), only data within this domain
        will be corrected.  Data outside (e.g., edge channels avoided in
        {\stfaf setdata} for the solve), will not be corrected.  Therefore,
        the same (or narrower) channel selection is recommended for all
        operations using solutions produced by this function and {\stfaf
        solve()}.

        Note that the {\stfaf combine} parmaeter can be used meaningfully with
        the BPOLY solver.  When combine='spw', the data from multiple spws
        will be combined on a common frequency axis, and a single polynomial
        will be determined spanning them all.  This is different than for
        ordinary sampled 'B' solutions, for which combine='spw' causes the
        bandpass to be combined on a common channel axis, effectively yielding
        a mean bandpass for the set of spws.



        Input Parameters:
        	table		 Output calibration table name 
        	append		 Append to existing table? false 
        	t		 Solution interval (units optional) 
        	combine		 Data axes on which to combine solving (scan, spw, and/or field) 
        	degamp		 Polynomial degree for amplitude solution 3 
        	degphase	 Polynomial degree for phase solution 3 
        	visnorm		 Normalize data prior to solution false 
        	solnorm		 Normalize result? true 
        	maskcenter	 Number of channels to avoid in center of each band 0 
        	maskedge	 Fraction of channels to avoid at each band edge (in \%) 5.0 
        	refant		 Reference antenna 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.selectvis(field='1331*')
        cb.setsolvebandpoly(table='bpoly',degamp=5,degphase=7);
        cb.solve();
        cb.close();


        In this example, amplitude (degree 5) and phase (degree 7) Chebychev
        polynomial bandpasses are determined using the default parameters.

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_setsolvebandpoly(self, *args, **kwargs)

    def state(self):
        """
        state(self) -> bool

        Summary
        	Request the apply/solve state of the calibrater tool

        Description
        	

        Request the apply/solve state of the calibrater tool.  A listing of
        all calibration components that have been set for application or
        solving is written to the logger.


        Example:
        	

        cb.open('ngc5921.ms');
        cb.setapply ('P', 5.0);
        cb.setsolve ('G', 300.0, F, 3, 'gcal_1', T);
        cb.state();


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_state(self)

    def reset(self, apply=True, solve=True):
        """
        reset(self, apply=True, solve=True) -> bool

        Summary
        	Reset the selected apply and/or solve components

        Description
        	

        Resets the apply and/or solve components previously set by setapply and
        setsolve.



        Input Parameters:
        	apply		 If true, unset all apply settings true 
        	solve		 If true, unset all solve settings true 
        	
        Example:
        	

        cb.open('ngc5921.ms')
        cb.setapply ('P', 5.0)
        cb.setsolve ('G', 300.0, F, 3, 'gcal_1', T)
        cb.state()
        cb.reset(apply=T,solve=F);
        cb.state()
        cb.reset()



        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_reset(self, apply, solve)

    def initcalset(self, calset=0):
        """
        initcalset(self, calset=0) -> bool

        Summary
        	Re-initialize the calibration scratch columns.

        Description
        	

        This function re-initializes the calibration scratch columns:
        MODEL\_DATA to unity (in total intensity, and unpolarized), and
        CORRECTED\_DATA to (observed) DATA.  
        Optionally if calset is set to 1 any model saved in the MS header to for calibration
        purposes is deleted



        Input Parameters:
        	calset		 if it set to 1 the model saved in the header is removed 0 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.initcalset();
        cb.solve();




        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_initcalset(self, calset)

    def delmod(self, *args, **kwargs):
        """
        delmod(self, otf=False, field=initialize_variant(""), spw=initialize_variant(""), scr=False) -> bool

        Summary
        	Delete model data representations in the MS.

        Description
        	

        This method can be used to delete the model visibility
        data representations in the MS.  The 'otf' representation is
        the new (as of v3.4) 'scratch-less' model data, stored as
        keywords in the MS header containing model data formation
        instructions.  It is generated by the im tool (setjy, ft, and clean
        methods; usescratch=F in im.open), and if present, overrides the
        old-fashioned MODEL\_DATA column (if present).  If a user
        wishes to use the MODEL\_DATA column \_after\_ having operated
        with the 'otf' representation, this method can be used
        to delete the 'otf' represenatation to make the MODEL\_DATA
        column visible.  (Create the MODEL\_DATA column by using
        usescratch=T in the im tool, or by running the cb.open
        with addmodel=T.)

        If otf=T, the user may selectively remove only a selection of fields model from the MS by specifying the field parameter. Similarly if the field parameter is specified, selected spws model for those fields may be deleted by specifying the spw. 


        For convenience, this method also provides a means for
        deleting the MODEL\_DATA column by setting scr=T.



        Input Parameters:
        	otf		 If T, delete the otf model data keywords false 
        	field		 Select on field 
        	spw		 Select on spw only if field is defined 
        	scr		 If T, delete the MODEL\_DATA column false 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.delmod(otf=T,scr=F);   # delete only the otf model for all fields
        cb.solve();

        cb.open('n4826.ms')
        cb.delmod(otf=T, field='1') 
        #delete otf model of field 1 only, all other fields model are untouched
        #if present
        cb.open('n4826.ms')
        cb.delmod(otf=T, field='1', spw='2') 
        #delete otf model of field 1 and spectralwindow 2  only.

        ####NOTE doing:
        cb.delmod(otf=T, field='', spw='2')

        #will delete all otf models and spw will be ignored 


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_delmod(self, *args, **kwargs)

    def solve(self):
        """
        solve(self) -> bool

        Summary
        	Solve for the selected calibration components

        Description
        	
        Execution of this function initiates a solve for the calibration component
        specified in a previous {\stfaf setsolve} execution.  Existing calibration
        components (as specified in one or more {\stfaf setapply} executions) will
        be appropriately applied to the observed and model data according to their
        position in the Measurement Equation, and their commutation properties.  


        Example:
        	

        cb.open('ngc5921.ms');
        cb.setapply ('P', t=10)
        cb.setsolve ('G', 300.0, F, 3, 'gcal_1', T);
        cb.solve();
        cb.close();


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_solve(self)

    def correct(self, *args, **kwargs):
        """
        correct(self, applymode=string("")) -> bool

        Summary
        	Apply calibration information

        Description
        	 

        This function applies the calibration components specified via one or
        more invocations of the {\stff setapply} function to the observed 
        visibility data and writes the result to the CORRECTED\_DATA column 
        of the Measurement Set.



        Input Parameters:
        	applymode	 Correction cal/flag mode: ''='calflag','cal','flag','trial' 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.selectvis(field='1445*')
        cb.setapply ('G', 10.0, 'gcal_1')
        cb.correct();
        cb.close();


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_correct(self, *args, **kwargs)

    def corrupt(self):
        """
        corrupt(self) -> bool

        Summary
        	Corrupt model with calibration tables

        Description
        	 

        This function applies the calibration components specified via one or
        more invocations of the {\stff setapply} function to the model
        visibility data and (over-)writes the result to the MODEL\_DATA column of the
        Measurement Set.


        Example:
        	

        cb.open('ngc5921.ms')
        cb.selectvis(field='1445*')
        cb.setapply ('G', 10.0, 'gcal_1')
        cb.corrupt()
        cb.close()


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_corrupt(self)

    def initweights(self, *args, **kwargs):
        """
        initweights(self, wtmode=string("nyq"), dowtsp=False) -> bool

        Summary
        	Initialize MS weight info in various ways.

        Description
        	

        This function initializes the MS weight info in various ways.  

        If wtmode='ones', SIGMA and WEIGHT will be initialized with 1.0,
        globally.

        If wtmode='nyq' (the default), SIGMA and WEIGHT will be initialized
        according to bandwidth and integration time.  This is the
        theoretically correct mode for raw normalized visibilities.

        If wtmode='sigma', WEIGHT will be initialized according to the
        existing SIGMA column.  

        If mode='weight', WEIGHT_SPECTRUM will be initialized according to the
        existing WEIGHT column; dowtspec=T must be specified in this case. 

        For the above wtmodes, if dowtspec=T (or if the WEIGHT_SPECTRUM column
        already exists), the WEIGHT_SPECTRUM column will be initialized
        (uniformly in channel), in a manner consistent with the WEIGHT column.
        If the WEIGHT_SPECTRUM column does not exist, dowtsp=T will force its
        creation.

        The follow modes should be used with extreme care: If
        wtmode='delwtsp', the WEIGHT_SPECTRUM column will be deleted (if it
        exists).  If wtmode='delsigsp', the SIGMA_SPECTRUM column will be
        deleted (if it exists).  Note that creation of SIGMA_SPECTRUM is not 
        supported via this method.

        Note that this method does not support any prior selection.
        Intialization of the weight information must currently be done
        globally or not at all.  This is to maintain consistency.



        Input Parameters:
        	wtmode		 Initialization mode nyq nyq sigma weight ones delwtsp delsigsp 
        	dowtsp		 Initialize WEIGHT_SPECTRUM column false 
        	
        Example:
        	

        cb.open('ngc5921.ms')
        cb.initweights()
        cb.close()


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_initweights(self, *args, **kwargs)

    def fluxscale(self, *args, **kwargs):
        """
        fluxscale(self, tablein, reference=initialize_variant(""), tableout=string(""), transfer=initialize_variant(""), 
            listfile=string(""), append=False, refspwmap=initialize_vector(1, (int)-1), 
            gainthreshold=-1.0, antenna=string(""), timerange=string(""), 
            scan=string(""), incremental=False, fitorder=1, display=False) -> record *

        Summary
        	Bootstrap the flux density scale from standard calibrators

        Description
        	

        This function is used to bootstrap the amplitude scale the
        calibration solutions according to specified reference calibrator(s)
        of known flux density.  This is necessary when the flux densities
        of some of your calibrators were unknown (and thus were assumed
        to be 1 Jy) during G solving.

        The bootstrapping is achieved by comparing the median gain norm of the
        calibration solutions derived for the calibrators specified in {\stfaf
        reference} (one or more sources with known flux densities at the time
        of G solving) with that of the calibrators specified in {\stfaf
        transfer}, and enforcing the assumption that the antenna gains are
        constant, on average.  The gain solutions for the transfer sources are
        then re-scaled accordingly.   The {\stfaf reference} and {\stfaf transfer}
        parameters may be specified using the general field selection syntax
        (as in {\stfaf field} in {\stfaf selectvis}).

        If no {	t transfer} fields are specified, then the solutions for
        all non-reference fields in {	t tablein} will be re-scaled.  

        If no {	t tableout} is specified the input table will be overwritten
        with the scaled solutions.  Note that the resulting table will only
        contain solutions for those fields implicit in the {	t reference} and
        {	t transfer} specifications.     Use {	t append=T} to append the scaled
        solutions to an existing table.  

        Use the {\stfaf refspwmap} parameter to indicate how data for
        different spectral windows should be matched in calculating the flux
        density scale factor for {\stfaf transfer} fields. The default
        behavior for {	t refspwmap} is to insist on precisely matching
        spectral windows for {	t reference} and {	t transfer} fields.  When
        specified, the {\stfaf refspwmap} parameter takes a vector of integers
        indicating which spectral window solutions to use as the reference for
        others, such that {	t refspwmap[j]=i} causes solutions (from reference
        fields) observed in the i-th spectral window to be used to reference
        solutions (from transfer fields) observed in the j-th spectral window.
        For example, for the case of a total of 4 spectral windows: if the
        {	t reference} fields were observed only in spw=2 \& 4, and the {	t
        transfer} fields were observed variously in all 4 spws, specify {	t
        refspwmap=[2,2,4,4]}.  This will ensure that {	t transfer} fields
        observed in spws 1,2,3,4 will be referenced to {	t reference} field
        data from spws 2,2,4,4, respectively.  Note that if the {	t transfer}
        fields were observed only in spws 1 \& 3, the same specification would
        work, but {	t refspwmap=[2,2,4]} would suffice.  In this case,
        nothing need be specified for the 4th spw (there are no transfer
        fields there), and specifying 2 for the 2nd spw is actually
        inconsequential (though required so that the specification of 4 for spw 3
        is properly interpretted).

        The  gain values used in the flux scaling determination skewed by 
        outliers. The parameters, {	t gainthreshold} and {	t antenna} can be used
        to limit the input gain solutions to be included in the flux scale determination.
        Use the {	t gainthreshold} is a threshold in \% from the median values of the 
        gain solutions to be used. Use the {	t antenna} to select or de-selesect (using the
        MSSelection syntax) antenna(s). Futher refinements on the selection based on 
        timerange and scan are possible.
         
        The derived flux densities for the transfer fields will be reported in
        the logger, and returned to the Python dictionary specified in {	t
        fluxd}.  This will be an 2D array of shape [number-of-spectral-windows
        X number-of-fields]. When mulitple spectral windows are involved the spectral
        index will also be reported by fitting the determined flux densities across
        the freuquencies. The order of a polynomcial to be fitted can be specified with 
        {	t fitorder}.

        Note that elevation-dependent gain effects may render the basic
        assumption used here invalid, and so should be corrected for prior to
        solving for G, using types 'TOPAC' or 'GAINCURVE' in {	t setapply}.

        Note that the visibility data itself is not used directly by this
        function.

        Pending improvements:

        egin{itemize}
        \item Allow antenna and uv-distance selection to improve results for 
        resolved calibrators
        \item Set the visibility model according to the flux density results
        \item An option to use the data to derive the relative flux densities
        nd{itemize}



        Input Parameters:
        	tablein		 Input calibration table name 
        	reference	 Reference calibrator field names (comma-separated) 
        	tableout	 Output calibration table name. Default is input calibration table name. 
        	transfer	 Transfer source field names (comma-separated). Default is all other fields. 
        	listfile	 Name of listfile that contains the fit information. Default is '' (no file). 
        	append		 Append to existing table? false 
        	refspwmap	 List of alternate spw for referencing -1 
        	gainthreshold	 Threshold of gain amplitudes with respect to the median value to be used in flux scale calculation. Default: -1.0 (no threshold) -1.0 
        	antenna		 antenna selection/de-selection in flux scale calculation. Default: ''(include all antennas) 
        	timerange	 timerage sub-selection with antenna selection in flux scale calculation. Default: ''(include all) 
        	scan		 scan sub-selection with antenna selection in flux scale calculation. Default: ''(include all) 
        	incremental	 create a incremental caltable false 
        	fitorder	 order for spectral fitting for multiple spws 1 
        	display		 display statistics of the flux ratios false 
        	
        Example:
        	

        cb.open('ngc5921.ms')
        cb.selectvis(field='1331*,1445*')
        cb.setsolve(type='G',table='gcal',t='inf')
        cb.solve()
        cb.fluxscale (tablein='gcal', tableout='flxcal', 
                      reference='1331*', transfer='1445*');
        cb.close();


        This example generates a calibration table containing {	t G}
        solutuions ('gcal') and then writes a re-scaled version, using
        1335+305 as the reference calibrator, to derive properly scaled
        amplitude calibration for the transfer source, 1445+099.  We have
        assumed that 1331+305 has already had its MODEL\_DATA set to
        the correct flux density.


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_fluxscale(self, *args, **kwargs)

    def accumulate(self, *args, **kwargs):
        """
        accumulate(self, tablein=string(""), incrtable=string(""), tableout=string(""), field=initialize_variant(""), 
            calfield=initialize_variant(""), interp=string("linear"), t=-1.0, 
            spwmap=initialize_vector(1, (int)-1)) -> bool

        Summary
        	Accumulate incremental calibration
        solutions into a cumulative calibration table

        Description
        	

        This function enables cumulative calibration using {	t calibrater}.
        It is the analog of the task ``CLCAL'' in classic AIPS.

        The {	t accumulate} function is useful when:

        egin{itemize}
        \item a calibration solution of a particular type already exists,
        \item an incremental calibration solution {m of the same type} is desired
        (an incremental solution in this context means derived independently
        from, or determined with respect to, the first)
        \item the first calibration cannot be implicitly recovered in the course 
        of obtaining the incremental solution
        nd{itemize}

        For example, a phase-only ``G'' self-calibration on a target source
        may be desired to tweak the full amplitude and phase ``G'' calibration
        already obtained from a calibrator.  The initial calibration (from the
        calibrator) contains amplitude information, and so must be carried
        forward, yet the phase-only solution itself cannot (by definition)
        recover this information, as a full amplitude and phase
        self-calibration would.  In this case, the initial solution must be
        applied while solving for the phase-only solution, then the two
        solutions combined to form a {m cumulative} calibration embodying
        the net effect of both. In terms of the Measaurement Equation, the net
        calibration is the {m product} of the initial and incremental
        solutions.  

        The analog of {	t accumulate} in classic AIPS is the use of CLCAL to
        combine a series of (incremental) SN calibration tables to form
        successive (cumulative) CL calibration tables.

        Cumulative calibration tables also provide a means of generating
        carefully interpolated calibration, on variable user-defined
        timescales, that can be examined prior to application to the data with
        {	t setapply} and {	t correct}.  The solutions for different fields
        and/or spectral windows can be interpolated in different ways, with
        all solutions stored in the same table.

        The only difference between incremental and cumulative calibration
        tables is that incremental tables are generated directly from the data
        via {	t solve} or (in the near future) from other ancilliary data
        (e.g. weather information), and cumulative tables are generated from
        other cumulative and incremental tables via {	t accumulate}.  In all
        other respects (internal format, application to data via {	t
        setapply} and {	t correct}, plotting with {	t plotcal}, etc.), they
        are the same, and therefore interchangable.  Thus, {	t accumulate} and 
        cumulative calibration tables need only be used when circumstances
        require it.

        The {	t accumulate} function represents a generalization on the
        classic AIPS CLCAL model of cumulative calibration in that its
        application is not limited to accumulation of ``G'' solutions (SN/CL
        tables classic AIPS are the analog of ``G'' (and, implicitly, ``T'')
        in {	t aips++}).  In principle, any basic calibration type can be
        accumulated (onto itself), as long as the result of the accumulation
        (matrix product) is of the same type.  This is true of all the basic
        types, except ``D''.  Accumulation is currently supported for ``B'',
        ``G'', and ``T'', and, in future, ``F'' (ionospheric Faraday
        rotation), ``J'' (generic full-polarization calibration),
        fringe-fitting, and perhaps others.  Accumulation of certain
        specialized types (e.g., ``GSPLINE'', ``TOPAC'', etc.) onto the basic
        types will be supported in the near future.  The treatment of various
        calibration from ancilliary data (e.g., system temperatures, weather
        data, WVR, etc.), as they become available, will also make use of {	t
        accumulate} to achieve the net calibration.

        Note that accumulation only makes sense if treatment of a uniquely
        incremental solution is required (as described above), or if a careful
        interpolation or sampling of a solution is desired.  In all other
        cases, re-solving for the type in question will suffice to form
        the net calibration of that type.  For example, the product of
        an existing ``G'' solution and an amplitude and phase ``G'' self-cal 
        (solved with the existing solution applied), is equivalent to full
        amplitude and phase ``G'' selfcal (with no prior solution applied),
        as long as the timescale of this solution is at least as short as
        that of the existing solution.  

        Use of {	t accumulate} is straightforward:

        The {	t tablein} parameter is used to specify the existing cumulative
        calibration table to which an incremental table is to be applied.
        Initially, no such table exists, and {	t accumulate} will generate
        one from scratch (on-the-fly), using the timescale (in seconds)
        specified by the parameter {	t t}.  These nominal solutions will
        be unit-amplitude, zero-phase (i.e., unit matrix) calibration,
        ready to be adjusted by accumulation.  When {	t t} is negative (the
        default), the table name specified in {	t tablein} must exist and
        will be used.

        The {	t incrtable} parameter is used to specify the incremental table
        that should be applied to {	t tablein}.  The calibration type of
        {	t incrtable} sets the type assumed in the operation, so {	t
        tablein} must be of the same type.  If it is not, {	t accumulate}
        will exit with an error message.  (Certain combinations of types
        and subtypes will be supported by accumulate in the future.)

        The {	t tableout} parameter is used to specify the name of the output
        table to write.  If un-specified (or ``''), then {	t tablein} will be
        overwritten.  Use this feature with care, since an error here will 
        require building up the cumulative table from the most recent distinct
        version (if any).

        The {	t field} parameter specifies those field names (standard
        selection syntax) in {	t tablein} to which the incremental solution
        should be applied.  The solutions for other fields will be passed to
        {	t tableout} unaltered.  If the cumulative table was created from
        scratch in this run of {	t accumulate}, then these solutions will be
        unit-amplitude, zero-phase, as described above.

        The {	t calfield} parameter is used to specify the fields (standard
        selection syntax) to select from {	t incrtable} to use when applying
        to {	t tablein}.  Together, use of {	t field} and {	t calfield}
        permit completely flexible combinations of calibration accumulation
        with respect to fields.  Multiple runs of {	t accumulate} can be used
        to generate a single table with many combinations.  In future, a
        ``self'' mode will be enabled that will simplify the accumulation of
        field-specific solutions.

        The {	t interp} parameter is used to specify the interpolation type
        to use on the incremental solutions, as in {	t setapply}.  The
        currently available interpolation types are ``nearest'', ``linear'',
        and ``aipslin''.  See the {	t setapply} URM documentation for more
        details.

        The {	t spwmap} parameter enables accumulating solutions from
        differing spectral windows.  See {	t setapply} for details
        on how spwmap works.

        Pending improvements:

        egin{itemize}
        \item Implement a ``self'' mode (independent of interpolation type), 
        to simplify or eliminate use of the {	t field} and {	t calfield} 
        parameters in some contexts (e.g., self-cal)
        \item More interpolation modes, e.g., ``cubic'', and interpolation
        timescale (timerange to permit interpolation)
        \item Handle propogation (or not) of bad/flagged solutions 
        \item Support of specialized types (e.g., TOPAC) onto the basic
        types
        \item Smoothing (probably a separate function)
        nd{itemize}



        Input Parameters:
        	tablein		 Input cumulative calibration table name 
        	incrtable	 Input incremental calibration table name 
        	tableout	 Output cumulative calibration table name. Default is input table name. 
        	field		 List of fields (names) to update in input cumulative table. Default is all. 
        	calfield	 List of fields (names) in incremental table to use. Default is use all. 
        	interp		 Interpolation mode to use on incremental solutions linear 
        	t		 Cumulative table timescale when creating from scratch -1.0 
        	spwmap		 Spectral windows to apply -1 
        	
        Example:
        	

        cb.open('ap366.sim');

        # obtain G solutions from calibrator
        cb.selectvis(msselect='FIELD_ID IN [9,11]');
        cb.setsolve(type='G',table='cal.G0',t=300);
        cb.solve()

        # obtain proper flux density scale
        cb.fluxscale (tablein='cal.G0', tableout='cal.G1',
                     reference='1328+307', transfer='0917+624');

        # generate cumulative table for target source on 20s timescale
        cb.accumulate(tablein='',incrtable='cal.G1',tableout='cal.cG0',
                     field='0957+561',calfield='0917+624',
                     interp='linear',t=20);

        # apply this calibration to target
        cb.selectvis(msselect='FIELD_ID==10');
        cb.setapply(type='G',table='cal.cG0',interp='linear')
        cb.correct();

        #    (image target with imager tool)

        # phase-selfcal target on 60s timescale 
        cb.selectvis(msselect='FIELD_ID==10');
        cb.setapply(type='G',table='cal.cG0',interp='linear')
        cb.setsolve(type='G',table='cal.G2',t=60,phaseonly=T);
        cb.solve();

        # accumulate new solution onto existing one
        cb.accumulate(tablein='cal.cG0',incrtable='cal.G2',tableout='cal.cG1',
                     field='0957+561',calfield='0957+561',
                     interp='linear');

        # apply new cumulative solution to data
        cb.setapply(type='G',table='cal.cG1',interp='linear')
        cb.correct();

        #   (another round of imaging, etc.)

        cb.close();



        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_accumulate(self, *args, **kwargs)

    def activityrec(self):
        """
        activityrec(self) -> record *

        Summary
        	Returns a record containing properties of recent activity

        Description
        	

        This funtion enables returning generic information about recent activity.


        Pending improvements:

        egin{itemize}
        \item ??
        nd{itemize}


        Example:
        	

        TBD


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_activityrec(self)

    def specifycal(self, *args, **kwargs):
        """
        specifycal(self, caltable=string(""), time=string(""), spw=string(""), antenna=string(""), pol=string(""), 
            caltype=string(""), parameter=initialize_vector(1, (double)1.0), infile=string("")) -> bool

        Summary
        	Externally specify calibration
        of various types

        Description
        	

        This function enables specifying calibration parameters externally.




        Input Parameters:
        	caltable	 The calibration table name 
        	time		 Calibration timestamp 
        	spw		 Calibration spw(s) 
        	antenna		 Calibration antenna(s) 
        	pol		 Calibration polarization 
        	caltype		 Calibration timestamp 
        	parameter	 Calibration parameters 1.0 
        	infile		 Ancillary input file 
        	
        Example:
        	

        cb.open('ap366.sim');

        (TBD)

        cb.close();



        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_specifycal(self, *args, **kwargs)

    def smooth(self, *args, **kwargs):
        """
        smooth(self, tablein, tableout, field=initialize_variant(""), smoothtype=string("median"), smoothtime=60.0) -> bool

        Summary
        	Produce a smoothed calibration table

        Description
        	

        This function provides for time-dependent smoothing of sampled
        calibration solutions.  Currently supported types are 'G', 'B', and 'T'.
        (Smoothing on the frequency axis for 'B' will be supported in the near
        future.)

        Two (sliding) smoothing types are currenlty supported: 'median' or
        'mean', one of these options should be specified in {\stfaf
        smoothtype}.  The full width (in seconds) of the smoothing filter
        should be specified in {\stfaf smoothtime}.   Amplitude and
        (ambiguity-corrected) phase are smoothed separately.

        Use {\stfaf field} to limit the smoothing operation to a subset of the
        fields (standard selection syntax) found in the calibration table
        (other fields will pass to the output table unsmoothed).  If {\stfaf
        field} is left blank, all fields in the table will be smoothed.

        The smoothing is always done independently for each field, but 
        scan boundaries are not observed.  Thus, if the {\stfaf smoothtime} 
        is large enough, smoothing may occur over many boundaries. 

        Flagged solutions in the input table will not participate in the
        smoothing calculation, but will be replaced with smoothed values
        if the smoothing window covers one or more unflagged solutions when
        centered on the flagged point.

        Pending improvements:

        egin{itemize}
        \item Add other smoothtypes?
        \item Add spw and other selection on input table
        \item Add A/P toggle
        nd{itemize}



        Input Parameters:
        	tablein		 Input calibration table 
        	tableout	 Output calibration table 
        	field		 Limit smoothing to these fields (default is all fields) 
        	smoothtype	 The smoothing type: 'mean' or 'median' mean median 
        	smoothtime	 Smoothing filter time constant (sec) 60.0 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.smooth(tablein='in.gcal',tableout='out.gcal',
                 smoothtype='median',smoothtime=60);
        cb.close();


        In this example, 'G' solutions for all fields in the table 'in.gcal' are 
        smoothed using a median filter with a full-width of 60 seconds,
        and the result written to 'out.gcal'.


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_smooth(self, *args, **kwargs)

    def listcal(self, *args, **kwargs):
        """
        listcal(self, caltable, field=initialize_variant(""), antenna=initialize_variant(""), spw=initialize_variant(""), 
            listfile=string(""), pagerows=50) -> bool

        Summary
        	 List the contents of a calibration table
           

        Description
        	

        calibrater.listcal() lists antenna gain solutions in tabular
        form.  The table is organized as follows.  Solutions are output by 
        egin{enumerate}
        \item Spectral window,
        \item Antenna,
        \item Time,
        \item Channel,
        \item and Polarization.
        nd{enumerate}
        The inner-most loop is over polarization.
        A ``Spw Header'' row is printed each time the spectral window changes.  
        In addition  to listing the spectral window ID (SpwID), the Spw Header
        also lists the date of observation (Date), the calibration table name (CalTable), and the measurement
        set name (MS name).  A lower-level ``antenna header'' is printed each time the antenna
        names change or every `pagerows' of output, whichever comes first.
        The antenna header column are described here:

        egin{tabular}{ll}
        \hline \hline 
        Column Name   & Description \
        \hline
        Ant           & Antenna name \
        Time          & Visibility timestamp corresponding to gain solution \
        Field         & Field name \
        Chn           & Channel number \
        Amp           & Complex solution amplitude \
        Phs           & Complex solution  phase \
        F             & Flag \
        \hline \hline
        nd{tabular}

        Elements of the ``F'' column contain an `F' when the datum is flagged, 
        and ` ' (whitespace) when the datum is not flagged.

        Presently, the polarization mode names (for example: R, L) 
        are not given, but the ordering of the polrization modes (left-to-right) is 
        equivalent to the order output by task listobs (see ``Feeds'' in listobs output).



        Input Parameters:
        	caltable	 Calibration table to list 
        	field		 Field names or indices to list: ''==\>all 
        	antenna		 Antenna/Baseline to list: ''==\>all 
        	spw		 Spectral windows and channels: ''==\>all, spw='10:8~20' 
        	listfile	 Send output to file: ''==\>send to terminal) 
        	pagerows	 Rows per page 50 
        	
        Example:
        	


        Input:

        The following example imports a UVFITS file, performs a bandpass calibration, 
        and displays a subset of the resulting calibration table.

        pathname=os.environ.get('CASAPATH').split()[0] # Get path to CASA home dir
        fitsdata=pathname+'/data/demo/NGC5921.fits' # Select uv-data (FITS) file
        msdata='NGC5921.ms' # MS name; write to current directory
        importuvfits(fitsfile=fitsdata, vis=msdata) # import FITS data to MS
        setjy(vis=msdata) # Create model data for flux calibrator
        caldata=msdata+'.bcal' # Calibration table name
        bandpass(vis=msdata, caltable=caldata) # Bandpass calibration
        cb.open(msdata) # Open MS in cb
        cb.listcal(caltable=caldata, field='N5921_2, 0, 1', antenna='1~5;10~13;20~22', spw='0:4~6', pagerows=0) # List a subset of calibration factors

        Output:

        SpwID = 0, Date = 1995/04/13,  CalTable = NGC5921.ms.bcal (B Jones), MS name = /users/jcrossle/NRAO/casa/NGC5921.ms                                    
        -------------------------------------------------------------------------------------------------------------------------------------------------------
                                      | Ant = 1                     | Ant = 2                     | Ant = 3                     | Ant = 4                     |
        Time       Field           Chn|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|
        ----------|---------------|---|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
        09:21:46.0 1331+30500002_0   4|0.294    5.3   0.264    3.5   0.296  105.9   0.287 -111.9   0.276  -66.0   0.264  -24.5   0.269  165.8   0.281 -108.6   
        09:21:46.0 1331+30500002_0   5|0.303    5.3   0.279    0.6   0.305  107.0   0.298 -111.6   0.283  -64.2   0.274  -23.3   0.280  166.8   0.291 -108.9   
        09:21:46.0 1331+30500002_0   6|0.307    5.6   0.287   -1.6   0.309  107.5   0.303 -111.5   0.287  -63.2   0.280  -22.6   0.284  167.8   0.296 -108.8   
        10:05:27.9 1445+09900002_0   4|0.467    7.6   0.419    2.7   0.473  107.7   0.455 -112.3   0.437  -63.5   0.413  -24.8   0.427  168.2   0.446 -108.8   
        10:05:27.9 1445+09900002_0   5|0.472    7.3   0.440    0.0   0.486  109.1   0.471 -111.8   0.451  -62.6   0.436  -23.1   0.435  169.4   0.453 -108.5   
        10:05:27.9 1445+09900002_0   6|0.486    8.4   0.453   -2.4   0.482  110.0   0.478 -111.4   0.452  -60.7   0.443  -23.1   0.446  169.6   0.468 -108.6   
        10:09:05.3         N5921_2   4|0.082   50.0   0.074   34.7   0.097  -74.5   0.083   54.4   0.070  131.3   0.080  150.7   0.085   81.0   0.095  150.6   
        10:09:05.3         N5921_2   5|0.074   62.7   0.084   24.3   0.114  -73.1   0.093   47.3   0.066  119.9   0.069  154.9   0.099   81.2   0.085  147.4   
        10:09:05.3         N5921_2   6|0.079   44.4   0.081   21.7   0.092  -66.3   0.101   48.0   0.089  125.6   0.060  154.0   0.099   83.1   0.097  152.7   
                                      | Ant = 5                     | Ant = 10                    | Ant = 11                    | Ant = 12                    |
        Time       Field           Chn|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|
        ----------|---------------|---|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
        09:21:46.0 1331+30500002_0   4|0.261  -26.0   0.285 -107.1   0.279 -149.5   0.263    2.9   0.274 -102.5   0.257   -7.0   0.289  174.3   0.309 -139.2   
        09:21:46.0 1331+30500002_0   5|0.269  -26.1   0.295 -107.2   0.288 -148.8   0.274    2.3   0.283 -100.9   0.271   -6.8   0.307  173.1   0.319 -138.2   
        09:21:46.0 1331+30500002_0   6|0.272  -26.1   0.300 -107.0   0.293 -148.7   0.281    2.0   0.287  -99.7   0.280   -6.7   0.312  171.2   0.326 -137.2   
        10:05:27.9 1445+09900002_0   4|0.416  -24.0   0.450 -106.4   0.437 -147.3   0.414    3.2   0.433  -99.6   0.412   -6.8   0.456  175.9   0.477 -140.0   
        10:05:27.9 1445+09900002_0   5|0.421  -22.6   0.478 -106.1   0.453 -147.4   0.433    2.0   0.453  -98.1   0.433   -6.7   0.481  174.4   0.491 -138.9   
        10:05:27.9 1445+09900002_0   6|0.436  -22.7   0.478 -106.7   0.459 -146.6   0.443    2.4   0.457  -97.1   0.450   -7.0   0.486  173.5   0.510 -137.7   
        10:09:05.3         N5921_2   4|0.074   95.0   0.085   -4.2   0.083  109.6   0.084 -116.6   0.081   63.2   0.071  131.2   0.050  -55.4   0.083  -27.4   
        10:09:05.3         N5921_2   5|0.071   96.8   0.084  -13.7   0.086  104.3   0.100 -116.4   0.099   61.7   0.084  145.1   0.091  -76.1   0.087  -33.6   
        10:09:05.3         N5921_2   6|0.082   84.9   0.078   -5.3   0.101  109.1   0.102 -109.9   0.087   60.1   0.107  130.4   0.085  -75.5   0.080  -31.2   
                                      | Ant = 13                    | Ant = 20                    | Ant = 21                    | Ant = 22                    |
        Time       Field           Chn|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|
        ----------|---------------|---|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
        09:21:46.0 1331+30500002_0   4|0.285 -169.5   0.277  -90.4   0.254  -36.0   0.290   70.9   0.286  -97.8   0.305  108.8   0.273  -84.6   0.224 -124.2   
        09:21:46.0 1331+30500002_0   5|0.296 -168.9   0.287  -90.5   0.269  -38.6   0.300   71.0   0.296  -97.8   0.317  108.2   0.284  -85.8   0.243 -127.6   
        09:21:46.0 1331+30500002_0   6|0.301 -168.7   0.291  -90.3   0.278  -39.9   0.306   70.9   0.302  -97.8   0.326  107.2   0.289  -86.6   0.255 -129.7   
        10:05:27.9 1445+09900002_0   4|0.448 -167.2   0.434  -90.7   0.401  -34.4   0.456   70.8   0.457  -95.5   0.485  108.9   0.431  -82.1   0.361 -123.9   
        10:05:27.9 1445+09900002_0   5|0.466 -166.5   0.457  -91.1   0.423  -36.6   0.470   70.8   0.471  -96.6   0.506  108.1   0.448  -83.2   0.393 -126.7   
        10:05:27.9 1445+09900002_0   6|0.473 -166.9   0.464  -91.1   0.436  -37.8   0.485   70.2   0.476  -96.6   0.521  108.0   0.447  -83.2   0.410 -130.0   
        10:09:05.3         N5921_2   4|0.097   83.0   0.087  143.5   0.080   43.1   0.094  144.2   0.087  168.7   0.092    1.4   0.111   76.1   0.079   18.9   
        10:09:05.3         N5921_2   5|0.100   87.4   0.094  137.0   0.061   54.7   0.098  153.3   0.094  178.6   0.096   -3.7   0.101   64.6   0.091    9.5   
        10:09:05.3         N5921_2   6|0.099   93.3   0.122  140.5   0.077   51.3   0.090  151.7   0.083 -179.6   0.100    2.2   0.095   61.3   0.108    0.4   

        Listed 108 antenna solutions.




        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_listcal(self, *args, **kwargs)

    def posangcal(self, *args, **kwargs):
        """
        posangcal(self, posangcor, tablein, tableout=string("")) -> bool

        Summary
        	Apply position angle calibration to an existing cal table

        Description
        	

        This function is used to apply position angle calibration for
        observations made using circularly polarized feeds.  According to the
        Measurement Equation formalism, this correction should be applied to a
        {	t D} (instrumental polarization) calibration table.

        If no {	t D} calibration is performed (and thus no such table is
        available), the correction can be applied to a {	t G} table, but it
        should NEVER be applied to both, and always applied to a {	t D} table
        if one is available.  An input table must be specified.  If no output
        table is specified, then the input table will be modified in place.

        Specify, as a vector of values, a position angle adjustment (in degrees)
        for each spectral window.  If only one value is specified, it will be
        duplicated to all spectral windows; otherwise, the number of values
        specified must match the number of spectral windows.  The sign
        convention for the position angle adjustment is such that the specified
        value is the that which, when added to the position angle implied by the
        data, will yield the correct position angle.  For example, if {	t G-},
        {	t D-}, and {	t P-}calibrated data for 3c286 suggests a position
        angle of 45 degrees, the posangcor value should be -12 degrees as this
        will yield the correct position angle of 33 degrees when added.  In
        general, posangcor equals correct position angle minus observed position
        angle. 

        A future version of this function will have an option to recognize
        standard position angle calibrators and determine the correction
        automatically. 

        (NB: It may be desirable to use solutions for 'X' to handle
        position angle calibration, rather than this method.)




        Input Parameters:
        	posangcor	 Position angle corrections (degrees) 
        	tablein		 Input calibration table name 
        	tableout	 Output calibration table name. Default is input table name. 
        	
        Example:
        	

        cb.open('polcal.ms');
        cb.posangcal(tablein='3C286.dcal', tableout='3C286.dpacal', 
                     posangcor=[-12.0, 54.0]);
        cb.close();


        This example takes an existing calibration table containing {	t D}
        Jones matrices, and applies a position angle calibration of 45 and 54
        degrees to spectral windows 1 \& 2, respectively, writing the result
        to a new table.  The observed position angles for 3C286 must have been
        45 and -21 degrees; the corrections specified yield the correct value
        of 33 degrees when added to the observed values.

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_posangcal(self, *args, **kwargs)

    def linpolcor(self, *args, **kwargs):
        """
        linpolcor(self, tablein=string(""), tableout=string(""), fields=std::vector< string >(1, "")) -> bool

        Summary
        	Correct the gain table for linear polarization of the calibrator

        Description
        	

        THIS METHOD IS CURRENTLY DISABLED.

        This function can be used to correct the gains derived from secondary
        calibrators with unknown or variable polarization.  It should only be
        used for arrays with linear (X/Y) feeds and an Alt-Az mount for which
        the observed polarization varies with feed position angle on the sky. 

        The function fits the gains with a sine and cosine term in feed position
        angle and extracts the Q and U components of the secondary calibrator. 
        This is only possible if there is sufficient range in the position angle
        (i.e., minimum of about 6 scans spanning at least 90 degrees in position
        angle).  Check the error of the fit to judge if the fit was succesfull,
        it should generally be smaller than 0.5\%.  

        Use the {\stfaf fields} argument to select calibrator fields to be
        fitted.  The function takes a calibration table as input, and can write
        the adjusted gain solutions to the same table on output, or create a new
        table containing these results.  The function also prints the derived
        polarization for each field for each spectral window. 



        Input Parameters:
        	tablein		 Input calibration table name 
        	tableout	 Output calibration table name 
        	fields		 Calibrator field names 
        	
        Example:
        	

        cb.open('atca.ms');
        cb.linpolcor(tablein='atca.gcal', tableout='atca.gcal2', 
                     fields='2254-367');
        cb.close();


        This example takes an existing calibration table containing {	t G}
        Jones matrices, and writes a corrected output table, correcting only
        gains derived from 2254-367 for linear polarization.


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_linpolcor(self, *args, **kwargs)

    def plotcal(self, *args, **kwargs):
        """
        plotcal(self, antennas, fields, spwids, plottype=string("AMP"), tablename=string(""), polarization=1, 
            multiplot=False, nx=1, ny=1, psfile=string("")) -> bool

        Summary
        	Plot a calibration table

        Description
        	

        This function plots a calibration table either to a plotter or 
        to a file.  

        The argument {\stfaf plottype} can take the following values
        for all types of solutions: 
        egin{description}
        \item[AMP] Gain Amplitude vs. Time
        \item[1/AMP] Inverse Gain Amplitude vs. Time (useful for 
        comparing with classic AIPS)
        \item[PHASE] Gain Phase vs. Time
        \item[RI] Gain Real vs. Imaginary
        \item[RLPHASE] Right/Left Gain phase difference (if polarizations are R,L)
        \item[XYPHASE] X/Y Gain phase difference (if polarizations are X,Y)
        nd{description}

        The argument {\stfaf plottype} can take the following values
        for D tables

        egin{description}
        \item[DAMP] Cross-polarized Gain Amplitude vs. Time
        \item[DPHASE] Cross-polarized Gain Phase vs. Time
        \item[DRI] Cross-polarized Gain Real vs. Imaginary
        nd{description}

        The quality of the solutions can be examined with the following 
        {\stfaf plottype} choices:
        egin{description}
        \item[FIT] Fit per spectral window
        \item[FITWGT] Fit weight per spectral window
        \item[TOTALFIT] Total fit
        nd{description}

        By default, all antennas (as specified in the antennas argument) will
        appear on the same plot. Separate plots (all with the same scale) 
        for each antenna can be activated by setting multiplot=T.  The multiplot
        argument only separates plots by antenna (not, e.g., by the field\_id(s)
        specified in the fields argument).  If multiplot=T, the nx and ny 
        arguments can be used to specify the number of plots per page.

        At the moment, only one polarization can be plotted per execution.
        This restriction will be relaxed in the near future.

        For B solutions, the plotting will loop over timestamps (if more than
        one).  

        A hardcopy plot can be created by specifying the 	exttt{psfile}
        argument (which is especially useful for batch processing when a
        display screen is not available).  This will cause the plot to be
        written to a PostScript file which can be subsequently sent to a
        printer.  



        Input Parameters:
        	antennas	 Antennas to plot. Default is none. 
        	fields		 Fields to plot. Default is none. 
        	spwids		 Spectral windows id.'s to plot. Default is none. 
        	plottype	 Plot type 1/AMP PHASE RLPHASE XYPHASE RI DAMP DPHASE DRI FIT FITWGT TOTALFIT AMP 
        	tablename	 Calibration table name 
        	polarization	 Polarization to plot 1 
        	multiplot	 Turn on separate antenna plots false 
        	nx		 If multiplot=T, number of plots on horizontal axis 1 
        	ny		 If multiplot=T, number of plots on vertical axis 1 
        	psfile		 Name of output PostScript file to write plot to. Default is to send plot to the screen. 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.plotcal(plottype='PHASE', tablename='gcal', antennas=[1,3], polarization=2);
        cb.close();


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_plotcal(self, *args, **kwargs)

    def modelfit(self, *args, **kwargs):
        """
        modelfit(self, vary, niter=0, compshape=string("P"), par=initialize_vector(3,(double)1.0, (double)0.0, (double)0.0), 
            file=string("")) -> std::vector< double >

        Summary
        	 Model fitting

        Description
        	

        This method fits single-component models (points, elliptical Gaussians or elliptical Disks\_
        to the CORRECTED\_DATA of the selected field.  A first guess for the component
        parameters may be specified in the {\stfaf par} parameter. 



        Input Parameters:
        	vary		 If specified where T, let this parameter (in par) vary in fit 
        	niter		 Number of non-linear fitting iterations 0 
        	compshape	 Component shape, P=point G=gaussian P 
        	par		 Initial guess for fit parameters (default is for 'P)'I flux, rel RA, rel Dec, 1,0, 0.0, 0.0 are defaults 1.0 0.0 0.0 
        	file		 If specified, output componentslist file name, if empty don't write componentslist file 
        	
        Example:
        	

        cb.open('ngc5921.ms');
        cb.selectvis(field='1331*')
        cb.modelfit(compshape='P',par=[15.0,0.0,0.0]) 
        cb.close();


        This example fits a point source mode using 15.0 Jy at the origin (phase center)
        as a first guess.



        cb.open('ngc5921.ms');
        cb.selectvis(field='1331*')
        cb.modelfit(compshape='G',par=[15.0,0.0,0.0,2.0,1.0,0.0]) 
        cb.close();


        This example fits a Guassian model with a starting
        guess of 15 Jy at the phase center (0,0), with 2.0 arcsec major axis,
        1.0 axial ratio, at position angle 0.0 deg.


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_modelfit(self, *args, **kwargs)

    def updatecaltable(self, *args, **kwargs):
        """
        updatecaltable(self, caltable) -> bool

        Summary
        	Caltable modernizer.

        Description
        	
        This method can be used to update a caltable (from v3.4 or later)
        to the current version of CASA.

        The following updates are currently supported.

        o At CASA v4.1.0, the OBSERVATION subtable and OBSERVATION\_ID column
        were added to caltables.  This method adds trivial versions of
        these elements to pre-v4.1 caltables.



        Input Parameters:
        	caltable	 Name of the caltable. 
        	
        Example:
        	
        cb.updatecaltable('mycaltable');

        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_updatecaltable(self, *args, **kwargs)

    def close(self):
        """
        close(self) -> bool

        Summary
        	Close the calibrater tool

        Description
        	
        Close the {	t calibrater} tool, which is hardly ever necessary.


        Example:
        	

        cb.open('ngc5921.ms');
        cb.close();


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_close(self)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Destroy the calibrater tool

        Description
        	
        This function is redundant with the {\stfaf close} method.


        Example:
        	

        cb.open('ngc5921.ms');
        cb.done();


        --------------------------------------------------------------------------------
        	      
        """
        return _calibrater.calibrater_done(self)

calibrater_swigregister = _calibrater.calibrater_swigregister
calibrater_swigregister(calibrater)

# This file is compatible with both classic and new-style classes.


