# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_imager', [dirname(__file__)])
        except ImportError:
            import _imager
            return _imager
        if fp is not None:
            try:
                _mod = imp.load_module('_imager', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _imager = swig_import_helper()
    del swig_import_helper
else:
    import _imager
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class imager(_object):
    """Proxy of C++ casac::imager class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, imager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, imager, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_pixels_advise"] = _imager.imager__pixels_advise_set
    __swig_getmethods__["_pixels_advise"] = _imager.imager__pixels_advise_get
    if _newclass:_pixels_advise = _swig_property(_imager.imager__pixels_advise_get, _imager.imager__pixels_advise_set)
    __swig_setmethods__["_cell_advise"] = _imager.imager__cell_advise_set
    __swig_getmethods__["_cell_advise"] = _imager.imager__cell_advise_get
    if _newclass:_cell_advise = _swig_property(_imager.imager__cell_advise_get, _imager.imager__cell_advise_set)
    __swig_setmethods__["_facets_advise"] = _imager.imager__facets_advise_set
    __swig_getmethods__["_facets_advise"] = _imager.imager__facets_advise_get
    if _newclass:_facets_advise = _swig_property(_imager.imager__facets_advise_get, _imager.imager__facets_advise_set)
    __swig_setmethods__["_phasecenter_advise"] = _imager.imager__phasecenter_advise_set
    __swig_getmethods__["_phasecenter_advise"] = _imager.imager__phasecenter_advise_get
    if _newclass:_phasecenter_advise = _swig_property(_imager.imager__phasecenter_advise_get, _imager.imager__phasecenter_advise_set)
    __swig_setmethods__["_bmaj_fitpsf"] = _imager.imager__bmaj_fitpsf_set
    __swig_getmethods__["_bmaj_fitpsf"] = _imager.imager__bmaj_fitpsf_get
    if _newclass:_bmaj_fitpsf = _swig_property(_imager.imager__bmaj_fitpsf_get, _imager.imager__bmaj_fitpsf_set)
    __swig_setmethods__["_bmin_fitpsf"] = _imager.imager__bmin_fitpsf_set
    __swig_getmethods__["_bmin_fitpsf"] = _imager.imager__bmin_fitpsf_get
    if _newclass:_bmin_fitpsf = _swig_property(_imager.imager__bmin_fitpsf_get, _imager.imager__bmin_fitpsf_set)
    __swig_setmethods__["_bpa_fitpsf"] = _imager.imager__bpa_fitpsf_set
    __swig_getmethods__["_bpa_fitpsf"] = _imager.imager__bpa_fitpsf_get
    if _newclass:_bpa_fitpsf = _swig_property(_imager.imager__bpa_fitpsf_get, _imager.imager__bpa_fitpsf_set)
    __swig_setmethods__["_pointsource_sensitivity"] = _imager.imager__pointsource_sensitivity_set
    __swig_getmethods__["_pointsource_sensitivity"] = _imager.imager__pointsource_sensitivity_get
    if _newclass:_pointsource_sensitivity = _swig_property(_imager.imager__pointsource_sensitivity_get, _imager.imager__pointsource_sensitivity_set)
    __swig_setmethods__["_relative_sensitivity"] = _imager.imager__relative_sensitivity_set
    __swig_getmethods__["_relative_sensitivity"] = _imager.imager__relative_sensitivity_get
    if _newclass:_relative_sensitivity = _swig_property(_imager.imager__relative_sensitivity_get, _imager.imager__relative_sensitivity_set)
    __swig_setmethods__["_sumweights_sensitivity"] = _imager.imager__sumweights_sensitivity_set
    __swig_getmethods__["_sumweights_sensitivity"] = _imager.imager__sumweights_sensitivity_get
    if _newclass:_sumweights_sensitivity = _swig_property(_imager.imager__sumweights_sensitivity_get, _imager.imager__sumweights_sensitivity_set)
    __swig_setmethods__["_senrec_sensitivity"] = _imager.imager__senrec_sensitivity_set
    __swig_getmethods__["_senrec_sensitivity"] = _imager.imager__senrec_sensitivity_get
    if _newclass:_senrec_sensitivity = _swig_property(_imager.imager__senrec_sensitivity_get, _imager.imager__senrec_sensitivity_set)
    __swig_setmethods__["_pointsource_apparentsens"] = _imager.imager__pointsource_apparentsens_set
    __swig_getmethods__["_pointsource_apparentsens"] = _imager.imager__pointsource_apparentsens_get
    if _newclass:_pointsource_apparentsens = _swig_property(_imager.imager__pointsource_apparentsens_get, _imager.imager__pointsource_apparentsens_set)
    __swig_setmethods__["_relative_apparentsens"] = _imager.imager__relative_apparentsens_set
    __swig_getmethods__["_relative_apparentsens"] = _imager.imager__relative_apparentsens_get
    if _newclass:_relative_apparentsens = _swig_property(_imager.imager__relative_apparentsens_get, _imager.imager__relative_apparentsens_set)
    def __init__(self): 
        """__init__(self) -> imager"""
        this = _imager.new_imager()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _imager.delete_imager
    __del__ = lambda self : None;
    def advise(self, *args, **kwargs):
        """
        advise(self, takeadvice=True, amplitudeloss=0.05, fieldofview=initialize_variant("1.0deg"), _pixels=_pixels_advise, 
            _cell=_cell_advise, _facets=_facets_advise, _phasecenter=_phasecenter_advise) -> bool

        Summary
        	Advise (and optionally use) parameter values

        Description
        	
        Advise on recommended values of certain parameters. Return these
        values and optionally use them in Imager.

        The calculations are performed as following:

        egin{description}
        \item[cell] The maximum uv distance in wavelength is found and then half of the
        inverse is taken as the maximum cellsize allowed.
        \item[pixels] The field of view is converted to a number of pixels
        using the calculated cell size.
        \item[facets] The number of facets on an axis is calculated in two
        different ways. The first method simply requires that the peeling of 
        facets away from the celestial sphere should not cause an amplitude
        drop of more than the argument {	t amplitudeloss}. The positions may
        be incorrect, but all the sources will be removed correctly. The
        second method requires that the source positions be accurate to the
        same fraction of the beam specified by {	t amplitudeloss}. The 
        second calculates the second moment in w and in uv distance and
        chooses the number of facets correspondingly. The first method does
        the same but after fitting a plane to the sampling: $w = a u + b v$.
        For an approximately coplanar array, the positions may be wrong but
        the removal of sidelobes will be accurate. The number of facets
        returned is the second, usually smaller, number. The formula used
        is:
        egin{equation}
        N\_{facets} = N\_{pixels} \sqrt{{{\Delta 	heta}\over{\sqrt{8 \delta A}}}{w\_{rms}}\over{uv\_{rms}}}
        nd{equation}
        where $\Delta 	heta$ is the cellsize in radians, and $\delta A$ is
        the amplitude loss. This formula can be derived from (a) the peeling
        of facets from the celestial sphere, and (b) a quadratic approximation 
        for the beam size both in the plane of the sky and along the $w$ axis.
        nd{description}



        Input Parameters:
        	takeadvice	 Use the advised values? true 
        	amplitudeloss	 Maximum fractional amplitude loss due to faceting 0.05 
        	fieldofview	 Desired field of view 1.0deg 
        	

        Output Parameters:
        	_pixels		 Number of pixels on a side 
        	_cell		 Recommended maximum cellsize 
        	_facets		 Recommended number of facets on one axis 
        	_phasecenter	 Direction of phase center as a measure 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_advise(self, *args, **kwargs)

    def advisechansel(self, *args, **kwargs):
        """
        advisechansel(self, freqstart=1.0e6, freqend=1.1e6, freqstep=100.0, freqframe=string("LSRK"), msname=string(""), 
            fieldid=0, getfreqrange=False, spwselection=string("")) -> record *

        Summary
        	Advise on spw and chan selection optimal for the image frequency range wanted

        Description
        	
         Basically tells you what channels of which spectral window need to be
         selected for your image spectral parameters.  The freqstep is used to
         calulate the extra padding needed for data selection at the begining
         and end of the range.  The freqframe parameter is the frame in which
         the frequency range is being given. It will be converted to the frame
         of the data with time to locate which channel match.
         A record will be returned with an element for each ms  used in selectvis.
         Each element of the record will have the spwids and channel start and nchan for each spwid.
          if the parameter msname is used then the MSs associated associated with
          this tool (that have been either 'open'ed or 'selectvis'ed) are ignored
          In this mode it is a helper function to the general world ...no need to
          open or selectvis. You need to specify the field\_id for which this calculation is 
          being done for in the helper mode. 
          If you have already set MS's and selected data and msname='' then 
          the calulation is done for the field(s) selected in selectvis.

        If the parameter {	t getfreqrange=True} then the reverse is requested. You set {	t spwselection} to be the range of data selection you want to use and you'll get the range of frequency covered in the frame you set. 



        Input Parameters:
        	freqstart	 Begining of frequency range in Hz 1.0e6 
        	freqend		 End of frequency range in Hz 1.1e6 
        	freqstep	 spectral channel resolution of intended image in Hz 100.0 
        	freqframe	 frame in which frequency is being expressed in other parameters LSRK 
        	msname		 name of an ms, if empty string it will use the ms's used in selectvis 
        	fieldid		 fieldid to use when msname is not empty otherwise ignored and field selected in selectvis is used 0 
        	getfreqrange	 if set then freqrange is returned in the frame requested for the data selected false 
        	spwselection	 if getfreqrange=True then this is needed to find the range of frequency in the frame requested 
        	
        Example:
        	
        In this example, we are interested in an image cube which span 20.0682GHz to 20.1982 in LSRK  which will have a channel resolution of 3.9MHz. The field we are interested is field 4 of each of the ms.


        #######
        im.selectvis(vis='test1.ms', field='4', spw='*')
        im.selectvis(vis='test2.ms', field='4', spw='*')
        selinfo=im.advisechansel(freqstart=2.00682e10, freqend=2.01982e10, freqstep=3.9e3, freqframe='LSRK')
        ####The output 'selfinfo' will be a record which will look like thus
        {'ms_0': {'nchan': array([109,  23], dtype=int32),
                  'spw': array([4, 5], dtype=int32),
                  'start': array([19,  0], dtype=int32)},
         'ms_1': {'nchan': array([109,  23], dtype=int32),
                  'spw': array([4, 5], dtype=int32),
                  'start': array([19,  0], dtype=int32)}}
        ###
        Thus from the first ms a spw selection like  '4:19~127, 5:0~22'  is all that is needed. 
        Similarly from the second ms.

        ###if you need this info without needing to change the state of the imager tool 
        then you can it as follows

        im.advisechansel(freqstart=2.00682e10, freqend=2.01982e10, freqstep=3.9e3, freqframe='LSRK', msname='test1.ms', fieldid=4)


        ####now if you want to see what frequency range is covered, in the frame 
        ####defined by freqframe, in spwselection you want to use
        im.selectvis(vis='test3.ms', spw='0:20~210')
        im.advisechansel(getfreqrange=True, freqframe='LSRK')
        ### the output will be something
         {'freqend': 346020345384.64178, 'freqstart': 345683852920.1723}

        ###and if you just want to use it as a helper function without touching the state 
        ###of imager

        im.advisechansel(msname='test3.ms', getfreqrange=True, spwselection='0:20~210')



        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_advisechansel(self, *args, **kwargs)

    def approximatepsf(self, *args, **kwargs):
        """
        approximatepsf(self, psf=string(""), async=False) -> bool

        Summary
        	Calculate approximate point spread functions

        Description
        	
        Calculate the approximate point spread function.
        {m Note that the model visibilities are updated}.

        Some types of imaging do not yield a well-defined point spread
        function. For example, mosaicing or single dish imaging both yield
        point spread functions that are position dependent. Nevertheless, one
        can still usefully define an {m approximate} PSF that is of some
        utility. This is calculated by doing the following calculation: a
        point source is located at the center of the specified coordinate
        system and the model data predicted. The approximate PSF is then formed from
        those model data using the full sky equation. For regular sampling in
        the image plane, this approximate PSF is actually quite good. It can
        be used in a deconvolution. For a mosaic with similar uv sampling per
        pointing, the approximate PSF is roughly the PSF per pointing
        multiplied by the primary beam. For a single dish image, it is roughly
        the telescope primary beam convolved with itself (if the
        gridfunction='pb' was selected).


        Input Parameters:
        	psf		 Name of output point spread function 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	
        Example of how to make the approximate psf for a mosaic:

        im.open('orion.ms')
        im.selectvis(spwid=[0, 1] ,field=range(2,11));
        im.defineimage(nx=300, ny=300, cellx='2.0arcsec',celly='2.0arcsec' , stokes='I', phasecenter=6, spwid=[0,1])
        im.weight('natural')
        im.setvp(dovp=T, usedefaultvp=True)
        im.setoptions(ftmachine='mosaic', padding=1.0)
        im.approximatepsf(psf='LePSF.image')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_approximatepsf(self, *args, **kwargs)

    def boxmask(self, *args, **kwargs):
        """
        boxmask(self, mask=string(""), blc=initialize_vector(4,(int)0, (int)0, (int)0, (int)0), trc=std::vector< int >(), 
            value=1.0) -> bool

        Summary
        	Construct a mask image from blc, trc

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution. 

        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. boxmask does not enforce
        this requirement.



        Input Parameters:
        	mask		 name of mask image 
        	blc		 Bottom left corner 0 0 0 0 
        	trc		 Top right corner, should be image shape 
        	value		 Value to fill in 1.0 
        	
        Example:
        	

        im.boxmask(mask='bigmask', blc=[56,45,1,1], trc=[87,93,4,1])
        im.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)



        Makes the image bigmask, and then sets it to unity for all points in
        the region bounded by the blc and trc.  Then cleans using it as the
        mask.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_boxmask(self, *args, **kwargs)

    def calcuvw(self, *args, **kwargs):
        """
        calcuvw(self, fields=initialize_vector(1, (int)-1), refcode=string(""), reuse=True) -> bool

        Summary
        	Calculates (u, v, w) coordinates for the ms.

        Description
        	
             This calculates (u, v, w) positions for the visibilities using the antenna
             and feed positions and offsets, the time, and the phase tracking center(s).
           

        Input Parameters:
        	fields		 Field IDs (numbered relative to 0) to operate on. Blank = all. -1 
        	refcode		 Reference frame to use for the generated (u, v, w)s. WARNING: clean and the im tool ignore the reference frame claimed by the UVW column (it is often mislabelled as ITRF when it is really J2000) and instead assume the (u, v, w)s are in the same frame as the phase tracking center. calcuvw does not yet force the UVW column and field centers to use the same reference frame! Blank = use the phase tracking frame of vis. 
        	reuse		 Start from the UVWs in vis (True) or calculate them from the antenna positions? true 
        	
        Example:
        	
             
             im.open('3C273XC1.MS')
             im.calcuvw()
             im.done()
             
           
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_calcuvw(self, *args, **kwargs)

    def clean(self, *args, **kwargs):
        """
        clean(self, algorithm=string("clark"), niter=1000, gain=0.1, threshold=initialize_variant("0.0Jy"), 
            displayprogress=False, model=std::vector< string >(1, ""), keepfixed=initialize_vector(1, (bool)false), 
            complist=string(""), mask=std::vector< string >(1, ""), 
            image=std::vector< string >(1, ""), residual=std::vector< string >(1, ""), 
            psfimage=std::vector< string >(1, ""), interactive=False, 
            npercycle=100, masktemplate=string(""), async=False) -> record *

        Summary
        	Calculate a deconvolved image with selected clean algorithm

        Description
        	
        Makes a clean image using either the Hogbom, Clark, multi-scale or multi-field
        algorithms. The Clark algorithm is the default. The clean is performed
        on the residual image calculated from the visibility data currently
        selected. Hence the first step performed in clean is to transform the
        current model or models (optionally including a componentlist) to fill
        in the MODEL\_DATA column, and then inverse transform the residual
        visibilities to get a residual image. This residual image is then
        cleaned using the corresponding point spread function. This means that
        the initial model is used as the starting point for the
        deconvolution. Thus if you want to restart a clean, simply set the
        model to the model that was previously produced by clean.

        Rather than explicit CLEAN boxes, mask images are used to constrain
        the region that is to be deconvolved. To make mask images,
        use either boxmask (to define a mask
        via the corner locations blc and trc) or 
        mask (to define a mask via
        thresholding an existing image) or regionmask (to make masks via regions using the regionmanager or interactively through the viewer)  . The default mask is the inner quarter
        of the image.

        The CLEAN deconvolution is joint in whatever Stokes parameters are
        present. Thus it searchs for peaks in either $I$ or $I+|V|$ or
        $I+\sqrt{Q^2+U^2+V^2}$, the rationale for the latter two forms being
        to be biased towards finding strongly polarized pixels first (these
        forms are also the maximum eigenvalue of the coherency matrix).  The
        PSF is constrained to be the same in all polarizations (a feature of
        this implementation, not of the Hamaker-Bregman-Sault formalism). But the option of 
        searching peaks in the stokes planes independently is available via 
        the {	t clarkstokes} parameter



        The clean algorithms possible are:
        egin{description}
        \item[Hogbom] The classic algorithm: points are found iteratively
        by searching for the peak. Each point is subtracted from the
        full residual image using the shifted and scaled point spread
        function.
        \item[Multiscale] An experimental multi-scale clean algorithm is invoked.
        The algorithm is fully described in 
        deconvolver.
        \item[Clark] The faster algorithm: the cleaning is split into
        minor and major cycles. In the minor cycles only the brightest
        points are cleaned, using a subset of the point spread function.
        In the major cycle, the points thus found are subtracted correctly
        by using an FFT-based convolution.
        \item[Multi-field] Cleaning is split into minor and major
        cycles. For each field, a Clark-style minor cycle is performed. 
        In the major cycle, the points thus found are subtracted
        either from the original visibilities (for multiple fields)
        or using a convolution (for only one field). The latter is
        much faster.  Multi-field imaging has been implemented for
        Clark, Hogbom, and Multi-scale deconvolution algorithms.
        \item[Cotton-Schwab] Cleaning is split into minor and major
        cycles. For each field, a Clark-style minor cycle is performed. 
        In the major cycle, the points thus found are subtracted
        from the original visibilities. A fast variant does a convolution
        using a FFT. This will be faster for large numbers of
        visibilities. Double the image size from that used for Cotton-Schwab
        and set a mask to clean only the inner quarter.
        \item[Wide-field] The user will need to use a wide-field algorithm to
        deconvolve if the array is not coplanar over the field of view being
        imaged . The technique used is to break the field being imaged into
        smaller pieces (facets), over each of which the array appear
        planar. We implement a rectangular facetting scheme. If the number of
        facets specified in defineimage is
        greater than one, Either wfhogbom or wfclark algorithm has to be
        selected here to perform a wide-field decovolution. The function
        advise can be used to calculate or
        check if you need to use a wide-field deconvolution. Note that
        aliasing can be reduced by using the {	t padding} argument in
        setoptions. In practice the
        previous sentence means that if you notice the clean to diverge at the
        edges of the facets then you need to use a larger amount of padding
        for the FT; the default being 1.2. Wide-field imaging has been
        implemented for Clark and Hogbom algorithms.
        nd{description}

        The multi-field clean should be used if either of two conditions
        hold:
        egin{enumerate}
        \item Multiple fields are to be cleaned simultaneously {f OR}
        \item Primary beam correction is enabled. In this case, a
        mosaiced clean is performed.
        nd{enumerate}

        Note that for the single pointing algorithms, only a quarter of the
        image may be cleaned. If no mask is set, then the cleaned region
        defaults to the inner quarter. If a mask larger than a quarter of the
        image is set, then only the inner quarter part of that mask is used.
        However, for the wide-field and multi-field imaging (including the
        Cotton-Schwab algorithm), the entire field may be imaged because the
        major cycles either do an exact subtraction from the visibilities or
        because PSF extent is more than twice the extent of the primary beam
        support.

        Before {	t clean} can be run, you must run {	t selectvis} and {	t defineimage}.
        Before {	t clean} can be run with a multi-field algorithm (especially for mosaic), you should run
        {	t setvp}.  You may want to run {	t setmfcontrol} before running {	t clean}
        with a multi-field or wide-field algorithm, though the default control values
        may be acceptable.  Before {	t clean} can be run with a multi-scale algorithm,
        {	t setscales} must be run.


        Interactive cleaning/masking: If the user wants to see what the clean
        image looks like after npercycle iteration and mask or modify the mask
        each time, he/she should set {	t interactive=True} and give npercycle to a
        fraction of niter. A viewer with the last residual image along with an
        overlayed mask appear after every npercycle iteration. The user can
        add or delete regions (by clicking on the appropriate button) to the
        mask using the region button and drawing regions and double clicking
        inside the region. When satisfied and ready to continue cleaning press 'DONE
        with masking' (if the user want to terminate the cleaning process use
        the 'STOP' button). The button 'No more mask changes' should be used
        if the user want clean to proceed without any further interruption.
        Even if {	t interactive=False}, and if the parameter
        'mask' is non-empty, it is still used in limiting the search area for
        clean components.  If the parameter 'masktemplate' is not empty this
        means that the user want to use an apriori image to make the mask the
        first time (e.g a previously cleaned image)

        This function returns a record containing convergence, iterations used and threshold reached. 




        Input Parameters:
        	algorithm	 Algorithm to use clark clarkstokes hogbom multiscale mfclark mfclarkstokes csclean csfast mfhogbom mfmultiscale wfclark wfhogbom clark 
        	niter		 Number of Iterations, set to zero for no CLEANing 1000 
        	gain		 Loop Gain for CLEANing 0.1 
        	threshold	 Flux level at which to stop CLEANing 0.0Jy 
        	displayprogress	 Display the progress of the cleaning? false 
        	model		 Names of clean model images 
        	keepfixed	 Keep one or more models fixed false 
        	complist	 Name of component list 
        	mask		 Names of mask images used for CLEANing 
        	image		 Names of restored images 
        	residual	 Names of residual images 
        	psfimage	 Names of psfs if they are needed 
        	interactive	 whether to stop clean and interactively mask false 
        	npercycle	 If interactive is 'T', then no of iter of clean before stopping, usually a fraction of niter 100 
        	masktemplate	 If non empty then will use this image to make the mask the first time 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

        im.clean(model='3C273XC1.clean.model',
        mask='3C283XC1.mask', niter=1000, gain=0.25, threshold='0.03Jy')


        A few points should be noted in this example:

        egin{itemize}
        \item When the mask parameter is specified, the number of mask images
              listed should be equal to the number of model images.  They
              should also have the same coordinate system as their
              corresponding model images.  
        \item If one or more model images are listed in the model parameter
              but the image and residual parameters are empty, the restored
              and residual images are automatically named as the model names
              appended with '.restored' and '.residual', respectively.
        \item No restored or residual image is made if the respective image 
              string is explicitly unset.
        nd{itemize}


        include 'imager.g';
        msfile = 'vlac125K.ms';
        im.open(msfile);
        npix = 500; cell='5arcsec';
        #
        # CS on 500 by 500
        #
        im.defineimage(nx=npix, ny=npix, cellx=cell, celly=cell, stokes='I',
        	      spw=[0,1]);
        im.setoptions(padding=1.0);
        im.selectvis(spwid=[0,1]);
        im.clean('cs', model='vlac125K.cs', image='vlac125K.cs.restored',
        	   niter=1000, gain=0.1);
        #
        # CSF on 1000 by 1000, cleaning a given box
        #

        im.defineimage(nx=2*npix, ny=2*npix, cellx=cell, celly=cell, stokes='I',
        	      spwid=[1,2]);
        reg=rg.box(blc=[400,500], trc=[450,550])
        im.regionmask('vlac125K.mask', region=reg);
        im.clean('csf', model='vlac125K.csf', image='vlac125K.csf.restored',
        	   mask='vlac125K.mask', niter=1000, gain=0.1);

        #
        # CS on 1000 by 1000, cleaning entire image
        #

        im.defineimage(nx=2*npix, ny=2*npix, cellx=cell, celly=cell, stokes='I',
        	      spwid=[1,2]);
        im.clean('cs', model='vlac125K.csl', image='vlac125K.csl.restored',
        	   mask='vlac125K.mask', niter=1000, gain=0.1);

        im.done();


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_clean(self, *args, **kwargs)

    def clipimage(self, *args, **kwargs):
        """
        clipimage(self, image=string(""), threshold=initialize_variant("0.0Jy")) -> bool

        Summary
        	Zero all pixels where Stokes I is below
        a threshold

        Description
        	
        All pixels in the image with Stokes I less than some threshold
        are set to zero. This is useful prior to self-calibration where one 
        oftens wishes to remove negative pixels from the model. Note that
        if the image has polarization information, then the polarized
        part of a pixel is also set to zero if Stokes I is less than the
        threshold.


        Input Parameters:
        	image		 name of image 
        	threshold	 Threshold 0.0Jy 
        	
        Example:
        	

        im.clipimage(image='clean', threshold='50mJy')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_clipimage(self, *args, **kwargs)

    def clipvis(self, *args, **kwargs):
        """
        clipvis(self, threshold=initialize_variant("0.0Jy")) -> bool

        Summary
        	Flag visibilities where residual exceeds
        a threshold

        Description
        	
        All visibilities where the residual exceeds some threshold
        are flagged. This provides a simple way of flagging bad
        data.


        Input Parameters:
        	threshold	 Threshold 0.0Jy 
        	
        Example:
        	

        im.plotvis('residual')
        # determine threshold then apply it
        im.clipvis(threshold='50mJy')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_clipvis(self, *args, **kwargs)

    def close(self):
        """
        close(self) -> bool

        Summary
        	Close the imager tool, with data written on disk, keeping imager process running for future use

        Description
        	
        This is used to close {	t imager} tools. Note that the
        data is written to disk. The {	t imager} process keeps running
        until a done tool function call is performed.

        Example:
        	

        im.open('3C273XC1.MS')      
        im.makeimage(image='3C273XC1.dirty',type='corrected')
        im.close()


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_close(self)

    def defineimage(self, *args, **kwargs):
        """
        defineimage(self, nx=128, ny=-1, cellx=initialize_variant("1.0"), celly=initialize_variant(""), stokes=string("I"), 
            phasecenter=initialize_variant("0"), mode=string("mfs"), nchan=-1, 
            start=initialize_variant("0"), step=initialize_variant("1"), spw=initialize_vector(1, (int)0), 
            restfreq=initialize_variant(""), outframe=string("LSRK"), 
            veltype=string("radio"), facets=1, movingsource=initialize_variant(""), 
            distance=initialize_variant("0.0")) -> bool

        Summary
        	Set the image parameters for subsequent processing

        Description
        	
        Define the default image parameters. If an image is to be
        made, then these parameters are used in the construction
        of the image. Thus, for example, the tool function make
        makes an (empty) image using these parameters. 

        Note that some parameters can be specified either in canonical units
        or via measures. To establish default values, the ids for the default
        spectral window and default field id must be given.

        The parameter {	t mode} can be one of the following:
        egin{itemize}
        \item mfs
        \item channel
        \item velocity or opticalvelocity
        \item frequency
        nd{itemize}

        {	t imager} can perform multi-frequency synthesis over several
        spectral windows (mode='mfs'). To achieve this, you should set spwid
        to an array of the required spectral windows ({m e.g.}  {	t
        spwid=[0,1]}).\ WARNING: For multifrequency synthesis, 'mfs', it is
        important that the spwid's selected in selectvis be the SAME
        as the one selected in {	t defineimage}.  Otherwise the frequency at which
        the image is made is not going to be the same as to the one as the one
        used in gridding the visibility and can lead to image artifacts.  For
        {	t mode='velocity'} and {	t mode='frequency'} the {	t step}
        parameter has to be a measure/quantity of velocity or frequency,
        otherwise for {	t mode='channel'} step is the number of data
        channels to be averaged to make one image channel( see examples
        below).


        The phase center of the image defaults to that of the specified
        phasecenter (the first fieldid in the ms is taken if none is
        specified), this parameter can be a fieldid or a measure string or the
        record output from the direction function of the measures tool( direction ).  
        This is important if you have multiple pointings in the data. The user 
        would have used selectvis to select which pointings would be used in imaging. If the
        conversion from the observed direction requires frame information then
        this is taken as follows: egin{itemize} \item Direction information,
        including the coordinate system, is taken from the relevant entry in
        the Field table of the MeasurementSet.  \item The epoch is taken from
        the time of observation of each visibility.  \item A position is
        specified via the {	t imager} tool function setoptions
        nd{itemize}

        If the specified number of facets is greater than unity then the image
        is split into facets (this number along the x and y axes) and
        processed. This is necessary when using wide-field algorithm for
        deconvolving the image, in cases of non-coplanar arrays (e.g the VLA
        at low frequencies but can be safely left at 1 for the ATCA or WSRT).
        This is now recommended only when memory or image size is of a problem, 
        otherwise for widefield issues, wprojection (ftmachine parameter in setoptions) is recommended with a single 
        facet. 

        For spectral imaging {	t defineimage} and {	t selectvis} defines the
        spectral channels that are imaged. Examples are given in the selectvis section.
        The parameter {	t restfreq} can be used to define what rest frequency
        to use in the resulting images. If none is specified imager will try
        to use the one that is defined in the ms. It will use the first one
        defined in the first spectral window selected.

        For wide-field or 3D imaging see setoptions
        section for some examples.

        If the telescope is observing moving source (e.g planet or moon) over
        a period of time. One may wish to image in a frame where the source is
        fixed. The parameter {	t movingsource} is for that. Setting it to a
        source that {	t measures} is aware of will force the imaging to
        realign (shift in SD imaging or phase rotation in interferometry
        imaging) the data so that the source appears fixed in the
        image. Obviously in doing so the background sources will be
        blurred. The coordinate system used to fix the source on is the one where
        the source is at the first time observed in the selected data.




        Input Parameters:
        	nx		 Total number of spatial pixels in x 128 
        	ny		 Total number of spatial pixels in y -1 
        	cellx		 Cellsize in x (e.g. '1arcsec') 1.0 
        	celly		 Cellsize in y (e.g. '1arcsec') 
        	stokes		 Stokes parameters to image (e.g. 'IQUV') IV IQU IQUV I 
        	phasecenter	 Direction of phase center as a diretion measure or a field id 0 
        	mode		 Type of processing (velocity =radiovelocity) frequency radiovelocity opticalvelocity truevelocity mfs 
        	nchan		 Number of channels; a -1 (default) means all the channels as selected in selectvis and combined into one continuum channel -1 
        	start		 Start channel; A 0-relative channel number of the spwid or a frequency quantity or a velocity quantity or radial velocity measure 0 
        	step		 Step in channel; integer for number of channels or frequency quantity or velocity quantity or radial velocity measure 1 
        	spw		 Spectral Window Id (0 relative) that defines center of image 0 
        	restfreq	 rest frequency to use; default =\& use the one available in ms 
        	outframe	 frequency frame of output image (default LSRK, '' =\> as input ms or LSRK in case of multiple ms's), options are LSRK, LSRD, BARY, GALACTO, LGROUP, CMB LSRK LSRK LSRD BARY GALACTO LGROUP CMB 
        	veltype		 velocity definition ('radio' or 'optical' or 'relativistic') optical relativistic radio 
        	facets		 Number of facets on each axis 1 
        	movingsource	 Name of moving source, e.g planet or moon, to keep fixed in image 
        	distance	 Distance to object: usually ignore this! (m) 0.0 
        	
        Example:
        	

        ## Example 1
        im.defineimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
        nchan=1, stokes='IV', phasecenter=me.direction('mars'));
        ## Example 2
        im.defineimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
        nchan=1, stokes='IV', phasecenter=['J2000', '19:00:30.5', '-45d00m25.6']);
        ## Example 3
        im.selectvis(nchan=10, start=3, spw=[0,1], field=[3, 4, 5, 6, 7, 9, 10])
        im.defineimage(nx=500, ny=500, mode='mfs', spwid=[0,1], fieldid=7)
        im.clean(algorithm='mfclark', niter=1000, model='mosaic.model', image='mosaic.image') 

        ## Example 4

        dir1=me.direction('J2000', '20h00m00', '21d00m00')
        dir2=me.direction('J2000', '20h10m00', '21d00m00')
        dir3=me.direction('J2000', '20h00m00', '21d03m00')
        im.defineimage(nx=100,  cellx='0.1arcsec', phasecenter=dir1)
        im.make('box1')
        im.defineimage(nx=100, cellx='0.1arcsec', phasecenter=dir2)
        im.make('box2')
        im.defineimage(nx=100, cellx='0.1arcsec', celly='0.1arsec', phasecenter=dir3)
        im.make('box3')
        im.clean(algorithm='mfclark', model=['box1', 'box2', 'box3'], 
        	   image=['box1.restored', 'box2.restored', 'box3.restored'],
        	   residual=['box1.residual', 'box2.residual', 'box3.residual'])



        In the first example, the image parameters are set for 1024 by 1024
        pixels of 30milli arcsec, 1 channel will be made, Stokes I and V will be
        imaged, and the phasecenter will be the direction of Mars as given by
        the JPL DE-200 emphemeris. In the second, the phase center is taken
        to be an absolute coordinate value.

        The third example shows the use of selectvis and defineimage to setup a mosaic. In 
        the set data we have chosen 10 channels (for each spectral window) of data starting form 
        channel 3. We also have selected spectral windows 0 and 1. We have selected data from 
        fields 3 to 10. In the defineimage we decide to use the data to make a 
        multifrequency synthesis image. We center the image on the field 7 pointing.  

        The fourth example is use to clean regions where the user knows the
        sources are and ignore all the other regions. This is very efficient
        in large fields with few sources. Smaller outlier images are made and
        deconvolved around known sources rather than making a big image
        englobing all three fields. 


        Now here are some examples about defining cubes using different {	t mode}
        parameters.


        defining channels cubes use the channel as defined in the data

        im.defineimage(cellx=1000, mode='channel', nchan=100, start=10,
        step=1, spwid=range(0,10))


        now using frequency and overiding the rest frequency defined in
        the ms or if its not defined in the ms

        im.defineimage(cellx=1000, mode='frequency', nchan=100, start='1GHz',
        step='10kHz', restfrequency='1.421GHz')


        in case you have a frame with the frequency

        im.defineimage(cellx=1000, mode='frequency', nchan=100, start=['LSRK',
        '1GHz'], step='10kHz', restfrequency='1.421GHz')


        OR using measures

        freqstart=me.frequency('LSRK', '1GHz')
        im.defineimage(cellx=1000, mode='frequency', nchan=100,
        start=freqstart, step='10kHz', restfrequency='1.421GHz')


        similarly if you want to use  velocity to define your cube

        im.defineimage(cellx=1000, mode='velocity', nchan=100, start=['LSRK',
        '10km/s'], step='1m/s', restfrequency='1.421GHz')
        OR using measures
        velstart=me.radialvelocity('LSRK', '10km/s')
        im.defineimage(cellx=1000, mode='velocity', nchan=100, start=velstart,
        step='1m/s')


        Change mode to 'opticalvelocity' if your velocity values are using  optical definition


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_defineimage(self, *args, **kwargs)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Terminate the imager process

        Description
        	
        This is used to totally stop the {	t imager} process. It is a good idea
        to conserve memory use on your machine by stopping the process once
        you no longer need it.

        Example:
        	

        im.open('3C273XC1.MS')      
        im.makeimage(image='3C273XC1.dirty',type='corrected')
        im.done()


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_done(self)

    def drawmask(self, *args, **kwargs):
        """
        drawmask(self, image=string(""), mask=string(""), niter=0, npercycle=0, threshold=string("0 mJy")) -> record *

        Summary
        	Allows you do draw mask using the viewer

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution. 

        drawmask  is used to interactively draw  regions over a template image which you want to allow deconvolution to occur.


        Input Parameters:
        	image		 name of template image 
        	mask		 name of image to save mask in 
        	niter		 Total number of iteration to display in box; just for display or python packaging 0 
        	npercycle	 npercycle value to display in box; just for display or python packaging 0 
        	threshold	 threshold to display in box ; just for display or python packaging 0 mJy 
        	
        Example:
        	

        im.drawmask(image='mytemplate.image', mask='myregions.mask')
        im.clean(mask='myregions.mask', model='3C273XC1.clean.masked', niter=1000)



        Make mask image by drawing interactively over a given image 'mytemplate.image',   then image and clean the visibilties using it as the
        'clean regions'.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_drawmask(self, *args, **kwargs)

    def exprmask(self, *args, **kwargs):
        """
        exprmask(self, mask=string(""), expr=1.0) -> bool

        Summary
        	Construct a mask image from a LEL expression

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution. 

        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. boxmask does not enforce
        this requirement.

        This function allows Lattice Express Language (LEL) expressions to
        be used in defining a mask. See the documentation on 
        imagecalc for more details.


        Input Parameters:
        	mask		 name of mask image 
        	expr		 Value to set the mask to. Any scalar or LEL expression 1.0 
        	
        Example:
        	

        im.exprmask(mask='bigmask', expr='3C273XC1.clean>0.5')
        im.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)


        Makes the image bigmask, and then sets it to unity for all points in
        the region where 3C273XC1.clean is greater than 0.5Jy.
        Then cleans using it as the mask.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_exprmask(self, *args, **kwargs)

    def feather(self, *args, **kwargs):
        """
        feather(self, image=string(""), highres=string(""), lowres=string(""), lowpsf=string(""), effdishdiam=-1.0, 
            lowpassfiltersd=False, async=False) -> bool

        Summary
        	Feather together an interferometer and a single dish image
        in the Fourier plane

        Description
        	 
        Basically the 'imerg' algorithm of AIPS and SDE, or the 'feather'
        algorithm of MIRIAD, we regrid the total power (or low resolution)
        image onto the interferometer (or high resolution) image, Fourier
        transform both the interferometer and single dish images, down weight
        the Fourier transform of the interferometer image by 1.0 - FT(low res psf),
        add the weighted interferometer Fourier plane to the single dish Fourier
        plane, and transform back into the image plane.

        The tapering is by the transform of a point spread function. If lowpsf
        is specified, that image is used, otherwise the appropriate telescope
        beam is used. The point spread function for a single dish image may be
        calculated using makeimage. 

        {	t Advice:} Note that if you are feathering large images, you'd be advised to have
        the number of pixels along the X and Y axes to be composite numbers
        and  definitely not  prime numbers. In general FFTs work much faster on even
        and composite numbers. You may use subimage function of image
          tool to trim the number of pixels to something desirable.



        Input Parameters:
        	image		 Name of output feathered image 
        	highres		 Name of high resolution (interferometer) image 
        	lowres		 Name of low resolution (single dish) image 
        	lowpsf		 Name of optional low resolution point spread function 
        	effdishdiam	 Optional new SD dish diameter in m to use in feathering; can be smaller than true dish size -1.0 
        	lowpassfiltersd	 Reject the high spatial frequency of the SD image false 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.setvp(dovp=True, usedefaultvp=True)
        im.feather(image='feathered.image', highres='casa.vlaonly',
        lowres='casa.sd');

        In the above example its using the default beams and the observatory
        information is in the image header.

        But if you have a single dish image with a beam which is not defined
        in the casa database then the example below is a guide of how to do
        that, say you know the beam of the single dish as a gaussian.



        #create a beam pattern table using vpmanager
        include 'vpmanager.g'
        vpman=vpmanager();
        vpman.setpbgauss(telescope='OTHER', othertelescope='BONN',
        halfwidth='1arcmin', maxrad='20arcmin', reffreq='1.4GHz');
        vpman.saveastable('bonn.pb')
        vpman.done()

        ##....would have done  your usual imager setup (defineimage etc) then before feathering
        im.setvp(dovp=True, usedefaultvp=false, vptable='bonn.pb')
        im.feather(image='feathered.image', highres='casa.vlaonly',
        lowres='casa.sd');

        ###




        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_feather(self, *args, **kwargs)

    def filter(self, *args, **kwargs):
        """
        filter(self, type=string("gaussian"), bmaj=initialize_variant("1arcsec"), bmin=initialize_variant("1arcsec"), 
            bpa=initialize_variant("0deg"), async=False) -> bool

        Summary
        	Apply additional weighting by filtering (u-v taper)

        Description
        	
        Apply visibility tapering to emphasize certain scale structures.  The
        imaging tapers are applied to a Table column called IMAGING\_WEIGHT,
        which may be plotted using 
        tb and pl.
        plotweights. 
        In addition, this column
        may be accessed directly using either the table
        or ms modules. Note that the taper is multiplicative and
        so the weights must be calculated first using
        weight. The points are not flagged!

        Note that the scale size to be emphasized is given in the image plane
        as the parameters of the corresponding Gaussian. Note also use of this
        function provides an optimum detection for the given scale size, which
        is not the same as requiring that the resulting dirty beam have the
        specified Gaussian fit. The resultant fitted beam size will {m very
        roughly} be the quadratic sum of the original beam and the specified
        beam. If you wish to obtain a specified beam, then the best approach
        is to perform this calculation and check the value obtained using
        imager.fitpsf.



        Input Parameters:
        	type		 Type of filtering or u-v tapering gaussian 
        	bmaj		 Major axis of filter 1arcsec 
        	bmin		 Minor axis of filter 1arcsec 
        	bpa		 Position angle of filter 0deg 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.weight('uniform')
        im.filter(type='gaussian', bmaj='2.3arcsec', bmin='1.67arcsec',
        bpa='-34.5deg')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_filter(self, *args, **kwargs)

    def fitpsf(self, *args, **kwargs):
        """
        fitpsf(self, psf, async=False, _bmaj=_bmaj_fitpsf, _bmin=_bmin_fitpsf, _bpa=_bpa_fitpsf) -> bool

        Summary
        	Fit the point spread function, making psf image first if needed

        Description
        	
        This fits an elliptical Gaussian to the point spread function
        and returns the fitted beam parameters. If psf image is not specified
        then a psf is made and used. The values for the beam fit
        are saved internally and used whenever needed (for example in the functions restore or smooth) until invalidated. The values
        are invalidated by selectvis, defineimage or any tool function that changes
        the weights. Use the function summary to check if there is a valid fitted psf stored internally.
         


        Input Parameters:
        	psf		 Name of input psf 
        	async		 Run asynchronously in the background false 
        	

        Output Parameters:
        	_bmaj		 Major axis of beam 
        	_bmin		 Minor axis of beam 
        	_bpa		 Position angle of beam 
        	
        Example:
        	

        im.makeimage(type='psf', image='3C273XC1.psf')
        params=im.fitpsf('3C273XC1.psf')
        #This returns a python dict params here 
        print params['bmaj'].value, params['bmin'].value, params['bpa']
        im.restore(model='bla' , complist='', image='bla.restored' , residual='bla2.residual' )


        Or if one wants to generate a psf from the uv coverage and use that subsequently as in the  following example:


        - im.fitpsf(psf='')
        - im.restore(model='bla' , complist='', image='bla.restored' , residual='bla2.residual' )



        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_fitpsf(self, *args, **kwargs)

    def fixvis(self, *args, **kwargs):
        """
        fixvis(self, fields=initialize_vector(1, (int)-1), phasedirs=std::vector< string >(1, ""), refcode=string(""), 
            distances=initialize_vector(1, (double)0.0), datacolumn=string("all")) -> bool

        Summary
        	Performs visibility adjustments.

        Description
        	
             Corrects UVW coordinates and optionally the visibilities for various
             effects that can be calculated without fitting a model to the data.

             The effects include:
             egin{itemize}
               \item changing the phase tracking center(s),
               \item correcting for differential aberration,  (Not yet implemented)
               \item changing the equinox (i.e. B1950\_VLA to J2000 or APP, etc.) of the UVW coordinates,
               \item changing the projection, as in (-)NCP to SIN.  (Not yet implemented),
               \item refocusing.
             nd{itemize}
           

        Input Parameters:
        	fields		 Field IDs (numbered relative to 0) to operate on. Blank = all. -1 
        	phasedirs	 Phase tracking centers for each field in fields, in the same order. 
        	refcode		 Reference frame to use for the generated UVWs. WARNING: clean and the im tool ignore the reference frame claimed by the UVW column (it is often mislabelled as ITRF when it is really J2000) and instead assume the (u, v, w)s are in the same frame as the phase tracking center. calcuvw does not yet force the UVW column and field centers to use the same reference frame! Blank = use the phase tracking frame of vis. 
        	distances	 A list of distances (in m) for the fields listed in fields. 0 = infinity. 0.0 
        	datacolumn	 Which of DATA, MODEL\_DATA, and/or CORRECTED\_DATA to operate on. Default: 'all'. all 
        	
        Example:
        	
             
             im.open('3C273XC1.MS')
             im.fixvis()
             im.done()
             
           
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_fixvis(self, *args, **kwargs)

    def ft(self, *args, **kwargs):
        """
        ft(self, model=std::vector< string >(1, ""), complist=string(""), incremental=False, async=False) -> bool

        Summary
        	Fourier transform the specified model and componentlist

        Description
        	
        Fourier transform the specified model (and optionally componentlist) 
        and insert into the MODEL\_DATA column. The current contents of
        the MODEL\_DATA column are replaced unless incremental is set to
        T (in which case the results are added to the column).


        Input Parameters:
        	model		 Name of image 
        	complist	 Name of component list 
        	incremental	 Add to the existing MODEL\_DATA column? false 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

        im.ft(model='3C273XC1.nnls.model')
        im.ft(model='3C273XC1.another.model', incremental=True)


        Fourier transforms the model in the image 3C273XC1.nnls.model
        and then adds the visibility due to 3C273XC1.another.model

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_ft(self, *args, **kwargs)

    def getweightgrid(self, *args, **kwargs):
        """
        getweightgrid(self, type=string("imaging"), wgtimages=std::vector< string >(1, "")) -> variant *

        Summary
        	get the requested weight grids

        Description
        	

        This is a utility function when running multi imager processes in parallel on subsection of an ms/data independently
        One would wish to weight the dirty image before averaging or set the imaging weight density (when using unform or
        Brigg's style weighting) to account for all the data being used. This is {f NOT} for the general user but for people who 
        are parallelizing at the scripting level.

        {f imaging}: will return a the weight griddensity \
         
        {f ftweight}: will put the FT-machine weight images in the names given in wgtimage parameters..these may be needed to average residual images from different processes running seperately on different section of the data.




        Input Parameters:
        	type		 Type of weight requested (imaging, ftweight) imaging imaging ftweight 
        	wgtimages	 names of weightimages to save 
        	
        Example:
        	

        wght=im.getweightgrid('imaging')
        wght2=im2.getweightgrid('imaging')
        wght=wght+wght2

        im.setweightgrid(weight=wght, type='imaging')



        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_getweightgrid(self, *args, **kwargs)

    def linearmosaic(self, *args, **kwargs):
        """
        linearmosaic(self, images=std::vector< string >(1, ""), mosaic=string(""), fluxscale=string(""), sensitivity=string(""), 
            fieldids=initialize_vector(1, (int)0), usedefaultvp=True, 
            vptable=string(""), async=False) -> bool

        Summary
        	Make a linear mosaic of several images

        Description
        	 
        Make a linear mosaic of several images.
        Currently, the pointing center is not specified in the image, so
        we specify the pointing center in terms of the row numbers of the FIELD subtable.


        Input Parameters:
        	images		 Input images to be mosaiced 
        	mosaic		 Output mosaic image 
        	fluxscale	 Fluxscale image 
        	sensitivity	 Sensitivity image 
        	fieldids	 List of field ids that correspond each of the images,used to center the PB of each image. (0-based list) 0 
        	usedefaultvp	 Use the default vp type? true 
        	vptable		 Voltage pattern table from the vpmanager for detailed specification 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.linearmosaic(images=['orion.1.cln', 'orion.2.cln', 'orion.4.cln'], mosaic='orion.linmos',
        fluxscale='orion.linmos.fluxscale', fieldid=[1,2,4]);


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_linearmosaic(self, *args, **kwargs)

    def make(self, *args, **kwargs):
        """
        make(self, image=string(""), async=False) -> bool

        Summary
        	Make an empty (i.e. blank) image

        Description
        	
        Make an empty image using the current image parameters. Often this is
        unnecessary, but you will typically need to use this if you wish to
        deconvolve a set of images. The steps are to make the empty images
        that you require to be deconvolved, and then pass them into clean as a
        vector of strings.


        Input Parameters:
        	image		 name of output image 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.defineimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
        nchan=1, stokes='IV', phasecenter=me.direction('mars'));
        im.make('mars.moving');
        im.defineimage(nx=1024,ny=1024, cellx='30marcsec',celly='30marcsec', 
        nchan=1, stokes='IV', 
        phasecenter=me.direction('J2000', '12:23:48.7', '-15:56:32.9')
        im.make('mars.fixed');
        im.clean(algorithm='mf', model=['mars.moving', 'mars.fixed'],
        image=['mars.moving.restored', 'mars.fixed.restored'])


        This makes two empty images, one moving with mars and one fixed
        in J2000, and then deconvolves the two jointly using clean.
        Finally the images are restored.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_make(self, *args, **kwargs)

    def predictcomp(self, *args, **kwargs):
        """
        predictcomp(self, objname=string(""), standard=string(""), epoch=initialize_variant("55555.0d"), freqs=initialize_vector(1,(double)1.0e11), 
            pfx=string("predictcomp")) -> string

        Summary
        	Make a component list for a known object

        Description
        	
        Make a component list for an object recognized by standard, one of setjy's
        flux density standards.


        Input Parameters:
        	objname		 Name of the object 
        	standard	 Name of the flux standard 
        	epoch		 Time to use, as an epoch measure, e.g. me.epoch('UTC', '55555d'), for Solar System objects 55555.0d epoch measure 
        	freqs		 The frequencies to use, in Hz 1.0e11 
        	pfx		 Prefix for the name of the component list predictcomp 
        	
        Example:
        	

        clname = im.predictcomp('Ceres', 'Butler-JPL-Horizons 2010',
                                '2012-02-14/13:33:00', [3.45e11, 6.90e11], 'vd_')

        This writes a component 'list' named vd_spw0_Ceres_345GHz55971.6d.cl to disk
        containing a uniform disk component for Ceres as it is expected to appear at
        345 and 690 GHz at 2012-02-14/13:33:00 UTC, and returns the name of the
        component list.  Returns '' on error.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_predictcomp(self, *args, **kwargs)

    def makeimage(self, *args, **kwargs):
        """
        makeimage(self, type=string("observed"), image=string(""), compleximage=string(""), verbose=True, 
            async=False) -> bool

        Summary
        	Calculate images by gridding, etc.

        Description
        	
        This tool function actually does gridding (and Fourier inversion if
        needed) of visibility data to make an image. It allows calculation of
        various types of image:
        egin{description}
        \item[observed] Make the dirty image from the DATA column ({m default})
        \item[model] Make the dirty image from the MODEL\_DATA column
        \item[corrected] Make the dirty image from the CORRECTED\_DATA column
        \item[residual] Make the dirty image from the difference of the
        CORRECTED\_DATA and MODEL\_DATA columns
        \item[psf] Make the point spread function
        \item[singledish] Make a single dish image
        \item[coverage] Make a single dish coverage image
        \item[holography] Make a complex holography image
        \item[pb] Make the primary beam as defined by setvp
        nd{description}

        Note the full {	t imager} equation is not used and so, for example, the
        primary beam correction is not performed. Use
        restore to get a residual image
        using the full {	t imager} equation where primary beam correction is
        performed.

        A position shift can be applied when specifying the image parameters
        with defineimage. If a shift is specified then
        the uvw coordinates are reprojected prior to gridding, and a phase
        rotation is applied. If the image is a PSF then no phase shift is
        applied but the uvw are recomputed. To see the effects of the uvw
        reprojected, you can use the
        plotuv function.

        If desired, the full complex image (before conversion to stokes
        I,Q,U,V) may be retained. Note that the image
        tool cannot load a complex image directly. Instead, use the
        imagecalc constructor 
        to take {m e.g.}  the real and imaginary parts of the image.

        For making single dish and holography images, the data are convolved onto the
        grid using a one of a number of options:
        egin{description}
        \item[gridfunction='SF'] Circularly symmetric prolate spheroidal wavefunction. 
        This is always the same function in pixels.  To get this to match to
        the antenna primary beam, the optimum cellsize to use in constructing
        the image is the antenna primary beam half-width-half-maximum times
        1.20192.
        \item[gridfunction='BOX'] Nearest neighbor gridding.
        \item[gridfunction='PB'] The telescope primary beam is used as the
        convolution function. This function is the same in arcseconds,
        independent of the cellsize. This choice is optimum in the least
        squares sense. To override the default choice of telescope primary beam
        for a given telescope, use the function
        setvp. Usually the default will be acceptable.
        nd{description}

        To make a reasonable approximation to the sky, one should divide
        the type='singledish' image by the type='coverage' image, thresholding
        at some level. For example:

        egin{verbatim}

        ia.open('scanweight'); 
         ia.statistics(s);	
        threshold = s.max / 10.0;
        #
        ia.imagecalc('sdimage',
        	      pixels=spaste('scanimage[scanweight>', threshold,
        			    ']/scanweight[scanweight>', threshold, ']'))
        ###ia.view(raster=True, axislabels=True);
        nd{verbatim}




        Input Parameters:
        	type		 Type of output image observed 
        	image		 Name of output image 
        	compleximage	 Name of output complex image 
        	verbose		 Report things like the center frequency to the logger true 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.ft(model='3C273XC1.model', complist='3C273XC1.complist');
        im.makeimage(type='residual', image='3C273XC1.residual')
        im.makeimage(type='psf', image='3C273XC1.psf')


        Fill in the MODEL\_DATA column from Fourier transforming the model and
        the componentlist.  Make the residual image and write it to
        3C273XC1.residual. 

        Example:
        	

        im.setvp(dovp=T, usedefaultvp=T, telescope='GBT');
        im.makeimage(type='pb', image='gbt.pb')



        In the above we may want to see what the primary beam we are using
        look like. May also be useful to deconvolve single dish images in the
        deconvolver tool.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_makeimage(self, *args, **kwargs)

    def makemodelfromsd(self, *args, **kwargs):
        """
        makemodelfromsd(self, sdimage=string(""), modelimage=string(""), sdpsf=string(""), maskimage=string("")) -> bool

        Summary
        	Make an initial model image from a
            Single Dish image

        Description
        	
        This functions use an image from a single dish and make a model
        (clean component) image out of it. This allows one to use this as the
        starting model in a deconvoltion  function e.g
        clean or mem
        This provides an alternative to
        feather.
        The difference between the two is that in {	t feather} the
        interferometer image is deconvolved first and the single dish image is 
        put in at the end. Whereas if one starts with a model from the single
        dish image it will give a different starting point for the deconvolving
        algorithm to interpolate the missing short baseline. 

        The function setsdoptions may be used to set
        a factor by which to scale the SD image, if necessary.

        The {	t sdpsf} parameter (optional) should be used if an external PSF image of the 
        single dish is needed to calculate the beam parameters of the primary
        beam of the dish. This is usually needed if the dish image is from a
        non standard telescope or the beam is not in the {	t CASA} system.

        The {	t mask} is a mask image that may be needed to be used for
        clean.  This is usually the case when the dish image does not fully
        cover the field defined by defineimage.



        Input Parameters:
        	sdimage		 Single Dish image 
        	modelimage	 Name of output image to be used as model 
        	sdpsf		 PSF of Single Dish if needed 
        	maskimage	 mask image 
        	
        Example:
        	


        im.open('orion\_only.ms')
        im.selectvis(field=range(10), spw=range(2))
        im.defineimage(nx=1000, cellx='1arcsec', , phasecenter=4, spwid=[0,1])
        im.setvp(dovp=T)
        im.setoptions(ftmachine='mosaic')
        im.setscales(nscales=3)
        im.setsdoptions(scale=0.9);
        im.makemodelfromsd(sdimage='orion\_gbt.im', modelimage='orion\_model', maskimage='orion.mask')
        im.clean(algorithm='mfmultiscale', model='orion\_model',
        residual='orion.residual', image='orion.restored', gain=0.2, niter=500, mask='orion.mask')


        In the above example we are making a mosaic with the fields 0 to 9. A
        single dish image {	t orion\_gbt.im} is used scaled down by a factor 0.9 to
        make the initial model that is passed to multi-scale clean.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_makemodelfromsd(self, *args, **kwargs)

    def mask(self, *args, **kwargs):
        """
        mask(self, image=string(""), mask=string(""), threshold=initialize_variant("0.0Jy"), async=False) -> bool

        Summary
        	Construct a mask image by thresholding an image

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used
        in {	t imager} to control the region selected in a deconvolution.
        One makes a mask image by clipping the I part of the restored image
        (this function) or via the boxmask,
        regionmask, and 
        exprmask functions.  In this
        function, all points greater than the threshold are set to unity. The
        mask is the same in I,Q,U, and V. Note that
        exprmask is the most powerful
        method for making mask images.

        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle.

        Note that if you do use a mask for the Clark or Hogbom Clean, it must
        cover only a quarter of the image. It is particularly important to
        check this when creating an image using a threshold. If it extends
        further, the easiest fix is to use
        getchunk and
        getchunk to set parts of it to zero.


        Input Parameters:
        	image		 name of template image 
        	mask		 name of mask image 
        	threshold	 threshold for mask 0.0Jy 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.mask( image='bigimage', mask='bigmask',threshold='0.07Jy')
        im.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)


        Makes the image bigmask, and then sets it to unity
        for all points where the Stokes I in bigimage is
        greater than 0.07. Then clean using it as the mask.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_mask(self, *args, **kwargs)

    def mem(self, *args, **kwargs):
        """
        mem(self, algorithm=string("entropy"), niter=20, sigma=initialize_variant("0.001Jy"), targetflux=initialize_variant("1.0Jy"), 
            constrainflux=False, displayprogress=False, 
            model=std::vector< string >(1, ""), keepfixed=initialize_vector(1, (bool)false), 
            complist=string(""), prior=std::vector< string >(1, ""), mask=std::vector< string >(1, ""), 
            image=std::vector< string >(1, ""), residual=std::vector< string >(1, ""), 
            async=False) -> bool

        Summary
        	Calculate a deconvolved image with selected mem (maximum entropy) algorithm

        Description
        	
        Makes a mem image using either the Cornwell-Evans maximum entropy or
        maximum emptiness algorithms, using the single field or multi-field
        contexts. The maximum entropy algorithm is the default. The mem is performed
        on the residual image calculated from the visibility data currently
        selected. Hence the first step performed in mem is to transform the
        current model or models (optionally including a componentlist) to fill
        in the MODEL\_DATA column, and then inverse transform the residual
        visibilities to get a residual image. This residual image is then
        deconvolved using the corresponding point spread function. This means that
        the initial model is used as the starting point for the
        deconvolution. Thus if you want to restart a mem, simply set the
        model to the model that was previously produced by clean.

        Mask images are used to constrain the region that is to be
        deconvolved. To make mask images, use either
        boxmask (to define a mask via the
        corner locations blc and trc) or mask (to
        define a mask via thresholding an existing image). The default mask is
        the inner quarter of the image.

        The MEM deconvolution only operates on one Stokes parameter at a time.
        Joint MEM deconvolution for multiple Stokes parameters will be
        implemented in the future. 

        Some reference regarding MEM :
        Cornwell and Evans,
        Astronomy and Astrophysics (ISSN 0004-6361), vol. 143, no. 1, Feb. 1985,
                            p. 77-83.

        Narayan and  Nityananda,
        Annual review of astronomy and astrophysics. Volume 24 (A87-26730
        10-90). Palo Alto, CA, Annual Reviews, Inc., 1986, p. 127-170.

        The mem algorithms possible are:
        egin{description}
        \item[Cornwell-Evans Maximum Entropy (entropy)] The classic 'vm' or 'vtess' 
        deconvolution algorithm.
        \item[Cornwell-Evans Maximum Emptiness (emptiness)] The historic, but 
        largely undocumented, modification to the Cornwell-Evans algorithm
        which seeks a model image which is consistent with the data and
        simultaneously minimizes the number of pixels with no emission
        (meaning 'with pixel values below the noise level').
        \item[Multi-field Maximum Entropy (mfentropy)] Deconvolution is split
        into minor and major cycles. For each field, the MEM analog of a Clark
        Clean minor cycle is performed. In the major cycle, the emission thus
        modelled is subtracted either from the original visibilities (for
        multiple fields) or using a convolution (for only one field). The
        latter is much faster.
        \item[Multi-field Maximum Emptiness (mfemptiness)] Just like {	t mfentropy},
        but with emptiness.
        nd{description}

        The multi-field mem ({	t mfentropy} or {	t mfemptiness}) should be
        used if either of two conditions hold:
        egin{enumerate}
        \item Multiple fields are to be deconvolved simultaneously {f OR}
        \item Primary beam correction is enabled. In this case, a
        mosaiced mem is performed.
        nd{enumerate}

        Note that for the single pointing algorithms, only a quarter of the
        image may be deconvolved. If no mask is set, then the deconvolved
        region defaults to the inner quarter. If a mask larger than a quarter
        of the image is set, then only the quarter starting at the bottom left
        corner is used.  However, for the multi-field imaging, the entire
        field may be imaged because the major cycles either do an exact
        subtraction from the visibilities or because PSF extent is more than
        twice the extent of the primary beam support.

        Before {	t mem} can be run, you must run {	t selectvis} and {	t defineimage}.
        Before {	t mem} can be run with a multi-field algorithm, you should run
        {	t setvp}.  You may want to run {	t setmfcontrol} before running {	t mem}
        with a multi-field algorithm, though the default control values
        may be acceptable. 



        Input Parameters:
        	algorithm	 Algorithm to use entropy emptiness mfentropy mfemptiness entropy entropy 
        	niter		 Number of Iterations 20 
        	sigma		 Image sigma to try to achieve 0.001Jy 
        	targetflux	 Target flux for final image 1.0Jy 
        	constrainflux	 Constrain image to match target flux? else targetflux used only to initialize model false 
        	displayprogress	 Display the progress of the cleaning? false 
        	model		 Names of model images 
        	keepfixed	 Keep model fixed false 
        	complist	 Name of component list 
        	prior		 Names of mem prior images 
        	mask		 Names of mask images (0=\>no emission, 1=\>emission permitted 
        	image		 Names of restored images 
        	residual	 Names of residual images 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

        im.mem(model='3C273XC1.mem.model',
        mask='3C283XC1.mask', niter=40, sigma='0.001Jy')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_mem(self, *args, **kwargs)

    def nnls(self, *args, **kwargs):
        """
        nnls(self, model=std::vector< string >(1, ""), keepfixed=initialize_vector(1, (bool)false), 
            complist=string(""), niter=0, tolerance=1e-06, fluxmask=std::vector< string >(1, ""), 
            datamask=std::vector< string >(1, ""), image=std::vector< string >(1, ""), 
            residual=std::vector< string >(1, ""), async=False) -> bool

        Summary
        	Calculate a deconvolved image using the 
        NNLS algorithm

        Description
        	 

        Solve for the model brightness using the Briggs' Non-Negative Least
        Squares algorithm. Since NNLS works only on the $I$ image, the $I$
        pixels in the current image is set to zero where the fluxmask is $\> 0.0$,
        then NNLS is used to estimate the $I$-pixels for that region.
        The deconvolution is performed on the residual image calculated from
        the visibility data currently selected. Hence the first step performed
        in clean is to transform the current model to fill in the MODEL\_DATA
        column, and then inverse transform the residual visibilities to get a
        residual image. This residual image is then deconvolved using the
        corresponding point spread function.

        Some other points to remember are that rather than explicit boxes,
        mask images are used to constrain the region that is to be
        deconvolved.  For NNLS, there are two masks, the fluxmask specifying
        the region within which flux is allowed, and the datamask specifying
        the region of the dirty image to be used as constraints. Typically the
        datamask will be somewhat larger than the fluxmask. On a large
        machine, a practical limit to both will be about 5000-6000
        pixels. Hence NNLS is only useful for compact tools.  (For more
        details, see the \htmladdnormallink{Briggs thesis}{riggsURL}).  To
        make mask images, use either boxmask (to
        define a mask via the corner locations blc and trc) or
        mask (to define a mask via
        thresholding an existing image).

        On the canonical ipspp\ machine with 64MBytes of physical memory,
        you should try to keep the product of the pixels in the fluxmask
        and the datamask below about 5-10 million. Otherwise the 
        solution phase will swap badly.


        Input Parameters:
        	model		 Name of image 
        	keepfixed	 Keep model fixed false 
        	complist	 Name of component list 
        	niter		 Number of Iterations, set to zero for no NNLS 0 
        	tolerance	 Tolerance for solution 1e-06 
        	fluxmask	 Name of mask for allowed flux 
        	datamask	 Name of mask for constraint pixels in dirty image 
        	image		 Names of restored images 
        	residual	 Names of restored images 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.nnls(image='3C273XC1.nnls.image', model='3C273XC1.nnls.model',
        fluxmask='3C283XC1.fluxmask', datamask='3C273XC1.datamask', niter=1000,
        tolerance=0.00001)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_nnls(self, *args, **kwargs)

    def open(self, *args, **kwargs):
        """
        open(self, thems=string(""), compress=False, usescratch=False) -> bool

        Summary
        	Open a new MeasurementSet, for processing, closing current MeasurementSet

        Description
        	
        Close the current MeasurementSet and open a new MeasurementSet
        instead. The current state of {	t imager} is retained, except for
        the data selection.


        Input Parameters:
        	thems		 New MeasurementSet to be processed 
        	compress	 Compress calibration columns? false 
        	usescratch	 If true: Imager will use corrected data column and make scratch columns of they donot exist false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_open(self, *args, **kwargs)

    def pb(self, *args, **kwargs):
        """
        pb(self, inimage=string(""), outimage=string(""), incomps=string(""), outcomps=string(""), 
            operation=string("apply"), pointingcenter=initialize_variant(""), parangle=initialize_variant("0.0deg"), 
            pborvp=string("pb"), async=False) -> bool

        Summary
        	Applies or corrects for a primary beam

        Description
        	 

        Multiply ({	t operation='apply'}) or divide ({	t operation='correct'})
        by the primary beam function.  The primary beam can be applied to images and/or 
        Componentlists.  

        If {	t pointingcenter==false} then you must specify {	t inimage}
        and the pointing center is taken from its reference direction.
        Otherwise, {	t pointingcenter} must be a Direction measure.
        It cannot take on the value {	t True}.

        The applied primary beam function is deterimed as follows.  If you used
        function Imager.setvp to set an external
        voltage pattern table, then this is where the applied primary beam will
        come from (regardless of whether you set {	t inimage} or not).  If you
        did not run this function, then you must supply argument {	t inimage}. 
        The telescope name embedded in its Coordinate System will be used to
        determine the primary beam function. 



        Input Parameters:
        	inimage		 Input image to apply beam to 
        	outimage	 Output image after beam is applied 
        	incomps		 Input Componentlist table name 
        	outcomps	 Output Componentlist table name 
        	operation	 Operation correct apply 
        	pointingcenter	 Pointing center for primary beam application: default N.Pole 
        	parangle	 Parallactic angle for calculation 0.0deg 
        	pborvp		 Primary Beam or Voltage Pattern vb pb 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        # make a flat image
        im.make('flat.image');
        ia.open('flat.image');
        arr=ia.getchunk();
        arr[0:len(arr), 0:len(arr[0])] = 1.0;
        ia.putchunk(arr);
        ia.done()
        arr = false;
        #
        # as we are using 'pointingcenter=F', it defaults to the image center
        im.pb(inimage='flat.image', outimage='pb.image', pointingcenter=F)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_pb(self, *args, **kwargs)

    def plotsummary(self):
        """
        plotsummary(self) -> bool

        Summary
        	Plot a summary of field and spectral window  ids

        Description
        	
        Performs a simple plot of the field and spectral window IDs
        versus time (after sorting).

        Example:
        	

        m = fitstoms('3C273XC1.ms', '3C273XC1.fits'); m.close()
        im.open('3C273XC1.ms')
        im.plotsummary()


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_plotsummary(self)

    def plotuv(self, rotate=False):
        """
        plotuv(self, rotate=False) -> bool

        Summary
        	Plot the uv coverage

        Description
        	
        Performs a simple plot of the uv coverage of all selected data.

        Optionally, plotuv will rotate the uvw coordinates to the
        specified phase center (set via defineimage).


        Input Parameters:
        	rotate		 Rotate uvw coordinates to specified phase center? false 
        	
        Example:
        	

        im.open('3C273XC1.ms')
        im.plotuv(false)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_plotuv(self, rotate)

    def plotvis(self, *args, **kwargs):
        """
        plotvis(self, type=string("all"), increment=1) -> bool

        Summary
        	Plot the visibility amplitudes as a function of u-v radius (also, see visplot tool

        Description
        	
        Performs a simple plot of the visibility amplitudes of all selected data.


        Input Parameters:
        	type		 Type of plot: can contain all, observed, corrected, model, residual all observed corrected model residual all 
        	increment	 Increment in points to plot 1 
        	
        Example:
        	


        im.open('3C273XC1.ms')
        im.plotvis(increment=10)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_plotvis(self, *args, **kwargs)

    def plotweights(self, gridded=False, increment=1):
        """
        plotweights(self, gridded=False, increment=1) -> bool

        Summary
        	Plot the visibility weights as a function of u-v radius

        Description
        	
            Performs a plot of the visibility weights of all selected data (stored in
            the IMAGING\_WEIGHT column of the MeasurementSet).
            The plot can be of the gridded weights (type='gridded') or
            ungridded.
            
          

        Input Parameters:
        	gridded		 Do gridded plot? false 
        	increment	 Increment in points to plot 1 
        	
        Example:
        	
            
            im.open('3C273XC1.ms')
            im.defineimage(cellx='0.7arcsec', celly='0.7arcsec')
            im.weight('briggs')
            im.plotweights(gridded=True,increment=10)
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_plotweights(self, gridded, increment)

    def regionmask(self, *args, **kwargs):
        """
        regionmask(self, mask=string(""), region=initialize_record(""), boxes=initialize_variant(""), circles=initialize_variant(""), 
            value=1.0) -> bool

        Summary
        	Construct a mask image from a region

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution. 

        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value is discouraged but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. {	t regionmask} does not enforce
        this requirement. 

        The function regionmask also allows multiple regions to be used. A record of the regions can be made as in the example below. 

        Regions can be made in many different ways using the
        regionmanager functions. An example
        using wbox function is given
        below. The default regionmanager tool 'rg' can be used for cases the user want to have flexibility in manipulating regions. The {	t region} parameter takes a record that comes from the regionmanager output.
        The parameter boxes allow the user to sent in a list of 4 elements numbers representing blc's and trc's 

        If both the parameters, {	t regions} and {	t boxes} are used the a union is done with the two sets of region thus defined.



         



        Input Parameters:
        	mask		 name of mask image 
        	region		 Region record usually from regionmanager unset 
        	boxes		 list of 4 elements lists e.g [[xblc1, yblc1, xtrc1, ytrc1], [[xblc2, yblc2, xtrc2, ytrc2]] 
        	circles		 list of 3 elements lists e.g [[rad0, xcen0, ycen0], [rad1,xcen1, ycen1], .....] 
        	value		 Value to set the mask to 1.0 
        	
        Example:
        	


        Makes a mask  then cleans using it.

        im.open('test.ms')
        im.selectvis(field=0, spw=0)
        im.defineimage(nx=400, cellx='0.001arcsec', phasecenter=0)
        a=[100.0, 100.0, 200, 200.0]
        b=[50, 50, 80, 80]
        im.regionmask(mask='bigmask', boxes=[a,b])
        im.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)

        Another example using rg.wbox function: 
        ia.open('dirty')
        cs = ia.coordsys()
        rg.setcoordinates(cs.record())
        r1 = dg.wbox(blc=['173pix', '347pix'], trc=['183pix', '370pix'])
        im.regionmask(mask='bigmask',region=r1)

        Or using a dict of regions:

        r2=rg.wbox(blc=['180pix', '344pix'], trc=['191pix', '369pix'])
        r3=rg.wbox(blc=['189pix', '341pix'], trc=['204pix', '364pix'])
        regs={'reg1'':r1, 'reg2':r2, 'reg3':r3}
        rec=rg.makeunion(regs)
        im.regionmask(mask='bigmask',region=rec)

        If quantities are to be used to define regions the following is a an example

        im.regionmask(mask='joetest',boxes=['15:23:32.902','+05.19.32.089','15:22:28.631','+05.28.52.474'])





        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_regionmask(self, *args, **kwargs)

    def regiontoimagemask(self, *args, **kwargs):
        """
        regiontoimagemask(self, mask=string(""), region=initialize_record(""), boxes=initialize_variant(""), circles=initialize_variant(""), 
            value=1.0) -> bool

        Summary
        	union a mask image with various regions 

        Description
        	


        This function is very similar to regionmask function
        except that the mask image has to be existant already and this is an
        independent helper function (i.e does not care about the state of the imager tool... e.g does not need imager to have an
        attached ms).



         



        Input Parameters:
        	mask		 name of mask image 
        	region		 Region record usually from regionmanager unset 
        	boxes		 list of 4 elements lists e.g [[xblc1, yblc1, xtrc1, ytrc1], [[xblc2, yblc2, xtrc2, ytrc2]] 
        	circles		 list of 3 elements lists e.g [[rad0, xcen0, ycen0], [rad1,xcen1, ycen1], .....] 
        	value		 Value to set the mask to 1.0 
        	
        Example:
        	


        Makes a mask  then cleans using it.

        a=[100.0, 100.0, 200, 200.0]
        b=[50, 50, 80, 80]
        im.regiontoimagemask(mask='bigmask', boxes=[a,b])
        im.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)

        Another example using rg.wbox function: 
        ia.open('dirty')
        cs = ia.coordsys()
        rg.setcoordinates(cs.record())
        r1 = dg.wbox(blc=['173pix', '347pix'], trc=['183pix', '370pix'])
        im.regionmask(mask='bigmask',region=r1)

        Or using a dict of regions:

        r2=rg.wbox(blc=['180pix', '344pix'], trc=['191pix', '369pix'])
        r3=rg.wbox(blc=['189pix', '341pix'], trc=['204pix', '364pix'])
        regs={'reg1'':r1, 'reg2':r2, 'reg3':r3}
        rec=rg.makeunion(regs)
        im.regionmask(mask='bigmask',region=rec)

        If quantities are to be used to define regions the following is a an example

        im.regionmask(mask='joetest',boxes=['15:23:32.902','+05.19.32.089','15:22:28.631','+05.28.52.474'])





        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_regiontoimagemask(self, *args, **kwargs)

    def residual(self, *args, **kwargs):
        """
        residual(self, model=std::vector< string >(1, ""), complist=string(""), image=std::vector< string >(1, ""), 
            async=False) -> bool

        Summary
        	Calculate the residual image with respect to current model and component list

        Description
        	
        Calculate the residuals corresponding to the model and
        componentlist. {m Note that the model visibilities are updated}.


        Input Parameters:
        	model		 Names of input models 
        	complist	 Name of component list 
        	image		 Names of output residual images 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        - im.residual(model='3C273XC1.clean', complist='3C273XC1.cl',
        image='3C273XC1.clean.residual')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_residual(self, *args, **kwargs)

    def restore(self, *args, **kwargs):
        """
        restore(self, model=std::vector< string >(1, ""), complist=string(""), image=std::vector< string >(1, ""), 
            residual=std::vector< string >(1, ""), async=False) -> bool

        Summary
        	Calculate the restored image with restored model, component list, and  residuals

        Description
        	
        Restore the residuals to a smoothed version of the model. The model
        images are convolved with the specified Gaussian beam and then the
        residual images are added.  {m Note that the model visibilities are
        updated and thus reflect the model and componentlist that was
        used.}. Use setbeam to set the beam
        parameters.


        Input Parameters:
        	model		 Names of input model 
        	complist	 Name of component list 
        	image		 Names of output restored images 
        	residual	 Names of residual images 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        - im.setbeam(bmaj='2.0arcsec', bmin='2.0arcsec')
        - im.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_restore(self, *args, **kwargs)

    def updateresidual(self, *args, **kwargs):
        """
        updateresidual(self, model=std::vector< string >(1, ""), complist=string(""), image=std::vector< string >(1, ""), 
            residual=std::vector< string >(1, "")) -> bool

        Summary
        	Calculate the residual and restored images with new modified model, component list,

        Description
        	
        This function is for efficiency and speed purpose only. Same as restore
        It is to be used after you have used clean or mem ...but you wish to tweak the model image, say by clipping unwanted components and it will avoid unnecessary recalculating of psf but will do a proper prediction of the new model visibilities and recalculate residual and restored images.




        Input Parameters:
        	model		 Names of input model 
        	complist	 Name of component list 
        	image		 Names of output restored images 
        	residual	 Names of residual images 
        	
        Example:
        	

        - im.setbeam(bmaj='2.0arcsec', bmin='2.0arcsec')
        - im.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_updateresidual(self, *args, **kwargs)

    def sensitivity(self, *args, **kwargs):
        """
        sensitivity(self, async=False, _pointsource=_pointsource_sensitivity, _relative=_relative_sensitivity, 
            _sumweights=_sumweights_sensitivity, _senrec=_senrec_sensitivity) -> bool

        Summary
        	Calculate rms  sensitivity

        Description
        	

        NB: The implementation in this function will be removed for CASA v4.5.
        We now recommend that the im.apparentsens() function be used instead
        of this one, especially if their weights are initialized and
        calibrated.

        Calculate the point source sensitivity for the selected data, both
        absolutely and relatively (to that for natural weighting).

        To do the calculation, we use the imaging weights (in the 
        column called IMAGING\_WEIGHT) as calculated from the WEIGHT column,
        and an estimate of the effective net bandwidth and integration time.
        The calculation therefore includes all the effects
        of weight and 
        filter.

        The output is an array with mixed elements.  Counting from zero, the
        second element (out[1]) is the net sensitivity, third element is the
        ratio of the reduction in sensitivity due to the chosen weighting
        scheme.  This ratio is 1.0 for Natural weight and greater than one for
        all other weighting schemes.  (NOTE: Further testing is required of
        this value and hence this is kept separate for now).

        The sensitivity calculations require Tsys and collecting area of
        the antenna. These quantities are not known from the MS.  The
        sensitivity is therefore returned in units of Jy m\^2/K.  Multiplying the
        second elements with the ration of the Tsys and effective antenna
        collecting area will give the sensitivity in Jy/beam units.

        The fourth elements of the return value is a record with the following
        keys: 'nbaselines', 'effectiveintegration', 'effectivebandwidth',
        'sumwt' and 'spwid'.  These can be used to get the number of baselines
        used, effective integration time (in sec), the effective bandwidth (in
        Hz), the sum of weights and the absolute spectral window IDs used.



        Input Parameters:
        	async		 Run asynchronously in the background false 
        	

        Output Parameters:
        	_pointsource	 Calculated point source sensitivity (Jy m\^2 / (K beam)) 
        	_relative	 Calculated relative sensitivity 
        	_sumweights	 Calculated sum of weights 
        	_senrec		 Record per SPW per chan sensitivity calculations 
        	
        Example:
        	

        a=im.sensitivity(false);
        print 'Sensitivity =', a[1];
        print 'Relative to Natural Weighting = ', a[2];


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_sensitivity(self, *args, **kwargs)

    def apparentsens(self, *args, **kwargs):
        """
        apparentsens(self, async=False, _pointsource=_pointsource_apparentsens, _relative=_relative_apparentsens) -> bool

        Summary
        	Calculate rms sensitivity directly from weights

        Description
        	

        This function calculates the point source sensitivity for the data
        selected by im.selectvis(...), and according to the imaging weighting
        parameters specified in im.weight(...) and im.defineimage(...).  The
        calculation is performed solely using the weight information stored in
        the MS WEIGHT column (WEIGHT_SPECTRUM tbd), and as adjusted by the net
        imaging weighting function (natural, uniform, robust, taper, etc.).
        Therefore, it is assumed that the MS WEIGHTs have been properly
        initialized and calibrated along with the visibility data.  As long as
        the WEIGHTs are in the inverse square units of the visibilities (i.e.,
        inverse variance weights), the calculation should yield the real
        theoretical imaging sensitivity for data at any stage of the
        calibration (though data at early and intermediate stages of
        calibration may not be sufficiently coherent for imaging at high--or
        even modest--fidelity).

        Two values are reported in the logger and returned (see example
        below). First, the apparent sensitivity (in the units implied by the
        WEIGHTs' units), for the specified imaging weighting scheme.  Second,
        a unitless factor describing the ratio of the apparent sensitivity to
        that obtained with pure 'natural' weighting (the nominal peak
        sensitivity).  When 'natural' weighting is selected, this ratio factor
        will be 1.0; all other weighting choices will yield an apparent
        sensitivity ratio greater than 1.0.

        Currently, this function reports only the continuum sensitivity for
        the selected data, and in particular, for the aggregate bandwidth
        indicated by the spectral window selection.  The calculation further
        assumes that the visibility samples are each entirely independent
        (i.e., no redundant samples such as would occur for overlapping
        spectral windows).

        A future version of this function will support reporting a sensitivity
        spectrum for the spectral line case (including support for
        WEIGHT_SPECTRUM).  For now, spectral line sensitivity may be
        reasonably estimated by dividing the reported sensitivity by the
        square root of the fractional bandwidth of a single image channel, or
        by selecting a bandwidth matching the width of a single image channel.




        Input Parameters:
        	async		 Run asynchronously in the background false 
        	

        Output Parameters:
        	_pointsource	 Calculated apparent point source sensitivity (in units implied by the MS weights) 
        	_relative	 Ratio of apparent sensitivity relative to natural weighting 
        	
        Example:
        	

        # open and set up selection and image plane parameters
        im.open('mydata.ms')
        im.selectvis(field='2',spw='0')
        im.defineimage(mode='mfs',spw=0,stokes='I',cellx='15arcsec',celly='15arcsec',nx=256,ny=256)

        # report natural weighting sensitivity
        im.weight(type='natural')
        nat=im.apparentsens();
        print 'Natural Sensitivity =', nat[1];
        print 'Relative to Natural Weighting = ', nat[2];

        # switch to uniform weighting
        im.weight(type='uniform')
        uni=im.apparentsens();
        print 'Uniform Sensitivity =', uni[1];
        print 'Relative to Natural Weighting = ', uni[2];

        # switch to briggs weighting
        im.weight(type='briggs',robust=0.0)
        rob=im.apparentsens();
        print 'Briggs Sensitivity =', rob[1];
        print 'Relative to Natural Weighting = ', rob[2];

        im.close()


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_apparentsens(self, *args, **kwargs)

    def setbeam(self, *args, **kwargs):
        """
        setbeam(self, bmaj=initialize_variant("1.0arcsec"), bmin=initialize_variant("1.0arcsec"), bpa=initialize_variant("0deg"), 
            async=False) -> bool

        Summary
        	Set the beam parameters for clean restoration

        Description
        	
        This sets the clean beam that will be used in all restoration
        operations.


        Input Parameters:
        	bmaj		 Major axis of beam 1.0arcsec 
        	bmin		 Minor axis of beam 1.0arcsec 
        	bpa		 Position angle of beam 0deg 
        	async		 Run asynchronously in the background false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setbeam(self, *args, **kwargs)

    def selectvis(self, *args, **kwargs):
        """
        selectvis(self, vis=string(""), nchan=initialize_vector(1, (int)-1), start=initialize_vector(1, (int)0), 
            step=initialize_vector(1, (int)1), spw=initialize_variant("-1"), field=initialize_variant("-1"), 
            baseline=initialize_variant("-1"), time=initialize_variant(""), 
            scan=initialize_variant(""), intent=string(""), observation=initialize_variant(""), 
            uvrange=initialize_variant(""), taql=string(""), 
            usescratch=False, datainmemory=False, writeaccess=True) -> bool

        Summary
        	Select visibilities for subsequent processing

        Description
        	
        This setup tool function selects which data are to be used 
        subsequently. After invocation of selectvis, only the selected
        data are operated on. Thus, for example, in imaging, only the selected
        data are gridded into an image, and in plotting, only the
        selected data are plotted.

        Data can be selected by field and spectral window ids. Note that
        all data thus selected are passed to imaging, and may or
        may not be imaged, depending on how the image was constructed
        using defineimage. For example,
        in mosaicing, use fieldid in defineimage to control what pointing
        is used to define the field center, and use fieldid in selectvis
        to control what pointings are used in the imaging.

        For spectral processing, it is possible to make cubes out
        multi-spectral window selections but the selection and combination can
        be a bit confusing (any hint at how to make it clearer is welcome).

        If the default values are not used, then data to be used can be selected channel wise. The 

        egin{description}
        \item[nchan]   is the number of data channels selected. It
        defaults to -1 (interpreted as all channels).
        \item[start] is the first channel from input dataset that is to be used.
        It defaults to 0 (i.e. first channel).
        \item[step] gives the increment between selected input channels. It defaults to 1 channel. A value of {	t n}  means that {	t n-1} data channels will not not be used.  
        nd{description}



        By choosing the parameters for selectvis and defineimage correctly,
        one may obtain various mappings of visibility channels to image
        channels. For example, to average 512 visibility channels into 64 
        image channels (producing image channels consisting of 8
        visibility channels):


        im.defineimage(mode='channel', spw=0, nchan=64, start=1, step=8);
        im.selectvis(spw=0, nchan=512, start=1, step=1)
        im.clean(.....);


        This averages the spectral channels during the gridding process. If
        one wanted to only include every 8th channel in the
        deconvolution, one would do:


        im.selectvis(nchan=64, start=1, step=8)
        im.defineimage(mode='channel', nchan=64, start=1, step=8);
        im.clean(....);


        For velocity and opticalvelocity modes, the mstart and mstep
        are the start and step velocities as strings.


        im.defineimage(mode='velocity', nchan=64, start='20 km/s', step='-100m/s');
        im.selectvis(spwid=[-1]); \#\#\#selecting all data spectral windows
        im.clean(...);


        If the image and data selections differ, then averaging is done during
        the gridding and degridding process in the image deconvolution.


        im.defineimage(mode='channel', nchan=64, start=1, step=8);
        im.selectvis(nchan=512, start=1, step=1)
        im.clean()


        Note:  The channels numbers used in {	t defineimage}
        and {	t selectvis} refers to the same channel. So if a channel is not
        selected in {	t selectvis} but is selected in {	t defineimage}, then
        blank channels image are made. The example below will result in the 
        having the first 6 (0-5) channels in the image to be blank.


        im.selectvis(nchan=50, start=6, step=1) \#selected chan 6-55
        im.defineimage(mode='channel', nchan=50, start=0, step=1); 

         \# will try to image channel 1-50. But as previously only channel 6-55 
         \# was selected only channel 6-50 will have data; images of channels
         \# 1-5 are blank 
        im.clean(....)


        For multi-spectral window cube imaging the selection of the data can
        be done as follows


        im.selectvis(nchan=[50,60], start=[0,0], step=[1,1],
                     spw=[0,1]) 
        im.defineimage(mode='channel', nchan=110, start=0, step=1, spw=[0,1]); 



        The above means that you would make a data selection of 50 channels
        (starting from 0 steping 1) from the first spectral window and 60
        channels (starting from 1 steping 1). The defineimage defines the image
        to be a cube of 110 channels. The caveat is the step size in the
        frequency direction is the step size of the first spectral window. If
        the step size of channels of the two spectral windows are different
        then one is better off defining the image cube in velocities (e.g. as below). 

                                                                              

        im.selectvis(nchan=[50,60], start=[0,0], step=[1,1],
                     spw=[1,2]) 
        im.defineimage(mode='velocity', nchan=200, mstart='20km/s',
                     mstep='-100m/s'); 
        	





        Input Parameters:
        	vis		 Measurementset for which this selection applies; an empty string '' implies that it is to be applied in ms used in open 
        	nchan		 Number of channels to select -1 
        	start		 Start channels (0-relative) 0 
        	step		 Step in channel number 1 
        	spw		 Spectral Window Ids (0 relative) to select; -1 interpreted as all -1 
        	field		 Field Ids (0 relative) or Field names (msselection syntax and wilcards are used) to select -1 
        	baseline	 Antenna Ids (0 relative) or Antenna names (msselection syntax and wilcards are used) to select -1 
        	time		 Limit data selected to be within a given time range. The syntax is defined in the msselection link 
        	scan		 Limit data selected on scan numbers. The syntax is defined in the msselection link 
        	intent		 Limit data selected on observation intent. The syntax is defined in the msselection link 
        	observation	 Limit data using observation IDs. The syntax is defined in the msselection link 
        	uvrange		 Limit data selected on uv distance. The syntax is defined in the msselection link 
        	taql		 For the TAQL experts, flexible data selection using the TAQL syntax 
        	usescratch	 If True: imager will use CORRECTED\_DATA column and will make scratch columns and store Model visibilities after deconvolution false 
        	datainmemory	 If True: imager will load the selected ms memory; useful if imaging a few channels that fit in memory false 
        	writeaccess	 If False: imager will open the ms in readmode; useful for multiple process access to the MS true 
        	
        Example:
        	

        im.open('3C273XC1.MS');
        im.selectvis(nchan=512,start=1,step=1, taql='SCAN_NUMBER > 10 && FIELD_ID==2')


        Time range selection

        im.selectvis(field=range(0,10), time='> 2000/09/21/12:00:00')


        select some antennas, for all fields that begins with {	t 'ngc'} 

        im.selectvis(field='ngc*', baseline=[0, 10, 20])


        And for those that the standard parameters are not flexible enough
        there is the taql parameter. This for people who knows the different
        columns of the MeasurementSet

        im.selectvis(taql='ANTENNA1==0 && ANTENNA2==3')


        Imager allows the user to make an image from multiple ms, without the
        need to concatenate them. To do this then the im.open method should
        {f not} be used at all but multiple calls of selectvis with the
        parameter vis pointing to each ms should be used. The other 
        parameters can be used to make selection on each ms


        im.selectvis(vis='myms1.ms', field=0, spw=[0,1], nchan=[40, 50], start=[5,10])
        im.selectvis(vis='myms2.ms', field=10, spw=[2], nchan=[40], start=[5])
        im.selectvis(vis='myms3.ms', field=range(0,10), time='> 2002/10/15/20:30:45')



        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_selectvis(self, *args, **kwargs)

    def setjy(self, *args, **kwargs):
        """
        setjy(self, field=initialize_variant(""), spw=initialize_variant(""), modimage=string(""), fluxdensity=initialize_vector(4,(double)0.0, (double)0.0, (double)0.0, (double)0.0), 
            standard=string("SOURCE"), 
            scalebychan=False, spix=initialize_vector(1, (double)0.0), 
            reffreq=initialize_variant("1GHz"), polindex=initialize_vector(1, (double)0.0), 
            polangle=initialize_vector(1, (double)0.0), rotmeas=0.0, 
            time=string(""), scan=string(""), intent=string(""), observation=string(""), 
            interpolation=string("nearest")) -> record *

        Summary
        	Compute the model visibility for a specified source flux density

        Description
        	
        Compute the model visibility for a specified source flux density, and
        insert into the MODEL\_DATA column. The source flux density for
        a set of standard flux density reference sources may optionally
        be pre-computed, by setting the input flux density to -1 (the default).
        At present, these include 3C286, 3C48, 3C147, 3C138, and 1934-638.
        In this case, if the source is not in this set, an unpolarized
        flux density of 1 Jy will be assumed.  Users may also specify
        {	t standard='SOURCE'} to use the model(s) in the SOURCE\_MODEL column of the
        SOURCE subtable.

        Users may also specify a model image that will be scaled to the
        specified total flux density (or that computed for reference sources).
        When a model image is specified, setjy will only permit processing
        one field, and will currently only process Stokes I.  



        Input Parameters:
        	field		 Field Id (0-relative) or name 
        	spw		 Spectral Window Id. (0-relative) 
        	modimage	 A model image 
        	fluxdensity	 Specified flux density (I,Q,U,V) in Jy (lookup the value; use 1.0 if not found) 0.0 0.0 0.0 0.0 
        	standard	 Flux density standard Baars Perley 90 Perley-Taylor 95 Perley-Taylor 99 Perley-Butler 2010 SOURCE 
        	scalebychan	 Do the flux scaling on a per channel basis else on a spw basis. Effectively True if fluxdensity is specified. false 
        	spix		 Spectral index for fluxdensity. S = fluxdensity * (freq/reffreq)**spix 0.0 
        	reffreq		 Reference frequency for spix. 1GHz 
        	polindex	 Coefficients for Taylor expansion of Polarization index 0.0 
        	polangle	 Coefficients for Taylor expansion of Polarization angle in radians 0.0 
        	rotmeas		 rotation measure (rad/lambda**2) 0.0 
        	time		 Time range to operate on 
        	scan		 Scan(s) to operate on 
        	intent		 Observation intent 
        	observation	 Observation ID(s) to operate on 
        	interpolation	 interpolation method in the case of time variable calibrator nearest 
        	
        Example:
        	

        im.setjy(fieldid=2, spwid=-1, fluxdensity=[2.6,0.2,0.3,0.5],standard='Baars')


        Compute the model visibility for field id. 2 to the specified
        point-source (I,Q,U,V) for all spectral windows id.'s on the
        Baars flux density scale.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setjy(self, *args, **kwargs)

    def ssoflux(self):
        """
        ssoflux(self) -> bool

        Summary
        	Use setjy instead.

        Description
        	
        *This was an experimental clone of setjy while flux calibration with Solar
         System objects was being tested.  It has been merged back into setjy.*

        Example:
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_ssoflux(self)

    def setmfcontrol(self, *args, **kwargs):
        """
        setmfcontrol(self, cyclefactor=1.5, cyclespeedup=-1, cyclemaxpsffraction=0.8, stoplargenegatives=2, 
            stoppointmode=-1, minpb=0.1, scaletype=string("NONE"), constpb=0.4, fluxscale=std::vector< string >(1, ""), 
            flatnoise=True) -> bool

        Summary
        	Set various cycle control parameters for 
        multi-field and wide-field imageing.

        Description
        	 
        Control parameters for mosaicing or wide-field imaging which are not
        required in single field deconvolution are set here to streamline the
        user interface.  As multifield and widefield imaging is accomplished
        by deconvolution in cycles, many of these parameters control how the
        deconvolution cycles are ended.

        egin{description}
        \item cyclefactor: this parameter helps in lowering or increasing the
          threshold at which the deconvolution cycle will stop  and degrid and
          subtract from the visibilities. For very bad PSFs you may want to
          reconcile with the visibilties often, thus a larger number is
          required here...(4 to 5). For very well behaved data you may want to
          deconvolve deep before reconciling: a lower number is used (1.5 to 2.0). 
        \item cyclespeedup: this is used if the PSF is not well behaved and
          you want clean to raise by 2 the threshold if it has not reached the
          threshold in this number of iteration
        \item cyclemaxpsffraction: similar to cyclefactor, but this is an
        explicit fraction of the PSF peak. The final threshold is computed
        using  min( cyclemaxpsffraction, cyclefactor * maxPSFsidelobe).
        Valid values are between 0.0 and 1.0. 
        \item stoplargenegatives: This parameter is exclusively for when using
          multiscale clean. This is used to stop the component
          search when the largest scale has found this number of negative
          components. -1 here means that continue component search even if the
          largest component is negative. 
        \item stoppointmode: Again exclusively for when using multiscale
          clean. The clean will stop if the smallest scale receives this
          number of consecutive components. 
        \item minpb: This is to defined up to what level the voltage pattern
          is going to applied when  using
          setvp. The default is 0.1 of the
          primary beam or the voltage pattern defined for the antenna.
        \item scaletype: This parameter cab be NONE or SAULT. If NONE the
          image is not scaled, if SAULT is used the image is weighted so that
          the noise is kept uniform across the image. The next two parameters
          defines how the SAULT weighting is limited. Obviously then the flux
          scale is not uniform across the image. To get the right flux
          multiply the image with the fluxscale image.
        \item constpb: this parameter defines up to what amplitude of the
          Primary beam the noise floor is kept uniform, when using SAULT as scaletype.
        \item fluxscale: use this to give a filename to store the factor image
          to apply to the image to get the fluxscale right.
        \item flatnoise: (default true) Set to false if you want clean components for mosaic  to be searched in the residual image that is effectively multiplied by the $beam^2$. This means when the noise is determined after the antenna, searching in the optimum domain of $signal/(sigma^2)$. For meter wavelengths where noise is determined by the sky, it is no longer optimal.
        nd{description}



        Input Parameters:
        	cyclefactor	 Cycle threshold = max\_resid * min(cyclemaxpsffraction, this * max\_sidelobe) 1.5 
        	cyclespeedup	 Cycle threshold doubles in this number of iterations -1 
        	cyclemaxpsffraction	 Cycle threshold = max\_resid * min(this, cyclefactor * max\_sidelobe) 0.8 
        	stoplargenegatives	 Stop the multiscale cycle for the first n cycles when a negative comp is found on the largest scale 2 
        	stoppointmode	 Stop multiscale altogether if the smallest scale recieves this many consecutive components -1 
        	minpb		 Minimum PB level to use 0.1 
        	scaletype	 Image plane flux scale type SAULT NONE NONE 
        	constpb		 In Sault weighting the flux scale is constant above this PB level 0.4 
        	fluxscale	 Names of flux scale images for mosaicing 
        	flatnoise	 Set to false if clean component search is to be done in an optimal signal/noise residual image if true will clean in a constant noise image true 
        	
        Example:
        	

        im.setmfcontrol(cyclefactor=2.0, cyclespeedup=niter/10, cyclemaxpsffraction=0.8,
        stoplargenegatives=T, stoppointmode=10, fluxscale='image.fluxscale');


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setmfcontrol(self, *args, **kwargs)

    def setoptions(self, *args, **kwargs):
        """
        setoptions(self, ftmachine=string("ft"), cache=-1, tile=16, gridfunction=string("SF"), location=initialize_variant(""), 
            padding=1.0, freqinterp=string("nearest"), wprojplanes=-1, 
            epjtablename=string(""), applypointingoffsets=False, dopbgriddingcorrections=True, 
            cfcachedirname=string(""), rotpastep=5.0, pastep=360.0, pblimit=0.05, 
            imagetilevol=0, singleprecisiononly=False, numthreads=-1, psterm=True, 
            aterm=True, mterm=True, wbawp=False, conjbeams=True) -> bool

        Summary
        	Set some general options for subsequent processing

        Description
        	
        This function is for setting different gridding and memory options

        egin{description}
        \item[ftmachine] The options for ftmachine are: 
        egin{description}
        \item[ft] Standard interferometric gridding
        \item[sd] Standard single dish gridding
        \item[both] ft and sd as appropriate.
        \item[wproject] option for using the wproject algorithm for wide-field
          imaging; when this option is used the parameter {	t wprojplanes}
          define the number of convolution functions to be used
        \item[mosaic] option to use the gridder that uses the primary beam as
          the convolution function in gridding

        nd{description}
        \item[cache] The size of the cache used (in complex pixels) during the
        gridding process. The default is to use half the physical memory of
        the machine as specified by the aipsrc variable system.resources.memory.
        \item[tile] The side of the tile (in complex pixels) during the
        gridding process.
        \item[gridfunction] The gridding function used. Currently only
        Box-car ('BOX') and Prolate Spheriodal Wave Function ('SF')
        are supported.  In the case of Single-Dish imaging the Primary Beam ('PB'), 
        Gaussian ('GAUSS'), and Gaussian * Jinc ('GJINC') also can be used. 
        \item[location] For some unusual types of image, one needs to know the
        location to be used in calculating phase rotations. For example,
        one can specify images to be constructed in azel, in which
        case, an antenna position must be chosen. One can use functions of
        measures: either
        observatory to
        get the position of a named observatory ({m e.g.}
        me.observatory('ATCA')) or
        position to set
        the position ({m e.g.}me.position('wgs84','30deg','40deg','10m')).
        Although this information is available from the MeasurementSet, what
        location is ambiguous in some cases {m e.g.} VLBI.
        \item[padding] When gridding and transforming, the array may be
        padded by this factor in the image plane. This reduces aliasing,
        especially in wide-field cleaning.
        \item[usemodelcol] if this is false it tells imager to create and use the model
          visibility on the fly and in memory as far as possible...otherwise
          if it is True then imager will use the MODEL\_DATA column to do this.
        \item[wprojplanes] this parameter is is used only of {	t ftmachine}
          is set to {	t wproject}. This defines how many convolution functions
          is used in the Wprojection gridder (a -1 implies an automatic determination).
        nd{description}


        Input Parameters:
        	ftmachine	 Fourier transform machine ft ft sd both wproject mosaic 
        	cache		 Size of gridding cache in complex pixels; default use half the memory available on computer -1 
        	tile		 Size of a gridding tile in pixels (in 1 dimension) 16 
        	gridfunction	 Gridding function SF SF BOX PB GAUSS GJINC 
        	location	 Location used in phase rotations 
        	padding		 Padding factor in image plane (\>=1.0) 1.0 
        	freqinterp	 interpolation mode in frequency;options:- nearest, linear, cubic, spline nearest nearest linear cubic spline 
        	wprojplanes	 No of gridding convolution functions used in wproject-ft machine (-1 means let the code decide this number) -1 
        	epjtablename	 E-Jones table name. This is used if applypointingoffsets is set to True. 
        	applypointingoffsets	 Apply pointing offset corrections during deconvolution. false 
        	dopbgriddingcorrections	 Correct for PB gridding before prediction of visibilities. This should be True when doing deconvolution. This should be False when predicting visibilities for model sky with no primary beam attenuation in the model. true 
        	cfcachedirname	 Directory where convolution functions are to be (or are being ) cached on the disk. 
        	rotpastep	 The PA increment in degree used for on-the-fly (OTF) rotation of the A-term in A-Projection. 5.0 
        	pastep		 The PA increment in degree used to compute the PA-rotated A-term in A-Projection. 360.0 
        	pblimit		 Primary beam limit when using PBWProjection 0.05 
        	imagetilevol	 Tile size on for image on disk (in pixel, multiply by 4 to get the byte size). It is safe to leave this as default, meant for usage on filesystem like Lustre, the default (0) implies 32x32x4x32 tile shape. Setting it explicitly to a negative number will also try to avoid using disk templattices when possible. 0 
        	singleprecisiononly	 Set this value to True to force single precision all the time. Otherwise imager may use double precision gridding (ft and wproject only for now) when it can and deems it fit. Setting to True can be handy on low memory machines false 
        	numthreads	 Limit the number of threads used in this run (openmp enabled only) -1 
        	psterm		 Switch-on the PS-Term? true 
        	aterm		 Switch-on the A-Term? true 
        	mterm		 Switch-on the M-Term? true 
        	wbawp		 Trigger the WB A-Projection algorithm? false 
        	conjbeams	 Use frequency conjugate beams in WB A-Projection algorithm? true 
        	
        Example:
        	

        - im.setoptions(cache=10000000, tile=32, gridfunction='BOX',
          location=me.location('vla'))

        The above example is to tell imager to use memory to fit 10000000
        complex numbers and tile the image with tiles of 32 pixels on a side. 
        Also it tells imager to use a box function as gridding function.  The
        location parameter will make imager overide the position of the
        telescope to use (the default is the one it gets from the ms). 


        im.open('n1333.ms')
        im.selectvis(fieldid=[2:6, 8:12], spwid=[1:2])
        im.defineimage(nx=800, ny=800, cellx='0.5arcsec', celly='0.5arcsec', mode='velocity', nchan=30, mstart='-10km/s', mstep='1.8km/s', spwid=[1,2],fieldid=3)
        im.setoptions(ftmachine='mosaic')
        im.setvp(dovp=T)
        im.setoptions(ftmachine='mosaic')
        im.clean(algorithm='mfclark', model='try1', niter=200)



        In the above example we are making a mosaic using the fields
        2,3,4,5,6,8,9,10,11,12 and we use the mosaic ftmachine. This uses the
        primary beam of the telescope as the gridding function.


        im.open('coma.ms')
        im.selectvis(spwid=1, fieldid=1);
        mydir=me.direction('J2000', '12h30m48', '12d24m0')
        im.defineimage(nx=200, cellx='30arcsec', phasecenter=mydir); 
        im.make('outlier1');
        im.defineimage(nx=1800, cellx='30arcsec');
        im.setoptions(ftmachine='wproject',wprojplanes=512, padding=1.0)
        im.make('main')
        im.clean(algorithm='mfclark',model=['main', 'outlier1'], niter=10000, image=['coma.image', 'outlier1.image'])
        im.done()



        In the above example we are using the Wprojection algorithm for 3-D
        imaging. We are using 512 gridding functions. Sometimes if there is a
        memory issue (very large images and many griding functions) we suggest  
        the use of facetting of the image with wprojection. So the example
        above would be something like below. Note that when using facets only
        the {	t wfclark} and {	t wfhogbom} can be used for now. Note on how
        an outlier field (or flanking) field is set on an interfering  source
        outside of the field of interest.


        im.open('coma.ms')

        im.selectvis(spwid=1, fieldid=1);
        mydir = me.direction('J2000', '12h30m48', '12d24m0')
        im.defineimage(nx=200, ny=200, cellx='30arcsec', celly='30arcsec', phasecenter=mydir); 
        im.make('outlier1');
        im.defineimage(nx=3000, ny=3000, cellx='30arcsec',celly='30arcsec',facets=3);
        im.setoptions(ftmachine='wproject',wprojplanes=200, padding=1.2)
        im.make('main')
        im.clean(algorithm='wfclark',model=['main', 'outlier1'], niter=10000)
        im.done()




        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setoptions(self, *args, **kwargs)

    def setscales(self, *args, **kwargs):
        """
        setscales(self, scalemethod=string("nscales"), nscales=5, uservector=initialize_vector(3,(double)0.0, (double)3.0, (double)10.0)) -> bool

        Summary
        	Set the scale sizes for MultiScale Clean

        Description
        	

        The multiscale clean algorithm cleans an image on a number of
        different scales, decomposing the image into Gaussians of these scale sizes.
        This function allows the user to set the number
        of scales used (using the nscales method), or to directly control the
        sizes of the scales in pixels (using the uservector method).  When using the
        nscales method, the scales are calculated using the following formula:
        egin{equation}
        	heta_{minor}  10.0 ^{(i- N\_{scales}/2)/2.0}
        nd{equation}
        where $	heta_{min}$ is the fitted minor axis of the clean beam. The
        first value is zero.


        Input Parameters:
        	scalemethod	 Method by which scales are set nscales uservector nscales 
        	nscales		 Number of scales 5 
        	uservector	 Vector of scale sizes in pixels to use, defaults should be 0,3,10 0.0 3.0 10.0 
        	
        Example:
        	

        - im.setscales(scalemethod='nscales', nscales=6);

        Here we make six scales automatically using the method described
        above.
        Or we could manually choose the scales in pixel numbers as follows:

        - im.setscales(scalemethod='uservector', uservector=[0,3,10,30]);


        Note: 0 pixel is the delta function, so if one were to select scale 0 only
        it would be  equivalent to a Hogbom clean.


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setscales(self, *args, **kwargs)

    def setsmallscalebias(self, inbias=0.6):
        """
        setsmallscalebias(self, inbias=0.6) -> bool

        Summary
        	Set bias toward smaller scales for  MultiScale Clean

        Description
        	



        Input Parameters:
        	inbias		 small scale bias 0.6 
        	
        Example:
        	

        - im.setsmallscalebias(inbias=0.6);




        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setsmallscalebias(self, inbias)

    def settaylorterms(self, ntaylorterms=2, reffreq=0.0):
        """
        settaylorterms(self, ntaylorterms=2, reffreq=0.0) -> bool

        Summary
        	Set the number of Taylor series terms for Multi-Frequency Clean

        Description
        	

        The multi-frequency clean algorithm cleans an image by approximating its spectra
        by a Taylor series expansion. This function allows the user to set the number of
        Taylor terms to be used. Options are 1,2,3.


        Input Parameters:
        	ntaylorterms	 Number of Taylor terms 2 
        	reffreq		 Reference Frequency 0.0 
        	
        Example:
        	

        - im.settaylorterms(ntaylorterms=3);


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_settaylorterms(self, ntaylorterms, reffreq)

    def setsdoptions(self, *args, **kwargs):
        """
        setsdoptions(self, scale=1.0, weight=1.0, convsupport=-1, pointingcolumntouse=string("DIRECTION"), truncate=initialize_variant("-1pixel"), 
            gwidth=initialize_variant("-1pixel"), 
            jwidth=initialize_variant("-1pixel"), minweight=0.) -> bool

        Summary
        	Set some options for single dish processing

        Description
        	
        Various less-often-used options for single dish processing can be set.

        egin{description}
        \item[scale] The overall scale of the single dish data is multiplied by this
        factor.
        \item[weight] The weight given to the single dish data in the imaging
        is multiplied by this factor.
        \item[convsupport] This parameter can be used to change the support used in gridding single dish data in imaging. If 'PB' or 'pb' is used as the 'convtype' in 
         setoptions this parameter is ignored as the support is defined by the primary beam. The deafult of -1 mans 1 as convsupport is used for 'box' convolution function and 3 is used for 'SF' convolution function.
        \item[pointingcolumntouse] This parameter is NOT to be changed under normal circumstances. This is to be used by those who know what they are doing and want to try to use different columns in the POINTING table especially if they believe their dish direction is wrong. And if any of the {	t \_OFFSET} columns is used do not expect to be able to use a different frame in the image setup in defineimage. Possible values are {	t DIRECTION, TARGET, ENCODER, POINTING\_OFFSET, SOURCE\_OFFSET} 
        \item[truncate] The truncation radius as a quantity or a float value. This parameter is effective only when 'GAUSS' or 'GJINC' is used as the 'convtype' in setoptions. You can use an unit 'pixel' to specify truncation radius as pixel value. If float value is set, or quantity without unit is set, its unit will be 'pixel'.
        \item[gwidth] The width of the gaussian beam as a radius of half maximum. This parameter is effective only when 'GAUSS' or 'GJINC' is used as the 'convtype' in setoptions. You can use an unit 'pixel' to specify truncation radius as pixel value. If float value is set, or quantity without unit is set, its unit will be 'pixel'. Note that, when 'GJINC' is used as the 'convtype', gwidth doesn't directry specify width of the convolution function.
        \item[jwidth] The witdh of the jinc beam as a parameter c, where jinc = J\_1(pi*x/c)/(pi*x/c). This parameter is effective only when 'GJINC' is used as the 'convtype' in setoptions. You can use an unit 'pixel' to specify truncation radius as pixel value. If float value is set, or quantity without unit is set, its unit will be 'pixel'. Note that jwidth doesn't directly specify width of the convolution function. 
        nd{description}


        Input Parameters:
        	scale		 Scaling applied to single dish data 1.0 
        	weight		 Weights applied to single dish data 1.0 
        	convsupport	 number of pixel for convolution support -1 
        	pointingcolumntouse	 Which Pointing Table column to use to get direction DIRECTION DIRECTION TARGET ENCODER POINTING\_OFFSET SOURCE\_OFFSET 
        	truncate	 truncation radius (effective only for 'GAUSS' or 'GJINC') -1pixel 
        	gwidth		 radius of half maximum for gaussian (effective only for 'GAUSS' or 'GJINC') -1pixel 
        	jwidth		 c-parameter for jinc function (effective only for 'GJINC') -1pixel 
        	minweight	 Minimum weight level to use for weight correction and weight based masking. 0. 
        	
        Example:
        	

        - im.setsdoptions(scale=1.0, weight=1.0, convsupport=5)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setsdoptions(self, *args, **kwargs)

    def setvp(self, *args, **kwargs):
        """
        setvp(self, dovp=False, usedefaultvp=True, vptable=string(""), dosquint=False, parangleinc=initialize_variant("360deg"), 
            skyposthreshold=initialize_variant("180deg"), telescope=string(""), 
            verbose=True) -> bool

        Summary
        	Set the voltage pattern model for subsequent processing

        Description
        	
        Set the voltage pattern model (and hence, the primary beam) used for a
        telescope.  There are currently two ways to set the voltage pattern: by using
        the extensive list of defaults which the system knows about, or by creating a
        voltage pattern description with the vpmanager.  The default voltage patterns
        include both a high and a low frequency VP for the WSRT, a VP for each
        observing band at the AT, several VP's for the VLA, including the appropriate
        beam squint for each observing band, and Gaussian for the BIMA dishes.  Due to
        temporary limitations in the internal structure of the visibility buffer, only
        one telescope's voltage pattern can be applied to a particular MeasurementSet.
        This will be corrected shortly.


        Input Parameters:
        	dovp		 Do voltage pattern (ie, primary beam) correction false 
        	usedefaultvp	 Look up the default VP for this telescope and frequency? true 
        	vptable		 If usedefaultvp is False, provide a VP Table made with vpmanager 
        	dosquint	 Activate the beam squint in the VP model false 
        	parangleinc	 Parallactice angle increment for squint application 360deg 
        	skyposthreshold	 Sky position threshold 180deg 
        	telescope	 Which default telescope to use; if empty use the one in encoded in MS 
        	verbose		 If false, suppress some messages from being sent to the logger. true 
        	
        Example:
        	

         im.setvp(dovp=True, usedefaultvp=True, dosquint=False)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setvp(self, *args, **kwargs)

    def setweightgrid(self, *args, **kwargs):
        """
        setweightgrid(self, weight=initialize_variant(""), type=string("imaging")) -> bool

        Summary
        	set the requested weight grids

        Description
        	

        This is a utility function when running multi imager processes in parallel on subsection of an ms/data independently
        One would wish to weight the dirty image before averaging or set the imaging weight density (when using unform or
        Brigg's style weighting) to account for all the data being used. This is {f NOT} for the general user but for people who 
        are parallelizing at the scripting level.




        Input Parameters:
        	weight		 Numeric array. Required input. 
        	type		 Type of weight requested imaging 
        	
        Example:
        	

        wght=im.getweightgrid('imaging')
        wght2=im2.getweightgrid('imaging')
        wght=wght+wght2

        im.setweightgrid(weight=wght, type='imaging')
        im2.setweightgrid(weight=wght, type='imaging')



        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_setweightgrid(self, *args, **kwargs)

    def smooth(self, *args, **kwargs):
        """
        smooth(self, model=std::vector< string >(1, ""), image=std::vector< string >(1, ""), usefit=True, 
            bmaj=initialize_variant("5.arcsec"), bmin=initialize_variant("5.arcsec"), 
            bpa=initialize_variant("0deg"), normalize=True, async=False) -> bool

        Summary
        	Calculate an image smoothed with a Gaussian beam

        Description
        	
        The model images are convolved with the specified Gaussian beam.  By
        default (normalize=T), the beam volume is normalized to unity so that
        the smoothing is flux preserving. The smoothing used in restoration is
        not normalized.


        Input Parameters:
        	model		 Name of input model 
        	image		 Name of output smoothed images 
        	usefit		 Use the fitted value (rather than that specified true 
        	bmaj		 Major axis of beam 5.arcsec 
        	bmin		 Minor axis of beam 5.arcsec 
        	bpa		 Position angle of beam 0deg 
        	normalize	 Normalize volume of psf to unity true 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        - im.smooth(model='3C273XC1.clean', image='3C273XC1.clean.restored',
        bmaj='2.0arcsec', bmin='2.0arcsec')


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_smooth(self, *args, **kwargs)

    def stop(self):
        """
        stop(self) -> bool

        Summary
        	stop the currently executing function asap

        Description
        	
        Stop the currently executing function as soon as possible. Note that
        it is not always possible to stop a function. 

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_stop(self)

    def summary(self):
        """
        summary(self) -> bool

        Summary
        	Summarize the current state of the imager tool

        Description
        	
        Writes a summary of the properties of the imager to the
        default logger. This includes:
        egin{itemize}
        \item The name of the MeasurementSet (set in construction or via the
        open function.
        \item The parameters of the image (set via defineimage)
        \item The current beam (set by fitpsf
        or setbeam.
        \item The selection of an ms (set via selectvis)
        \item The general processing options (set via setoptions)
        nd{itemize}

        Example:
        	

        - im.open('3C273XC1.MS');
        - im.defineimage(nx=256, ny=256)
        - im.summary()


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_summary(self)

    def uvrange(self, uvmin=0.0, uvmax=0.0):
        """
        uvrange(self, uvmin=0.0, uvmax=0.0) -> bool

        Summary
        	Select data within the limit of a given range

        Description
        	
        Apply a uvrange so that only points within a given uvrange are selected for further usage.  To be noted selectvis if used after uvrange will reset the selected range. So selectvis should be used prior to uvrange or can be used 

        to reset it if one changes one's mind. The points are not flagged! Further point to be noted for spectral line data the uv distance is calculated using the mean of the wavelengths of the different spectral channels selected. 



        Input Parameters:
        	uvmin		 Minimum uv distance allowed (wavelengths) 0.0 
        	uvmax		 Maximum uv distance allowed (wavelengths) 0.0 
        	
        Example:
        	

        im.weight('uniform')
        im.uvrange(0, 4000.0)


        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_uvrange(self, uvmin, uvmax)

    def weight(self, *args, **kwargs):
        """
        weight(self, type=string("natural"), rmode=string("none"), noise=initialize_variant("0.0Jy"), 
            robust=0.0, fieldofview=initialize_variant("0.0arcsec"), npixels=0, mosaic=False, 
            async=False) -> bool

        Summary
        	Apply additional weighting to the visibility weights

        Description
        	
        Apply visibility weighting to correct for the local density of
        sampling in the uv plane. The imaging weights are calculated on the fly 
        when processing the data and can be viewed by
        plotweights. 

        To correct for visibility sampling effects, natural, uniform, radial, and Briggs weighting are supported.  These work as
        follows. Then:
        egin{description}
        \item[natural]: minimizes the noise in the dirty image. The weight of
        the $i$-th sample is set to the inverse variance:
        egin{equation}
        w\_i={1\over{\sigma\_i^2}}
        nd{equation}
        where $\sigma_i$ is the noise of the $i$'th sample.
        \item[radial]: approximately minimizes rms sidelobes for an east-west synthesis
        array. The weight of the $i$-th sample is multiplied
        by the radial distance from the center of the $u,v$ plane:
        egin{equation}
        w\_i=w\_i \sqrt{u\_i^2+v\_i^2}
        nd{equation}
        \item[uniform]: For Briggs and uniform weighting, we first grid the inverse
        variance $w\_i$ for all selected data onto a grid of size given by the
        argument npixels (default to nx) and u,v cell-size given by
        $2/$fieldofview where fieldofview is the specified field of view
        (defaults to the image field of view).  This forms the gridded weights
        $W\_k$. The weight of the $i$-th sample is then changed:
        egin{equation}
        w\_i={w\_i\over{W\_k}}
        nd{equation}
        where $W\_k$ is the gridded weight of the relevant cell.
        It may be shown that this minimizes rms sidelobes over
        the field of view. By changing the field of view, one may suppress
        the sidelobes over a region different (usually smaller) than the
        image size.
        \item[briggs: rmode='norm']: The weights are changed:
        egin{equation}
        w\_i={w\_i\over{1 + W\_k f^2}}
        nd{equation}
        where:
        egin{equation}
        f^2={{(5*10^{-R})^2}\over{{\sum_k W\_k^2}\over{\sum\_i w\_i}}}
        nd{equation}
        and $R$ is the robust parameter. The scaling of $R$ is such that
        $R=0$ gives a good tradeoff between resolution and sensitivity.
        $R$ takes value between -2.0 (close to uniform weighting) to 2.0
        (close to natural).
        \item[briggs: rmode='abs']: The weights are changed:
        egin{equation}
        w\_i={w\_i\over{W\_k*R^2+2*\sigma_R^2}}
        nd{equation}
        where $R$ is the robust parameter and $\sigma_R$ is the noise
        parameter. 
        nd{description}
        For more details about Briggs (aka robust) weighting, see the \htmladdnormallink{Briggs thesis}
        {riggsURL}.

        Note that this weighting is {m not} cumulative since the imaging weights are
        calculated from the specified weight (function of noise; usually $1/\sigma^2$) per visibility
        (actually stored in the  WEIGHT column).



        Input Parameters:
        	type		 Type of weighting natural uniform briggs radial natural 
        	rmode		 Mode of briggs weighting norm abs none 
        	noise		 Noise used in absolute briggs weighting 0.0Jy 
        	robust		 Parameter in briggs weighting 0.0 
        	fieldofview	 Field of view for uniform weighting 0.0arcsec 
        	npixels		 Number of pixels in the u and v directions 0 
        	mosaic		 Individually weight the fields of a mosaic false 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        im.weight(type='briggs', rmode='norm', robust=0.5)


        Applies Briggs (robust) weighting.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_weight(self, *args, **kwargs)

    def mapextent(self, *args, **kwargs):
        """
        mapextent(self, ref=string("J2000"), movingsource=string(""), pointingcolumntouse=string("DIRECTION")) -> record *

        Summary
        	Compute map extent from given set of MSs

        Description
        	
        TODO: description must be filled


        Input Parameters:
        	ref		 direction reference J2000 
        	movingsource	 moving source name 
        	pointingcolumntouse	 POINTING table column to be used for computation DIRECTION 
        	
        Example:
        	

        TODO: example must be filled.

        --------------------------------------------------------------------------------
        	      
        """
        return _imager.imager_mapextent(self, *args, **kwargs)

imager_swigregister = _imager.imager_swigregister
imager_swigregister(imager)
cvar = _imager.cvar

# This file is compatible with both classic and new-style classes.


