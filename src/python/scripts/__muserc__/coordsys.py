# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_coordsys', [dirname(__file__)])
        except ImportError:
            import _coordsys
            return _coordsys
        if fp is not None:
            try:
                _mod = imp.load_module('_coordsys', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _coordsys = swig_import_helper()
    del swig_import_helper
else:
    import _coordsys
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class coordsys(_object):
    """Proxy of C++ casac::coordsys class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, coordsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, coordsys, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> coordsys"""
        this = _coordsys.new_coordsys()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _coordsys.delete_coordsys
    __del__ = lambda self : None;
    def newcoordsys(self, *args, **kwargs):
        """
        newcoordsys(self, direction=False, spectral=False, stokes=std::vector< string >(1, ""), linear=0, tabular=False) -> coordsys

        Summary
        	Create a non-default coordsys tool

        Description
        	

        By default, this constructor makes an empty Coordsys 	ool.  You can ask
        it to include various sorts of coordinates through the arguments. 
        Except for Stokes, you don't have any control over the coordinate
        contents (e.g.  reference value etc.) it does make for you on request. 
        But you can edit the Coordinate System after creation if you wish. 

        If you wish to make a Stokes coordinate, then you assign
        {\stfaf stokes} to a string (or a vector of strings) saying
        which Stokes you want.  \casa\ allows rather
        a lot of potential Stokes types.  

        Probably most useful is some combination of the
        basic I, Q, U, V, XX, YY, XY, YX, RR, LL, RL, and LR.

        However, a more esoteric choice is also possible:
        RX, RY, LX, LY, XR, XL, YR, YL (these are mixed
        linear and circular),  PP, PQ, QP, QQ (general quasi-orthogonal correlation products)
        RCircular, LCircular, Linear  (single dish polarization types).

        You can also specify some polarization `Stokes' types:
        Ptotal (Polarized intensity ($(Q^2+U^2+V^2)^{1/2}$),
        Plinear (Linearly Polarized intensity ($(Q^2+U^2)^{1/2}$),
        PFtotal (Polarization Fraction (Ptotal/I)), 
        PFlinear  (Linear Polarization Fraction (Plinear/I)), and
        Pangle  (Linear Polarization Angle ($0.5~arctan(U/Q)$ in radians)).

        Probably you will find the more unusual types aren't fully
        supported throughout the system.

        You can make a LinearCoordinate with as many uncoupled axes as you like.
        Thus, {\stfaf linear=2} makes one LinearCoordinate with 2 axes (think
        of it like a DirectionCoordinate which also has 2 axes [but coupled in
        this case], a longitude and a latitude).

        If you make a TabularCoordinate, it is linear to start with.
        You can change it to a non-linear one by providing
        a list of pixel and world values to function
        settabular.



        Input Parameters:
        	direction	 Make a direction coordinate ? false 
        	spectral	 Make a spectral coordinate ? false 
        	stokes		 Make a Stokes coordinate with these Stokes I Q U V XX YY XY YX RR LL RL LR 
        	linear		 Make a linear coordinate with this many axes 0 
        	tabular		 Make a tabular coordinate false 
        	
        Example:
        	

        '''
        #
        print '	----	 newcoordsys Ex 1 	----'
        cs1=cs.newcoordsys()
        print 'ncoordinates =',cs1.ncoordinates()
        #0
        cs1.done()
        #True
        cs2=cs.newcoordsys(direction=T,stokes=['I','V'])
        print 'ncoordinates =',cs2.ncoordinates()
        #2L
        print cs2.coordinatetype()
        #['Direction', 'Stokes']
        cs2.summary()
        #
        '''

        The second Coordinate System contains a direction coordinate
        and a Stokes coordinate.   This means that there are three `axes'
        associated with the 2 coordinates.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_newcoordsys(self, *args, **kwargs)

    def addcoordinate(self, *args, **kwargs):
        """
        addcoordinate(self, direction=False, spectral=False, stokes=std::vector< string >(1, ""), linear=0, tabular=False) -> bool

        Summary
        	Add default coordinates.  (For assay testing only.)

        Description
        	
        Add default coordinates of the specified types.  This function allows
        multiple coordinates of the same type which are not well supported.
        Use only for assay tests.


        Input Parameters:
        	direction	 Add a direction coordinate ? false 
        	spectral	 Add a spectral coordinate ? false 
        	stokes		 Add a Stokes coordinate with these Stokes I Q U V XX YY XY YX RR LL RL LR 
        	linear		 Add a linear coordinate with this many axes 0 
        	tabular		 Add a tabular coordinate false 
        	
        Example:
        	

        '''
        #
        print '	----	 addcoordinate Ex 1 	----'
        mycs=cs.newcoordsys()
        mycs.addcoordinate(direction=T)
        mycs.done()
        #
        '''



        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_addcoordinate(self, *args, **kwargs)

    def axesmap(self, toworld=True):
        """
        axesmap(self, toworld=True) -> std::vector< int >

        Summary
        	Find mapping between world and pixel axes

        Description
        	

        This function returns a vector describing the mapping from pixel to
        world or world to pixel axes.  It is not for general user use.

        See the \htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
        ordering.  Generally they will be in the same order.



        Input Parameters:
        	toworld		 Map from pixel to world ? true 
        	
        Example:
        	

        '''
        #
        print '	----	 axesmap Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        csys.axesmap(T);
        #[1L, 2L, 3L]
        csys.axesmap(F);
        #[1L, 2L, 3L]
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_axesmap(self, toworld)

    def axiscoordinatetypes(self, world=True):
        """
        axiscoordinatetypes(self, world=True) -> std::vector< std::string >

        Summary
        	Return types of coordinates for each axis

        Description
        	

        This function  returns a vector string 
        giving the coordinate type for each axis (world or pixel)
        in the Coordinate System.

        See the \htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
        ordering.



        Input Parameters:
        	world		 World or pixel axes ? true 
        	
        Example:
        	

        '''
        #
        print '	----	 axiscoordinatetypes Ex 1 	----'
        csys=cs.newcoordsys(direction=T,spectral=T)
        csys.axiscoordinatetypes()
        #['Direction', 'Direction', 'Spectral']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_axiscoordinatetypes(self, world)

    def conversiontype(self, *args, **kwargs):
        """
        conversiontype(self, type=string("direction")) -> string

        Summary
        	Get extra reference conversion layer

        Description
        	

        Some coordinates contain a reference code.  Examples of reference codes
        are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.  When you do conversions between pixel and world
        coordinate, the coordinates are in the reference frame corresponding to
        these codes.   

        Function  setconversiontype
        allows you to specify a different reference frame
        which is used when converting between world and pixel coordinate.

        This function allows you to recover those conversion types.  If no extra
        conversion layer has been set, you get back the native reference types.



        Input Parameters:
        	type		 Coordinate type, direction, spectral direction 
        	
        Example:
        	

        '''
        #
        print '	----	 conversiontype Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        print csys.conversiontype (type='direction'), ' ', csys.conversiontype (type='spectral')
        #J2000   LSRK
        csys.setconversiontype (direction='GALACTIC', spectral='BARY')
        print csys.conversiontype (type='direction'), ' ', csys.conversiontype (type='spectral')
        #GALACTIC   BARY
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_conversiontype(self, *args, **kwargs)

    def convert(self, *args, **kwargs):
        """
        convert(self, coordin, absin=initialize_vector(1, (bool)true), dopplerin=string("radio"), unitsin=std::vector< string >(1, ""), 
            absout=initialize_vector(1, (bool)true), dopplerout=string("radio"), 
            unitsout=std::vector< string >(1, ""), shape=initialize_vector(1, (int)-1)) -> std::vector< double >

        Summary
        	Convert a numeric mixed coordinate 

        Description
        	

        This function converts between mixed pixel/world/abs/rel numeric
        coordinates.  The input and output coordinates are specified via a 
        numeric vector giving coordinate values, a string vector giving units, a
        boolean vector specifying whether the coordinate is absolute or relative
        (to the reference pixel) and doppler strings specifying the doppler
        convention for velocities.

        The units string may include {\cf pix} for pixel coordinates and
        velocity units (i.e. any unit consistent with {\cf m/s}).

        The allowed doppler strings and definition are described
        in function summary.

        The {\stfaf shape} argument is optional.  If your Coordinate
        System is from an image, then assign the image shape to this
        argument.  It is used only when making mixed (pixel/world) conversions
        for Direction Coordinates to resolve ambiguity.

        The example clarifies the use of this function.



        Input Parameters:
        	coordin		 Input coordinate, as a numeric vector 
        	absin		 Are input coordinate elements absolute ? true 
        	dopplerin	 Input doppler type for velocities radio 
        	unitsin		 Input units, string vector Native 
        	absout		 Are output coordinate elements absolute ? true 
        	dopplerout	 Output doppler type for velocities radio 
        	unitsout	 Output units Native 
        	shape		 Image shape, integer vector -1 
        	
        Example:
        	
        In this example we convert from a vector of absolute pixels
        to a mixture of pixel/world and abs/rel.

        '''
        #
        print '	----	 convert Ex 1 	----'
        csys=cs.newcoordsys(direction=T, spectral=T)    # 3 axes
        cout=csys.convert(coordin=[10,20,30],absin=[T,T,T],
                          unitsin=['pix','pix','pix'],
                          absout=[T,F,T], dopplerout='optical',
                          unitsout=['pix','arcsec','km/s'])
        print cout
        #[10.0, 1140.0058038878046, 1139.1354056919731]
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_convert(self, *args, **kwargs)

    def convertdirection(self, *args, **kwargs):
        """
        convertdirection(self, frame) -> record *

        Summary
        	Convert the direction coordinate to the specified frame by rotating as necessary about the reference pixel so the axes line up with the cardinal directions.

        Description
        	
                Convert the direction coordinate in the coordinate system to the specified frame by
                rotating about the reference pixel so that the resulting coordinate axes are parallel
                to the cardinal directions. The resulting coordinate will not have a conversion layer,
                even if the input direction coordinate does. A conversion layer can be set after by
                running cs.setconversiontype(). Be aware that if you attach the resulting coordinate
                system to an image whose pixels have not been rotated around the reference pixel in
                the same manner, you will likely get an image for which the pixels do not match
                up to world coordinate values. This method should only be used by experienced users who
                know what they are doing. It was written originally to facilitate rotating the
                direction coordinate since the implementation of imregrid requires this in certain
                circumstances. The conversion is done in place; a new coordinate system tool is not
                created. The returned record represents an angular quantity through which the old
                direction coordinate was rotated to create the new coordinate.
            

        Input Parameters:
        	frame		 Reference frame to convert to. 
        	
        Example:
        	
                
            
        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_convertdirection(self, *args, **kwargs)

    def convertmany(self, *args, **kwargs):
        """
        convertmany(self, coordin, absin=initialize_vector(1, (bool)true), dopplerin=string("radio"), unitsin=std::vector< string >(1, ""), 
            absout=initialize_vector(1, (bool)true), dopplerout=string("radio"), 
            unitsout=std::vector< string >(1, ""), shape=initialize_vector(1, (int)-1)) -> variant *

        Summary
        	Convert many numeric mixed coordinates

        Description
        	

        This function converts between many mixed pixel/world/abs/rel numeric
        coordinates.   See function convert
        for more information.

        The only diffference with that function is that you
        provide a matrix holding many coordinates to convert
        and a matrix of many converted coordinates is returned.



        Input Parameters:
        	coordin		 Input coordinate, numeric matrix 
        	absin		 Are input coordinate elements absolute ? true 
        	dopplerin	 Input doppler type for velocities radio 
        	unitsin		 Input units, string vector Native 
        	absout		 Are output coordinate elements absolute ? true 
        	dopplerout	 Output doppler type for velocities radio 
        	unitsout	 Output units Native 
        	shape		 Image shape, integer array -1 
        	
        Example:
        	

        '''
        #
        print '	----	 convertmany Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)    # 3 axes
        # absolute pixel coordinates; 10 conversions each of length 3; spectral
        cin=[(15, 15, 15, 15, 15, 15, 15, 15, 15, 15),  # pixel runs from 1 to 10
             (20, 20, 20, 20, 20, 20, 20, 20, 20, 20),
             ( 1,  2,  3,  4,  5,  6,  7,  8,  9, 10)]
        cout = csys.convertmany (coordin=cin,     
                                 absin=[T,T,T],
                                 unitsin=['pix','pix','pix'],
                                 absout=[T,F,T],
                                 dopplerout='optical',
                                 unitsout=['pix','deg','km/s']);
        print cout
        #[(15.0, 15.0, 15.0, 15.0, 15.0, 15.0, 15.0, 15.0, 15.0, 15.0),
        # (0.31666827885771637, 0.31666827885771637, 0.31666827885771637,
        #  0.31666827885771637, 0.31666827885771637, 0.31666827885771637,
        #  0.31666827885771637, 0.31666827885771637, 0.31666827885771637,
        #  0.31666827885771637),
        # (1145.3029083129913, 1145.0902316004676, 1144.8775551885467,
        #  1144.6648790772279, 1144.4522032665102, 1144.2395277563601,
        #  1144.0268525468437, 1143.8141776379266, 1143.6015030296085,
        #  1143.3888287218554)]
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_convertmany(self, *args, **kwargs)

    def coordinatetype(self, *args, **kwargs):
        """
        coordinatetype(self, which=-1) -> std::vector< std::string >

        Summary
        	Return type of specified coordinate

        Description
        	

        This function  returns a string describing
        the type of the specified coordinate.  If {\stfaf which=unset} the types
        for all coordinates are returned.

        Possible output values are 'Direction', 'Spectral', 'Stokes', 'Linear', and
        'Tabular'



        Input Parameters:
        	which		 Which coordinate ? (0-rel) -1 
        	
        Example:
        	

        '''
        #
        print '	----	 coordinatetype Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        csys.coordinatetype(0)
        #'Direction'
        cs.coordinatetype()
        #['Direction', 'Spectral']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_coordinatetype(self, *args, **kwargs)

    def copy(self):
        """
        copy(self) -> coordsys

        Summary
        	Copy this Coordsys tool

        Description
        	



        This function returns a copy, not a reference, of the Coordsys 	ool.
        It is your responsibility to call the {\stff done} function
        on the new 	ool.


        Example:
        	

        '''
        #
        print '	----	 copy Ex 1 	----'
        cs1 = cs.newcoordsys(direction=T, spectral=T)
        cs2 = cs1         # Reference
        print cs1, cs2
        cs1.summary()
        cs2.summary()
        cs1.done()        # done invokes default coordsys tool
        cs1.summary()
        cs2.summary()     # cs2 gets doned when cs1 does
        cs1 = cs.newcoordsys(direction=T, spectral=T)
        cs2 = cs1.copy()  # Copy
        cs1.done()
        cs1.summary()     # cs1 is default coordsys tool
        cs2.summary()     # cs2 is still viable
        cs2.done()
        cs2.summary()     # Now it's done (done just invokes default constructor)
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_copy(self)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Destroy this Coordsys tool, restore default tool

        Description
        	

        If you no longer need to use a Coordsys 	ool calling this function
        will free up its resources and restore the default coordsys tool. 


        Example:
        	

        '''
        #
        print '	----	 done Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        csys.done()
        print csys.torecord()            # default tool
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_done(self)

    def epoch(self):
        """
        epoch(self) -> record *

        Summary
        	Return the epoch

        Description
        	

        This function  returns the epoch of the observation as a
        Measure.  


        Example:
        	

        '''
        #
        print '	----	 epoch Ex 1 	----'
        csys = cs.newcoordsys()
        ep = csys.epoch()
        print ep
        #{'type': 'epoch', 'm0': {'value': 54151.96481085648, 'unit': 'd'}, 'refer': 'UTC'}
        time = me.getvalue(ep)           # Extract time with measures
        print time
        #{'m0': {'value': 54151.96481085648, 'unit': 'd'}}
        qa.time(time)                    # Format with quanta
        #'23:09:20'
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_epoch(self)

    def findaxis(self, world=True, axis=0):
        """
        findaxis(self, world=True, axis=0) -> record *

        Summary
        	Find specified axis in coordinate system

        Description
        	

        This function  finds the specified axis in
        the Coordinate System. If the axis does not exist, it throws an exception.



        Input Parameters:
        	world		 is axis a world or pixel axis ? true 
        	axis		 Axis in coordinate system 0 
        	
        Example:
        	

        '''
        #
        print '	----	 findaxis Ex 1 	----'
        csys=cs.newcoordsys(direction=T, linear=2)          # RA/DEC/Lin1/Lin2
        rtn=csys.findaxis(T,1)                              # DEC
        rtn
        #{'axisincoordinate': 1L, 'coordinate': 0L}
        rtn = csys.findaxis(T,2)                            # Lin1
        rtn
        #{'axisincoordinate': 0L, 'coordinate': 1L}
        #
        '''


        In these examples, the Coordinate System has 2 coordinates and 4 axes
        (0-rel, both world and pixel the same).  The first example finds the
        DEC axis (coordinate system axis 1) to be the second axis of the
        Direction Coordinate (coordinate 0). The second example finds the
        first linear axis (coordinate system axis 2) to be the first axis of
        the Linear Coordinate (coordinate 1).


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_findaxis(self, world, axis)

    def findaxisbyname(self, *args, **kwargs):
        """
        findaxisbyname(self, axisname=string(""), allowfriendlyname=True) -> int

        Summary
        	Find specified axis in coordinate system.

        Description
        	
                Find the world axis based on its name. Matching is not case sensitive and minimal match is supported, eg 'dec' will match 'Declination'.
                In addition, if allowfriendlyname is True, other common terms will match the expected axis. Currently supported are:
                'spectral' matches frequency type axes, eg 'Frequency' or 'Velocity',
                'ra' matches 'Right Ascension'. These names must be spelled out completely; eg 'spectral' rather than simply 'spec'.
                The first matching axis (zero-based) number is returned. If no axis can be matched, an exception is thrown.
            

        Input Parameters:
        	axisname	 Name of axis to find. Minimal match supported 
        	allowfriendlyname	 Support friendly naming. Eg 'spectral' will match 'frequency' or 'velocity', 'ra' will match 'right ascension' true 
        	
        Example:
        	
                # Find the declination axis
                ia.open('myimage')
                csys = ia.coordsys()
                ia.done()
                try:
                    dec_axis_number = csys.findaxisbyname('dec', False)
                except Exception
                    print 'Declination axis not found
                
                # find the spectral axis
                try:
                    spec_axis_number = csys.findaxisbyname('spectral', True)
                except Exception:
                    print 'Spectral axis could not be found.
                
             
        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_findaxisbyname(self, *args, **kwargs)

    def findcoordinate(self, *args, **kwargs):
        """
        findcoordinate(self, type=string("direction"), which=0) -> record *

        Summary
        	Find axes of specified coordinate

        Description
        	

        This function finds the axes in the
        Coordinate System for the specified coordinate (minimum match is active
        for argument {\stfaf type}).  By default it finds the first coordinate,
        but if there is more than one (can happen for linear coordinates), you
        can specify which.  It returns a dictionary with 'return', 'pixel', and
        'world' as keys. The associated value of 'return' is a boolean indicating if
        the specified coordinate was found. The values of 'pixel' and 'world' are
        arrays indicating the indices of the associated pixel and world axes, respectively,
        of the specified coordinate. If the coordinate does not exist, these arrays
        will be empty.

        See also the function axesmap
        which returns the mapping between pixel and world axes.



        Input Parameters:
        	type		 Type of coordinate to find: direction, stokes, spectral, linear, or tabular direction 
        	which		 Which coordinate if more than one 0 
        	
        Example:
        	

        '''
        #
        print '	----	 findcoordinate Ex 1 	----'
        csys=cs.newcoordsys(direction=T)
        rtn=cs.findcoordinate('direction')
        print rtn
        #{'world': [0L, 1L], 'pixel': [0L, 1L]}
        print 'pixel, world axes =', rtn['pixel'], rtn['world']
        #pixel, world axes = [0 1] [0 1]
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_findcoordinate(self, *args, **kwargs)

    def frequencytofrequency(self, *args, **kwargs):
        """
        frequencytofrequency(self, value, frequnit=string(""), velocity=initialize_variant("")) -> std::vector< double >

        Summary
        	Apply relativistic Doppler shift to a list of frequencies

        Description
        	
        This function converts frequencies to frequencies by applying a 
        relativistic Doppler shift: 
        fout = fin * sqrt((1.-v/c)/(1.+v/c)) . 

        The input frequencies are specified via a vector of numeric values and
        a specified unit ({\stfaf frequnit}).  If you don't give a frequency
        unit, it is assumed that the units are those given by function coordsys units() for
        the spectral coordinate.

        This function does not make any frame conversions (e.g.  LSR to BARY).

        This function fails if there is no spectral coordinate
        in the Coordinate System. See also function
        frequencytovelocity.


        Input Parameters:
        	value		 Frequencies to convert 
        	frequnit	 Unit of input frequencies. Default is unit of the spectral coordinate. 
        	velocity	 Velocity 
        	
        Example:
        	
        '''
          ia.open('M100line.image')
          mycs = ia.coordsys()
          ia.close()

          mycs.frequencytofrequency(value=[115271201800.0], frequnit='Hz', velocity='1000km/s')
        results in
          array([114887337607.0])

        Let's see if this is correct
          print 115271201800.0*sqrt((1.-1000000./299792458.0)/(1.+1000000./299792458.0))
        Result: 1.14887337607e+11
        '''

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_frequencytofrequency(self, *args, **kwargs)

    def frequencytovelocity(self, *args, **kwargs):
        """
        frequencytovelocity(self, value, frequnit=string(""), doppler=string("radio"), velunit=string("km/s")) -> std::vector< double >

        Summary
        	Convert frequency to velocity

        Description
        	

        This function  converts frequencies to
        velocities.  

        The input frequencies are specified via a vector of numeric values and
        a specified unit ({\stfaf frequnit}).  If you don't give a frequency
        unit, it is assumed that the units are those given by function coordsys units() for
        the spectral coordinate.

        This function does not make any frame conversions (e.g. LSR to BARY)
        but you can specifiy the velocity doppler definition via the {\stfaf
        doppler} argument (see image summary() for
        possible values).

        The velocities are returned in a vector for which you specify the
        units ({\stfaf velunit} - default is km/s).

        This function will return a fail if there is no spectral coordinate
        in the Coordinate System. See also function
        velocitytofrequency.



        Input Parameters:
        	value		 Frequency to convert 
        	frequnit	 Unit of input frequencies. Default is unit of the spectral coordinate. 
        	doppler		 Velocity doppler definition radio 
        	velunit		 Unit of output velocities km/s 
        	
        Example:
        	

        '''
        #
        print '	----	 frequencytovelocity Ex 1 	----'
        im = ia.fromshape(shape=[10,10,10])
        csys = ia.coordsys()
        rtn = csys.findcoordinate('spectral')   # Find spectral axis
        pa=rtn['pixel']
        wa=rtn['world']
        pixel = csys.referencepixel();          # Use reference pixel for non-spectral
        nFreq = ia.shape()[pa];                 # Length of spectral axis
        freq = [];
        for i in range(nFreq):
          pixel[pa] = i            # Assign value for spectral axis of pixel coordinate
          w = csys.toworld(value=pixel, format='n')   # Convert pixel to world
          freq.append(w['numeric'][wa]);              # Fish out frequency
        print 'freq=', freq
        #freq= [1414995000.0, 1414996000.0, 1414997000.0, 1414998000.0,
        # 1414999000.0, 1415000000.0, 1415001000.0, 1415002000.0, 1415003000.0, 1415004000.0]
        vel = csys.frequencytovelocity(value=freq, doppler='optical', velunit='km/s')
        print 'vel=', vel
        #vel= [1146.3662963847394, 1146.153618169159, 1145.9409402542183, 1145.7282626398826,
        # 1145.5155853261515, 1145.3029083129911, 1145.0902316004676, 1144.8775551885467,
        # 1144.6648790772279, 1144.4522032665104]
        #
        '''


        In this example, we find the optical velocity in km/s of every pixel
        along the spectral axis of our image.  First we  obtain the Coordinate
        System from the image.  Then we find which axis of the Coordinate System
        (image) pertain to the spectral coordinate.  Then we loop over each
        pixel of the spectral axis, and convert a pixel coordinate (one for each
        axis of the image) to world.  We obtain the value for the spectral axis
        from that world vector, and add it to the vector of frequencies.  Then
        we convert that vector of frequencies to velocity.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_frequencytovelocity(self, *args, **kwargs)

    def fromrecord(self, *args, **kwargs):
        """
        fromrecord(self, record) -> bool

        Summary
        	Fill Coordinate System from a record

        Description
        	

        You can convert a Coordinate System to a record
        (torecord).  This function
        (fromrecord) allows you to set the contents of an existing Coordinate
        System from such a record.   In doing so, you overwrite its current
        contents.





        Input Parameters:
        	record		 Record containing Coordinate System 
        	
        Example:
        	

        '''
        #
        print '	----	 fromrecord Ex 1 	----'
        csys = cs.newcoordsys(direction=T, stokes='I Q')
        print csys.ncoordinates()
        #2
        r = csys.torecord()
        cs2 = cs.newcoordsys()
        print cs2.ncoordinates()
        #0
        cs2.fromrecord(r)
        print cs2.ncoordinates()
        #2
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_fromrecord(self, *args, **kwargs)

    def increment(self, *args, **kwargs):
        """
        increment(self, format=string("n"), type=string("")) -> record *

        Summary
        	Recover the increments

        Description
        	

        Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate. 

        This function  returns the increment (in
        world axis order). You can recover  the increments either for all
        coordinates (leave {\stfaf type} unset) or for a specific coordinate
        type (mimumum match of the allowed types will do).  If you ask for a
        non-existent coordinate an exception is generated.

        See the \htmlref{discussion}{COORDSYS:FORMATTING} regarding the
        formatting possibilities available via argument {\stfaf format}.

        You can set the increment with function
        setincrement. 



        Input Parameters:
        	format		 Format string from combination of 'n', 'q', 's', 'm' n 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all. 
        	
        Example:
        	

        '''
        #
        print '	----	 increment Ex 1 	----'
        csys=cs.newcoordsys(direction=T,spectral=T)
        print csys.increment(format='q')
        #{'quantity': {'*1': {'unit': ''', 'value': -1.0},
        #              '*2': {'unit': ''', 'value': 1.0},
        #              '*3': {'unit': 'Hz', 'value': 1000.0}}}
        print csys.increment(format='n')
        #{'numeric': [-1.0, 1.0, 1000.0]}
        print csys.increment(format='n', type='spectral')
        #{'numeric': [1000.0]}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_increment(self, *args, **kwargs)

    def lineartransform(self, *args, **kwargs):
        """
        lineartransform(self, type) -> variant *

        Summary
        	Recover the linear transform matrix

        Description
        	

        Recover the linear transform component for the specified coordinate type.

        You can set the linear transform with function
        setlineartransform. 



        Input Parameters:
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular' 
        	
        Example:
        	

        '''
        #
        print '	----	 lineartransform Ex 1 	----'
        csys=cs.newcoordsys(direction=T,linear=3)
        csys.lineartransform('dir')                             # 2 x 2
        # [(1.0, 0.0), (0.0, 1.0)]
        csys.lineartransform('lin')                             # 3 x 3
        # [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_lineartransform(self, *args, **kwargs)

    def names(self, *args, **kwargs):
        """
        names(self, type=string("")) -> std::vector< std::string >

        Summary
        	Recover the names for each axis

        Description
        	

        Each axis associated with the Coordinate System has a name (they don't
        mean anything fundamental).  This function returns those names in
        world axis order.

        You can recover the names either for all coordinates (leave {\stfaf
        type} unset) or for a specific coordinate type (mimumum match of the
        allowed types will do).  If you ask for a non-existent coordinate an
        exception is generated.

        You can set the names with function
        setnames. 



        Input Parameters:
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all. 
        	
        Example:
        	

        '''
        #
        print '	----	 names Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        n = csys.names()
        print n[0]
        #Right Ascension 
        print n[1]
        #Declination 
        print n[2]
        #Frequency 
        print cs.names('spec')
        #Frequency
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_names(self, *args, **kwargs)

    def naxes(self, world=True):
        """
        naxes(self, world=True) -> int

        Summary
        	Recover the number of axes

        Description
        	

        Find the number of axes  in the Coordinate System.

        You may find the number of world or pixel axes; these are generally the
        same and general users can ignore the distinction.  See the
        \htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
        ordering.



        Input Parameters:
        	world		 Find number of world or pixel axes ? true 
        	
        Example:
        	

        '''
        #
        print '	----	 naxes Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        n = csys.naxes(T)
        print n
        #3                          # 2 direction axes, 1 spectral
        n = csys.naxes(F)
        print n
        #3
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_naxes(self, world)

    def ncoordinates(self):
        """
        ncoordinates(self) -> int

        Summary
        	Recover the number of coordinates in the Coordinate System

        Description
        	

        This function  recovers the number of
        coordinates in the Coordinate System.

        Example:
        	

        '''
        #
        print '	----	 ncoordinates Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        print csys.ncoordinates()
        #2
        cs2 = cs.newcoordsys(linear=4)
        print cs2.ncoordinates()
        #1
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_ncoordinates(self)

    def observer(self):
        """
        observer(self) -> string

        Summary
        	Return the name of the observer

        Description
        	

        This function returns the name of the observer.
        You can set it with the function setobserver.


        Example:
        	

        '''
        #
        print '	----	 observer Ex 1 	----'
        csys = cs.newcoordsys()
        print csys.observer()
        #Karl Jansky
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_observer(self)

    def projection(self, *args, **kwargs):
        """
        projection(self, type=string("")) -> record *

        Summary
        	Recover the direction coordinate projection

        Description
        	

        If the Coordinate System contains a direction coordinate, this function
         can be used to recover information about the
        projection.  For discussion about celestial coordinate systems,
        including projections, see the papers by Mark Calabretta and Eric
        Greisen. The initial draft  from 1996 (implemented in
        \casa.  Background information can be
        found
        \htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.

        What this function returns depends upon the value
        you assign to {\stfaf type}.

        egin{itemize}

        \item {\stfaf type=unset}.  In this case (the default), the actual
        projection type and projection parameters are returned in a
        record with fields {\cf type} and {\cf parameters}, respectively.

        \item {\stfaf type='all'}.  In this case, a vector of strings
        containing all of the possible projection codes is returned.

        \item {\stfaf type=code}.  If you specify a valid
        projection type code (see list by setting {\stfaf type='all'})
        then what is returned is the number of parameters required
        to describe that projection (useful in function
        setprojection).

        nd{itemize}

        You can change the projection with
        setprojection. 

        If the Coordinate System does not contain a direction coordinate,
        an exception is generated.



        Input Parameters:
        	type		 Type of projection. Defaults to current projection. 
        	
        Example:
        	

        '''
        #
        print '	----	 projection Ex 1 	----'
        csys = cs.newcoordsys(direction=T)
        print csys.projection()
        #{'type': 'SIN', 'parameters': [0.0, 0.0]}
        print csys.projection('all')
        #{'all': True, 'types': ['AZP', 'TAN', 'SIN', 'STG', 'ARC', 'ZPN', 'ZEA',
        # 'AIR', 'CYP', 'CAR', 'MER', 'CEA', 'COP', 'COD', 'COE', 'COO', 'BON',
        # 'PCO', 'SFL', 'PAR', 'AIT', 'MOL', 'CSC', 'QSC', 'TSC']}
        print csys.projection('ZPN')
        #{'nparameters': 100}
        #
        '''

        We first recover the projection type and parameters from
        the direction coordinate.  Then we find the list of all
        possible projection types.  FInally, we recover the number of 
        parameters required to describe the 'ZPN' projection.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_projection(self, *args, **kwargs)

    def referencecode(self, *args, **kwargs):
        """
        referencecode(self, type=string(""), list=False) -> std::vector< std::string >

        Summary
        	Return specified reference code

        Description
        	

        This function  returns the reference code
        for all, or the specified coordinate type.    Examples of the reference
        code are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.

        If {\stfaf type} is left unset, then a vector of strings is returned,
        one code for each coordinate type in the Coordinate System.

        If you specify {\stfaf type} then select from
        'direction', 'spectral', 'stokes', and 'linear'
        (the first two letters will do).  However, only the first two
        coordinate types will return a non-empty string.
        If the Coordinate System does not contain a coordinate of
        the type you specify, an exception is generated.

        The argument {\stfaf list} is ignored unless you specify a specific {\stfaf type}. 
        If {\stfaf list=T}, then this function returns the list of all possible
        reference  codes for the specified coordinate type.  Otherwise, it just
        returns the actual code current set in the Coordinate System.    

        The list of all possible types is returned as a record  (it is
        actually generated by the 
        listcodes function in the
        measures system). This record has two
        fields.  These are called 'normal' 
        (containing all normal codes) and 'extra' (maybe empty, with all extra
        codes like planets). 

        You can set the reference code with
        setreferencecode. 


        Input Parameters:
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all. 
        	list		 List all possibilities? false 
        	
        Example:
        	

        '''
        #
        print '	----	 referencecode Ex 1 	----'
        csys = cs.newcoordsys(direction=T)
        clist = csys.referencecode('dir', T)
        print clist
        #['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN', 'BTRUE',
        # 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
        # 'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
        # 'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS',
        # 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS',
        # 'NEPTUNE', 'PLUTO', 'SUN', 'MOON', 'COMET']
        print csys.referencecode('dir')
        #J2000
        #
        '''


        In this example we first get the list of all possible reference codes
        ofor a direction coordinate. Then we
        get the actual reference code for the direction coordinate in our
        Coordinate System.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_referencecode(self, *args, **kwargs)

    def referencepixel(self, *args, **kwargs):
        """
        referencepixel(self, type=string("")) -> record *

        Summary
        	Recover the reference pixel

        Description
        	

        Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate. 

        This function  returns the reference pixel
        (in pixel axis order). You can recover  the reference pixel either for
        all coordinates (leave {\stfaf type} unset) or for a specific coordinate
        type (mimumum match of the allowed types will do).  If you ask for a
        non-existent coordinate an exception is generated.

        You can set the reference pixel with function
        setreferencepixel. 



        Input Parameters:
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all. 
        	
        Example:
        	

        '''
        #
        print '	----	 referencepixel Ex 1 	----'
        csys = cs.newcoordsys(spectral=T, linear=2)
        csys.setreferencepixel([1.0, 2.0, 3.0])
        print csys.referencepixel()
        #{'ar_type': 'absolute', 'pw_type': 'pixel', 'numeric': array([ 1.,  2.,  3.])}
        print csys.referencepixel('lin')
        #{'ar_type': 'absolute', 'pw_type': 'pixel', 'numeric': array([ 2.,  3.])}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_referencepixel(self, *args, **kwargs)

    def referencevalue(self, *args, **kwargs):
        """
        referencevalue(self, format=string("n"), type=string("")) -> record *

        Summary
        	Recover the reference value

        Description
        	

        Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate. 

        This function  returns the reference value
        (in world axis order). You can recover  the reference value either for all
        coordinates (leave {\stfaf type} unset) or for a specific coordinate
        type (mimumum match of the allowed types will do).  If you ask for a
        non-existent coordinate an exception is generated.

        See the \htmlref{discussion}{COORDSYS:FORMATTING} regarding the
        formatting possibilities available via argument {\stfaf format}.

        You can set the reference value with function
        setreferencevalue. 



        Input Parameters:
        	format		 Format string. Combination of 'n', 'q', 's', 'm' n 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all. 
        	
        Example:
        	

        '''
        #
        print '	----	 referencevalue Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        print csys.referencevalue(format='q')
        #{'ar_type': 'absolute',
        # 'pw_type': 'world',
        # 'quantity': {'*1': {'unit': ''', 'value': 0.0},
        #              '*2': {'unit': ''', 'value': 0.0},
        #              '*3': {'unit': 'Hz', 'value': 1415000000.0}}}
        print csys.referencevalue(format='n')
        #{'ar_type': 'absolute',
        # 'numeric': array([  0.00000000e+00,   0.00000000e+00,   1.41500000e+09]),
        # 'pw_type': 'world'}
        print csys.referencevalue(format='n', type='spec')
        #{'ar_type': 'absolute',
        # 'numeric': array([  1.41500000e+09]),
        # 'pw_type': 'world'}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_referencevalue(self, *args, **kwargs)

    def reorder(self, *args, **kwargs):
        """
        reorder(self, order) -> bool

        Summary
        	Reorder the coordinates

        Description
        	

        This function reorders the coordinates in the Coordinate System.
        You specify the new order of the coordinates in terms of their old
        order.



        Input Parameters:
        	order		 New coordinate order 
        	
        Example:
        	

        '''
        #
        print '	----	 reorder Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T, linear=2)
        print csys.coordinatetype()
        #['Direction', 'Spectral', 'Linear']
        csys.reorder([1,2,0]);
        print csys.coordinatetype()
        #['Spectral', 'Linear', 'Direction']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_reorder(self, *args, **kwargs)

    def transpose(self, *args, **kwargs):
        """
        transpose(self, order) -> bool

        Summary
        	Transpose the axes.

        Description
        	

        This method transposes the axes (both world and pixel) in the coordinate system.
        You specify the new order of the axes in terms of their old
        order, so eg order=[1,0,3,2] means reorder the axes so that the zeroth
        axis becomes the first axis, the first axis becomes the zeroth axis,
        the second axis becomes the third axis, and the third axis becomes the
        second axis.



        Input Parameters:
        	order		 New axis order 
        	
        Example:
        	

        csys = cstool()

        # Create a coordinate system with axes, RA, Dec, Stokes, and Frequency
        csys.newcoordsys(direction=T, spectral=T, stokes=['I','Q'])

        # transpose the axes so that the order is RA, Dec, Frequency, and Stokes
        csys.transpose(order=[0, 1, 3, 2])


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_transpose(self, *args, **kwargs)

    def replace(self, *args, **kwargs):
        """
        replace(self, csys, whichin, whichout) -> bool

        Summary
        	Replace a coordinate

        Description
        	

        This function replaces one coordinate in the current Coordinate System by
        one coordinate in the given Coordinate System.  The specified
        coordinates must have the same number of axes.



        Input Parameters:
        	csys		 Coordinate System to replace from. Use coordsys' torecord() to generate required record. 
        	whichin		 Index of input coordinate (0-rel) 
        	whichout	 Index of output coordinate 
        	
        Example:
        	

        '''
        #
        print '	----	 replace Ex 1 	----'
        cs1 = cs.newcoordsys(direction=T, linear=1)
        print cs1.coordinatetype()
        #['Direction', 'Linear']
        cs2 = cs.newcoordsys(spectral=T)
        cs1.replace (cs2.torecord(),0,1)
        print cs1.coordinatetype()
        #['Direction', 'Spectral']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_replace(self, *args, **kwargs)

    def restfrequency(self):
        """
        restfrequency(self) -> record *

        Summary
        	Recover the rest frequency

        Description
        	

        If the Coordinate System contains a spectral coordinate, then
        it has a rest frequency.  In fact, the spectral coordinate
        can hold several rest frequencies (to handle for example,
        an observation where the band covers many lines), although
        only one is active (for velocity conversions) at a time.

        This function  recovers the rest frequencies
        as a quantity vector.   The first frequency is the active one.

        You can change the rest frequencies with
        setrestfrequency. 

        If the Coordinate System does not contain a frequency coordinate,
        an exception is generated.


        Example:
        	

        '''
        #
        print '	----	 restfrequency Ex 1 	----'
        csys = cs.newcoordsys(spectral=T)
        print csys.restfrequency()
        #{'value': [1420405751.7860003], 'unit': 'Hz'}
        csys.setrestfrequency (value=qa.quantity([1.2e9, 1.3e9],'Hz'), which=1, append=F)
        print csys.restfrequency()
        #{'value': [1300000000.0, 1200000000.0], 'unit': 'Hz'}
        #
        '''

        In the example, the initial spectral coordinate has 1 rest frequency.
        Then we set it with two, nominating the second as the active rest frequency,
        and recover them.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_restfrequency(self)

    def setconversiontype(self, *args, **kwargs):
        """
        setconversiontype(self, direction=string(""), spectral=string("")) -> bool

        Summary
        	Set extra reference conversion layer

        Description
        	

        Some coordinates contain a reference code.  Examples of reference codes
        are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.  When you do conversions between pixel and world
        coordinate, the coordinates are in the reference frame corresponding to
        these codes.   

        This function allows you to specify a different reference frame which
        is used when converting between world and pixel coordinate (see
        function conversiontype
        to recover the conversion types).  If it returns F, it means that
        although the conversion machines were successfully created, a trial
        conversion failed.  This usually means the REST frame was involved
        which requires a radial velocity (not yet implemented).  If this
        happens, the conversion type will be left as it was. The function
        fails if more blatant things are wrong like a missing coordinate, or
        an incorrect reference code.

        The list of possible reference codes can be obtained via function
        referencecode.

        With this function, you specify the desired reference code.  Then,
        when a conversion between pixel and world is requested, an extra
        conversion is done to ({\stff toWorld}) or from ({\stff toPixel}) the
        specified reference frame.

        The summary
        function shows the extra conversion reference system to the right of
        the native reference system (if it is different) and in parentheses.

        Note that to convert between different spectral reference frames, you
        need a position, epoch and direction.  The position (telescope) and
        epoch (date of observation), if not in your coordinate system can be set
        with functions settelescope and
        setepoch.  The direction is the
        reference direction of the {\it required} direction coordinate in the
        coordinate system. 

        igskip\goodbreak
        As an example, let us say you are working with a spectral coordinate
        which was constructed with the LSRK reference frame.  You want to convert
        some pixel coordinates to barycentric velocities (reference code BARY).

        egin{verbatim}
        '''
        #
        print '	----	 setconversiontype Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T); # Create coordinate system
        rtn=csys.findcoordinate('spectral')             # Find spectral coordinate
        wa=rtn['world']
        pa=rtn['pixel']
        u = csys.units()[wa]                            # Spectral unit
        print csys.referencecode(type='spectral')       # Which is  in LSRK reference frame
        #LSRK
        p = [10,20,30]
        w = csys.toworld(p, format='n')           # Convert a pixel to LSRK world
        print 'pixel, world = ', p, w['numeric']
        #pixel, world =  [10, 20, 30] [21589.999816660376, 20.000112822985134, 1415030000.0]
        p2 = csys.topixel(w)                      # and back to pixel
        print 'world, pixel = ', w['numeric'], p2
        #world, pixel =  [21589.999816660376, 20.000112822985134, 1415030000.0]
        # [10.00000000000248, 19.999999999999801, 30.0]
        # Convert LSRK frequency to LSRK velocity
        v = csys.frequencytovelocity(value=w['numeric'][wa], frequnit=u, 
                                     doppler='RADIO', velunit='m/s');
        print 'pixel, frequency, velocity = ', p[pa], w['numeric'][wa], v
        #pixel, frequency, velocity =  30 1415030000.0 1134612.30321
        csys.setconversiontype(spectral='BARY')   # Specify BARY reference code
        w = csys.toworld(p, format='n')           # Convert a pixel to BARY world
        print 'pixel, world = ', p, w['numeric']
        #pixel, world =  [10, 20, 30] [21589.999816660376, 20.000112822985134, 1415031369.0081882]
        p2 = csys.topixel(w)                      # and back to pixel
        print 'world, pixel = ', w['numeric'], p2
        #world, pixel =  [21589.999816660376, 20.000112822985134, 1415031369.0081882]
        # [10.00000000000248, 19.999999999999801, 30.0]
        # Convert BARY frequency to BARY velocity
        v = csys.frequencytovelocity(value=w['numeric'][wa], frequnit=u, 
                                      doppler='RADIO', velunit='m/s');
        print 'pixel, frequency, velocity = ', p[pa], w['numeric'][wa], v
        #pixel, frequency, velocity =  30 1415031369.01 1134323.35878
        #
        '''
        nd{verbatim}


        You must also be aware of when this extra layer is active and when it is
        not.  It's a bit nasty. 

        egin{itemize}

        \item - Whenever you use {\stff toWorld}, {\stff toPixel}
        {\stff toWorldMany}, or {\stff toPixelMany} the layer is active.   

        \item - Whenever you use {\stff convert} or {\stff convertMany}
        the layer {\it may} be active.   Here are the rules !

        It is only relevant to spectral and direction coordinates.

        For the direction coordinate part of your conversion, if you request a
        pure world or pixel conversion it is active.  Any pixel/world mix will
        not invoke it (because it is ill defined). 

        For the spectral coordinate part it is always active (only one axis
        so must be pixel or world).

        \item - This layer is irrelevant to all functions converting between
        frequency and velocity, and absolute and relative.  The values are in
        whatever frame you are working with. 

        nd{itemize}

        The summary function
        lists the reference frame for direction and spectral coordinates.  If
        you have also set a conversion reference code it also lists that (to
        the right in parentheses).



        Input Parameters:
        	direction	 Reference code 
        	spectral	 Reference code 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setconversiontype(self, *args, **kwargs)

    def getconversiontype(self, *args, **kwargs):
        """
        getconversiontype(self, type=string(""), showconversion=True) -> string

        Summary
        	Get extra reference conversion layer
           (aka conversiontype).  

        Description
        	  See conversiontype for more complete description.


        Input Parameters:
        	type		 Conversion type 
        	showconversion	 Show the conversion layer true 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_getconversiontype(self, *args, **kwargs)

    def setdirection(self, *args, **kwargs):
        """
        setdirection(self, refcode=string(""), proj=string(""), projpar=initialize_vector(1, (double)-1), refpix=initialize_vector(1, (double)-1), 
            refval=initialize_variant(""), incr=initialize_variant(""), 
            xform=initialize_variant(""), poles=initialize_variant("")) -> bool

        Summary
        	Set direction coordinate values

        Description
        	

        When you construct a Coordsys 	ool, if you include a Direction
        Coordinate, it  will have some default parameters.  
        This function simply allows you to
        replace the values of the Direction Coordinate.

        You can also change almost all of those parameters (such as projection, reference value
        etc.) via the individual functions 
        setreferencecode,
        setprojection,
        setreferencepixel,
        setreferencevalue,
        setincrement, and
        setlineartransform
        provided by the Coordsys 	ool.    See those functions for more details
        about the formatting of the above function arguments.

        Bear in mind, that if your Coordinate System came from a real image, then
        the reference pixel is special and you should not change it.



        Input Parameters:
        	refcode		 Reference code. Default is no change. 
        	proj		 Projection type. Default is no change. 
        	projpar		 Projection parameters. Default is no change. -1 
        	refpix		 Reference pixel. Default is no change. -1 
        	refval		 Reference value. Default is no change. 
        	incr		 Increment. Default is no change. 
        	xform		 Linear transform. Default is no change. 
        	poles		 Native poles. Default is no change. 
        	
        Example:
        	

        '''
        #
        print '	----	 setdirection Ex 1 	----'
        csys = cs.newcoordsys(direction=T);
        csys.setdirection (refcode='GALACTIC', proj='SIN', projpar=[0,0],
                           refpix=[-10,20], refval='10deg -20deg');
        print csys.projection()
        #{'type': 'SIN', 'parameters': array([ 0.,  0.])}
        print csys.referencepixel()
        #{'ar_type': 'absolute', 'pw_type': 'pixel', 'numeric': array([-10.,  20.])}
        print csys.referencevalue(format='s')
        #{'ar_type': 'absolute', 'pw_type': 'world', 
        # 'string': array(['10.00000000 deg', '-20.00000000 deg'], dtype='|S17')}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setdirection(self, *args, **kwargs)

    def setepoch(self, *args, **kwargs):
        """
        setepoch(self, value) -> bool

        Summary
        	Set a new epoch

        Description
        	

        This function  sets a new epoch (supplied as an
        epoch measure) of the observation. You
        can get the current epoch with function
        epoch.  



        Input Parameters:
        	value		 New epoch measure 
        	
        Example:
        	

        '''
        #
        print '	----	 setepoch Ex 1 	----'
        csys = cs.newcoordsys()
        ep = csys.epoch()
        print ep
        #{'type': 'epoch', 'm0': {'value': 54161.766782997685, 'unit': 'd'}, 'refer': 'UTC'}
        ep = me.epoch('UTC', 'today')
        csys.setepoch(ep)
        print csys.epoch()
        #{'type': 'epoch', 'm0': {'value': 54161.766782997685, 'unit': 'd'}, 'refer': 'UTC'}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setepoch(self, *args, **kwargs)

    def setincrement(self, *args, **kwargs):
        """
        setincrement(self, value=initialize_variant(""), type=string("")) -> bool

        Summary
        	Set the increment

        Description
        	

        Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate. 

        This function  allows you to set a new
        increment.   You should not do this on 'stokes' axes unless you are an
        adept or a big risk taker.

        You can set the increments either for all axes ({\stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.

        You may supply the increments in all of the formats described in
        the \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

        In addition, you can also supply the increments as  a quantity of vector
        of doubles.  For example {\stfaf qa.quantity([-1,2],'arcsec')}.

        You can recover the current increments with function
        increment. 



        Input Parameters:
        	value		 Increments 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all 
        	
        Example:
        	

        '''
        #
        print '	----	 setincrement Ex 1 	----'
        csys=cs.newcoordsys(direction=T, spectral=T)
        rv = csys.increment(format='q')
        print rv
        # {'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': -1.0, 'unit': '''},
        #              '*2': {'value': 1.0, 'unit': '''},
        #              '*3': {'value': 1000.0, 'unit': 'Hz'}}}
        rv2 = qa.quantity('4kHz');
        csys.setincrement(value=rv2, type='spec')
        print csys.increment(type='spec', format='q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 4000.0, 'unit': 'Hz'}}}
        csys.setincrement(value='5kHz', type='spec')
        print csys.increment(type='spec', format='q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 5000.0, 'unit': 'Hz'}}}
        print csys.increment(format='q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': -1.0, 'unit': '''},
        #              '*2': {'value': 1.0, 'unit': '''},
        #              '*3': {'value': 5000.0, 'unit': 'Hz'}}}
        csys.setincrement (value='-2' 2' 2e4Hz')
        print csys.increment(format='q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': -2.0, 'unit': '''},
        #              '*2': {'value': 2.0, 'unit': '''},
        #              '*3': {'value': 20000.0, 'unit': 'Hz'}}}
        #
        '''


        In the example we first recover the increments as a vector of
        quantities. We then create a quantity for a new value for the spectral
        coordinate increment.  Note we use units of kHz whereas the spectral
        coordinate is currently expressed in units of Hz.  We then set the
        increment for the spectral coordinate.  We then recover the increment
        again; you can see 4kHz has been converted to 4000Hz.  We also show
        how to set the increment using a string interface.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setincrement(self, *args, **kwargs)

    def setlineartransform(self, *args, **kwargs):
        """
        setlineartransform(self, type=string(""), value=initialize_variant("")) -> bool

        Summary
        	Set the linear transform

        Description
        	

        This function set the linear transform component.  For Stokes Coordinates
        this function will return T but do nothing.

        You can recover the current linear transform with function
        lineartransform. 



        Input Parameters:
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular'. Leave empty for all. 
        	value		 Linear transform 
        	
        Example:
        	

        '''
        #
        print '	----	 setlineartransform Ex 1 	----'
        csys = cs.newcoordsys(spectral=T, linear=3)
        xf = csys.lineartransform('lin')
        print xf
        #[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]
        xf[0]=list(xf[0])
        xf[0][1]=0.01
        #xf[0]=tuple(xf[0])
        csys.setlineartransform('lin',xf)
        print csys.lineartransform('lin')
        #[(1.0, 0.01, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setlineartransform(self, *args, **kwargs)

    def setnames(self, *args, **kwargs):
        """
        setnames(self, value, type=string("")) -> bool

        Summary
        	Set the axis names

        Description
        	

        Each axis associated with the Coordinate System has a name.
        It isn't used in any fundamental way.

        This function  allows you to set
        new axis names.

        You can set the names either for all axes ({\stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.

        You can recover the current axis names with function
        names. 



        Input Parameters:
        	value		 Names 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular' or leave empty for all 
        	
        Example:
        	

        '''
        #
        print '	----	 setnames Ex 1 	----'
        csys = cs.newcoordsys(spectral=T, linear=2)
        csys.setnames(value='a b c')
        print csys.names()
        #['a', 'b', 'c']
        csys.setnames('flying fish', 'lin')
        print csys.names()
        #['a', 'flying', 'fish']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setnames(self, *args, **kwargs)

    def setobserver(self, *args, **kwargs):
        """
        setobserver(self, value) -> bool

        Summary
        	Set a new observer

        Description
        	

        If you want to grab all the glory, or transfer the blame, this function
         sets a new observer of the
        observation. You can get the current observer with function observer.  The
        observer's name is not fundamental to the Coordinate System !



        Input Parameters:
        	value		 New observer 
        	
        Example:
        	

        '''
        #
        print '	----	 setobserver Ex 1 	----'
        csys = cs.newcoordsys()
        print csys.observer()
        #Karl Jansky 
        csys.setobserver('Ronald Biggs')
        print csys.observer()
        #Ronald Biggs 
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setobserver(self, *args, **kwargs)

    def setprojection(self, *args, **kwargs):
        """
        setprojection(self, type, parameters=initialize_vector(1, (double)-1)) -> bool

        Summary
        	Set the direction coordinate projection

        Description
        	

        If the Coordinate System contains a direction coordinate, this
        function  can be used to set the
        projection.  For discussion about celestial coordinate systems,
        including projections, see the papers by Mark Calabretta and Eric
        Greisen. The initial draft from 1996 (implemented in \casa) can be
        found
        \htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.

        You can use the function projection
        to find out all the possible types of projection.  You can also use it
        to find out how many parameters you need to describe a particular
        projection.  See Calabretta and Greisen for details about those
        parameters (see section 4 of their paper); in FITS terms these
        parameters are what are labelled as PROJP. 

        Some brief help here on the more common projections in astronomy.

        egin{itemize}

        \item SIN has either 0 parameters or 2.  For coplanar arrays like
        East-West arrays, one can use what is widely termed the NCP projection. 
        This is actually a SIN projection where the parameters are 0 and
        $1/tan(\delta_0)$ where $\delta_0$ is the reference declination.  Images
        made from the ATNF's Compact Array with \casa\ will have such a
        projection.  Otherwise, the SIN projection requires no parameters (but
        you can give it two each of which is zero if you wish).

        \item TAN is used widely in optical astronomy.  It requires 0
        parameters.

        \item ZEA (zenithal equal area) is used widely in survey work.
        It requires 0 parameters.

        nd{itemize}

        If the Coordinate System does not contain a direction coordinate,
        an exception is generated.



        Input Parameters:
        	type		 Type of projection 
        	parameters	 Projection parameters -1 
        	
        Example:
        	

        '''
        #
        print '	----	 Ex setprojection 1 	----'
        im = ia.maketestimage('cena',overwrite=true)
        csys = ia.coordsys()
        print csys.projection()
        #{'type': 'SIN', 'parameters': array([ 0.,  0.])}
        print csys.projection('ZEA')
        #{'nparameters': 0}
        csys.setprojection('ZEA')
        im2 = ia.regrid('cena.zea', csys=csys.torecord(), overwrite=true)
        #
        '''

        We change the projection of an image from SIN to 
        ZEA (which requires no parameters).

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setprojection(self, *args, **kwargs)

    def setreferencecode(self, *args, **kwargs):
        """
        setreferencecode(self, value, type=string("direction"), adjust=True) -> bool

        Summary
        	Set new reference code

        Description
        	

        This function  sets the reference
        code for the specified coordinate type.  Examples of reference codes
        are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.

        You must specify {\stfaf type}, selecting from 'direction',  or
        'spectral' (the first two letters will do).   If the Coordinate System
        does not contain a coordinate of the type you specify, an exception is
        generated.

        Specify the new code with argument {\stfaf value}.  To see the list of
        possible codes, use the function referencecode
        (see example).

        If {\stfaf adjust} is T, then the reference value is recomputed.
        This is invariably the correct thing to do.  If {\stfaf adjust} is F, 
        then the reference code is simply overwritten; do this very carefully.



        Input Parameters:
        	value		 Reference code 
        	type		 Coordinate type: direction or spectral direction 
        	adjust		 Adjust reference value ? true 
        	
        Example:
        	

        '''
        #
        print '	----	 Ex setreferencecode 1 	----'
        csys = cs.newcoordsys(direction=T)
        clist = csys.referencecode('dir', T)      # See possibilities
        print clist
        #['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN', 'BTRUE', 'GALACTIC',
        # 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO', 'AZELSWGEO', 'AZELNEGEO',
        # 'JNAT', 'ECLIPTIC', 'MECLIPTIC', 'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO',
        # 'ICRS', 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS',
        # 'NEPTUNE', 'PLUTO', 'SUN', 'MOON', 'COMET']
        print cs.referencecode('dir')
        #J2000
        cs.setreferencecode('B1950', 'dir', T)
        #
        '''


        In this example we first get the list of all possible reference codes
        for a direction coordinate.  Then we set the actual reference code for the direction
        coordinate in our Coordinate System.


        Example:
        	

        '''
        #
        print '	----	 Ex setreferencecode 2 	----'
        ia.maketestimage('myimage.j2000',overwrite=true)      # Open image
        csys = ia.coordsys()			              # Get Coordinate System
        print csys.referencecode('dir', F)
        #J2000
        csys.setreferencecode('B1950', 'dir', T)              # Set new direction system
        im2 = ia.regrid(outfile='myimage.b1950', csys=csys.torecord(),
                        overwrite=true)  # Regrid and make new image
        #
        '''


        In this example we show how to regrid an image from J2000
        to B1950.  First we recover the Coordinate System  into the Coordsys
        	ool\ called {\stf cs}.  We then set a new direction reference code,
        making sure we recompute the reference value.  Then the
        new Coordinate System is supplied in the regridding process
        (done with an Image 	ool).


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setreferencecode(self, *args, **kwargs)

    def setreferencelocation(self, *args, **kwargs):
        """
        setreferencelocation(self, pixel=initialize_vector(1, (int)-1), world=initialize_variant("-1"), mask=initialize_vector(1, (bool)false)) -> bool

        Summary
        	Set reference pixel and value

        Description
        	

        This function sets the reference pixel and
        reference value to the specified values.  The world coordinate can be
        specified in any of the formats that the output world coordinate is
        returned in by the toworld function. 

        You can specify a mask (argument {\stfaf mask}) indicating which pixel
        axes are set (T) and which are left unchanged (F).  This function will
        refuse to change the reference location of a Stokes axis (gets you into
        trouble otherwise). 

        This function can be rather useful when regridding
        images.  It allows you to keep easily a particular feature centered in the 
        regridded image.



        Input Parameters:
        	pixel		 New reference pixel. Defaults to old reference pixel. -1 
        	world		 New reference value. Defaults to old reference value. -1 
        	mask		 Indicates which axes to center. Defaults to all. false 
        	
        Example:
        	

        '''
        #
        print '	----	 setreferencelocation Ex 1 	----'
        csys = cs.newcoordsys(linear=2)
        print csys.referencepixel()
        #[0.0, 0.0]
        print csys.referencevalue()
        #{'numeric': array([ 0.,  0.])}
        w = csys.toworld([19,19], format='n')
        shp = [128,128]
        p = [64, 64]
        csys.setreferencelocation (pixel=p, world=w)
        print csys.referencepixel()
        #[64.0, 64.0]  
        print csys.referencevalue()
        #{'numeric': array([ 19.,  19.])}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setreferencelocation(self, *args, **kwargs)

    def setreferencepixel(self, *args, **kwargs):
        """
        setreferencepixel(self, value, type=string("")) -> bool

        Summary
        	Set the reference pixel

        Description
        	

        Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate. 

        This function allows you to set a new reference pixel.   You should not
        do this on 'stokes' axes unless you are an adept or a big risk taker.

        You can set the reference pixel either for all axes ({\stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.

        Bear in mind, that if your Coordinate System came from a real image,
        then the reference pixel is special and you should not change it for
        Direction Coordinates. 

        You can recover the current reference pixel with function
        referencepixel. 



        Input Parameters:
        	value		 Reference pixel 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular' or leave unset for all 
        	
        Example:
        	

        '''
        #
        print '	----	 setreferencepixel Ex 1 	----'
        csys = cs.newcoordsys(spectral=T, linear=2)
        csys.setreferencepixel(value=[1.0, 2.0, 3.0])
        print csys.referencepixel()
        #[1.0, 2.0, 3.0]
        csys.setreferencepixel([-1, -1], 'lin')
        print csys.referencepixel()
        #[1.0, -1.0, -1.0]
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setreferencepixel(self, *args, **kwargs)

    def setreferencevalue(self, *args, **kwargs):
        """
        setreferencevalue(self, value, type=string("")) -> bool

        Summary
        	Set the reference value

        Description
        	

        Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate. 

        This function allows you to set a new
        reference value.  You should not do this on 'stokes' axes unless you
        are an adept or a big risk taker.

        You may supply the reference value in all of the formats described in
        the \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

        You can recover the current reference value with function
        referencevalue. 

        Note that the value argument should be one of the specified
        possibilitioes. Especially a {\stff measure} will be accepted, but
        will have a null effect, due to the interpretation as a generic
        record.



        Input Parameters:
        	value		 Reference value 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabular' or leave empty for all. 
        	
        Example:
        	

        '''
        #
        print '	----	 setreferencevalue Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        rv = csys.referencevalue(format='q')
        print rv
        #{'quantity': {'*1': {'value': 0.0, 'unit': '''},
        # '*2': {'value': 0.0, 'unit': '''}, '*3': {'value': 1415000000.0, 'unit': 'Hz'}}}
        rv2 = rv['quantity']['*3']
        rv2['value'] = 2.0e9
        print rv2
        #{'value': 2000000000.0, 'unit': 'Hz'}
        csys.setreferencevalue(type='spec', value=rv2)
        print csys.referencevalue(format='n')
        #{'numeric': array([  0.00000000e+00,   0.00000000e+00,   2.00000000e+09])}
        #
        # To set a new direction reference value, the easiest way, given a
        # direction measure dr would be:
        dr = me.direction('j2000','30deg','40deg')
        # SHOULD BE SIMPLIFIED!!!
        newrv=csys.referencevalue(format='q')
        newrv['quantity']['*1']=dr['m0']
        newrv['quantity']['*2']=dr['m1']
        csys.setreferencevalue(value=newrv)
        print csys.referencevalue(format='q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 1800.0, 'unit': '''},
        #              '*2': {'value': 2399.9999999999995, 'unit': '''},
        #              '*3': {'value': 1415000000.0, 'unit': 'Hz'}}}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setreferencevalue(self, *args, **kwargs)

    def setrestfrequency(self, *args, **kwargs):
        """
        setrestfrequency(self, value, which=0, append=False) -> bool

        Summary
        	Set the rest frequency

        Description
        	

        If the Coordinate System contains a spectral coordinate, then
        it has a rest frequency.  In fact, the spectral coordinate
        can hold several rest frequencies (to handle for example,
        an observation where the band covers many lines), although
        only one is active (for velocity conversions) at a time.

        This function allows you to set new rest
        frequencies.  You can provide the rest frequency as a quantity, or as
        a quantity string, or a double (units of current rest frequency assumed).

        You specify whether the list of frequencies will be appended
        to the current list or whether it will replace that list.
        You must select which of the frequencies will become the active
        one.  By default its the first in the list.  The index refers
        to the final list (either appended or replaced).

        You can recover the current rest frequencies with
        restfrequency. 

        If the Coordinate System does not contain a frequency coordinate,
        an exception is generated.



        Input Parameters:
        	value		 New rest frequencies 
        	which		 Which is the active rest frequency 0 
        	append		 Append this list or overwrite ? false 
        	
        Example:
        	

        '''
        #
        print '	----	 setrestfrequency Ex 1 	----'
        csys = cs.newcoordsys(spectral=T)
        print csys.restfrequency()
        #{'value': array([  1.42040575e+09]), 'unit': 'Hz'}
        csys.setrestfrequency(qa.quantity('1.4GHz'))
        print csys.restfrequency()
        #{'value': array([  1.40000000e+09]), 'unit': 'Hz'}
        csys.setrestfrequency(1.3e9)
        print csys.restfrequency()
        #{'value': array([  1.30000000e+09]), 'unit': 'Hz'}
        csys.setrestfrequency (value=[1.2e9, 1.3e9], which=1)
        print csys.restfrequency()
        #{'value': array([  1.30000000e+09,   1.20000000e+09]), 'unit': 'Hz'}
        csys.setrestfrequency (qa.quantity([1,2],'GHz'), which=3, append=T)
        print csys.restfrequency()
        #{'value': array([  2.00000000e+09,   1.20000000e+09,   1.30000000e+09,
        #         1.00000000e+09]), 'unit': 'Hz'}
        csys.setrestfrequency ('1.4E9Hz 1667MHz')
        print csys.restfrequency()
        #{'value': array([  1.40000000e+09,   1.66700000e+09]), 'unit': 'Hz'}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setrestfrequency(self, *args, **kwargs)

    def setspectral(self, *args, **kwargs):
        """
        setspectral(self, refcode=string(""), restfreq=initialize_variant(""), frequencies=initialize_variant("1GHz"), 
            doppler=string(""), velocities=initialize_variant("1km/s")) -> bool

        Summary
        	Set tabular values for the spectral coordinate

        Description
        	

        When you construct a Coordsys 	ool, if you include a Spectral Coordinate, it 
        will be linear in frequency.  This function allows you to replace the
        Spectral Coordinate by a finite table of values.  Coordinate
        conversions between pixel and world are then done by interpolation.

        You may specify either a vector of frequencies or velocities.  If you specify
        frequencies, you can optionally specify a (new) reference code (see
        function setreferencecode
        for more details) and rest frequency (else the existing ones will be used).

        If you specify velocities, you can optionally specify a (new) reference code
        and rest frequency (else the existing ones will be used).  You must also give
        the doppler type (see
        function summary for more
        details).  The velocities are then converted to frequency for creation of the
        Spectral Coordinate (which is fundamentally described by frequency).

        You may specify the rest frequency as a Quantum or a double (native units
        of Spectral Coordinate used).



        Input Parameters:
        	refcode		 Reference code. Leave unset for no change. 
        	restfreq	 Rest frequency. Leave unset for no change. 
        	frequencies	 Vector of frequencies. Leave unset for no change. 1GHz 
        	doppler		 Doppler type. Leave unset for no change. 
        	velocities	 Vector of velocities types. Leave unset for no change. 1km/s 
        	
        Example:
        	

        print '	----	 setspectral Ex 1 	----'
        csys = cs.newcoordsys(spectral=T);
        f1 = [1,1.01,1.03,1.4]
        fq = qa.quantity(f1, 'GHz')
        csys.setspectral(frequencies=fq)
        v = csys.frequencytovelocity(f1, 'GHz', 'radio', 'km/s')
        print 'v=', v
        #v= [88731.317461076716, 86620.706055687479, 82399.483244909003, 4306.8612455073862]
        vq = qa.quantity(v, 'km/s')
        csys.setspectral(velocities=vq, doppler='radio')
        f2 = csys.velocitytofrequency(v, 'GHz', 'radio', 'km/s')
        print 'f1 = ', f1
        #f1 =  [1, 1.01, 1.03, 1.3999999999999999]
        print 'f2 = ', f2
        #f2 =  [1.0, 1.01, 1.03, 1.3999999999999999]

        We make a linear Spectral Coordinate.  Then overwrite it with
        a list of frequenices.  Convert those values to velocity,
        then overwrite the coordinate starting with a list of
        velocities. Then convert the velocities to frequency
        and show we get the original result.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setspectral(self, *args, **kwargs)

    def setstokes(self, *args, **kwargs):
        """
        setstokes(self, stokes) -> bool

        Summary
        	Set the Stokes types

        Description
        	

        If the Coordinate System contains a Stokes Coordinate, this function allows
        you to change the Stokes types defining it.  If there is no Stokes
        Coordinate, an exception is generated.

        See the coordsys constructor
        to see the possible Stokes types you can set.

        You can set the Stokes types with function
        setstokes. 



        Input Parameters:
        	stokes		 Stokes types 
        	
        Example:
        	

        '''
        #
        print '	----	 setstokes Ex 1 	----'
        csys = cs.newcoordsys(stokes='I V')
        print csys.stokes()
        #['I', 'V']
        csys.setstokes('XX RL')
        print csys.stokes()
        #['XX', 'RL']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setstokes(self, *args, **kwargs)

    def settabular(self, *args, **kwargs):
        """
        settabular(self, pixel=initialize_vector(1, (double)-1), world=initialize_vector(1, (double)-1), which=0) -> bool

        Summary
        	Set tabular values for the tabular coordinate

        Description
        	

        When you construct a Coordsys 	ool, if you include a Tabular
        Coordinate, it will be linear.  This function allows you to replace the
        Tabular Coordinate by a finite table of values.  Coordinate conversions
        between pixel and world are then done by interpolation (or extrapolation
        beyond the end).  The table of values must be at least of length 2
        or an exception will occur.

        You may specify a vector of pixel and world values (in the current units
        of the Tabular Coordinate).  These vectors must be the same length.  If
        you leave one of them unset, then the old values are used, but again,
        ultimately, the pixel and world vectors must be the same length. 

        The new reference pixel will be the first pixel value.
        The new reference value will be the first world value.

        Presently, there is no way for you to recover the lookup table
        once you have set it.

        If you have more than one Tabular Coordinate, use argument
        {\stfaf which} to specify which one you want to modify.



        Input Parameters:
        	pixel		 Vector of (0-rel) pixel values. Default is no change. -1 
        	world		 Vector of world values. Default is no change. -1 
        	which		 Which Tabular coordinate 0 
        	
        Example:
        	

        '''
        #
        print '	----	 settabular Ex 1 	----'
        csys = cs.newcoordsys(tabular=T);
        print csys.settabular (pixel=[1,10,15,20,100], world=[10,20,50,100,500])
        #True
        #
        '''

        We make a linear Tabular Coordinate.  Then overwrite it with
        a non-linear list of pixel and world values.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_settabular(self, *args, **kwargs)

    def settelescope(self, *args, **kwargs):
        """
        settelescope(self, value) -> bool

        Summary
        	Set a new telescope

        Description
        	

        This function sets a new telescope of the observation.   The telescope
        position may be needed for reference code conversions; this is why it is
        maintained in the Coordinate System.    So it is fundamental
        to the Coordinate System and should be correct.

        You can find a list of the observatory names know to \casa\ with the
        Measures obslist function.

        You can  get the current telescope with function
        telescope.   



        Input Parameters:
        	value		 New telescope 
        	
        Example:
        	

        '''
        #
        print '	----	 settelescope Ex 1 	----'
        csys = cs.newcoordsys()
        print csys.telescope()
        #ATCA
        csys.settelescope('VLA')
        print csys.telescope()
        #VLA
        csys.settelescope('The One In My Backyard')
        #Tue Mar 6 21:41:24 2007      WARN coordsys::settelescope:
        #This telescope is not known to the casapy system
        #You can request that it be added
        print me.obslist()
        #ALMA ARECIBO ATCA BIMA CLRO DRAO DWL GB GBT GMRT IRAM PDB IRAM_PDB
        # JCMT MOPRA MOST NRAO12M NRAO_GBT PKS SAO SMA VLA VLBA WSRT
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_settelescope(self, *args, **kwargs)

    def setunits(self, *args, **kwargs):
        """
        setunits(self, value, type=string(""), overwrite=False, which=-10) -> bool

        Summary
        	Set the axis units

        Description
        	

        Each axis associated with the Coordinate System has a unit. This
        function allows you to set new axis units.    

        You can set the units either for all axes ({\stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.

        In general, the units must be consistent with the old units. When you
        change the units, the increment and reference value will be adjusted
        appropriately.  However, for a linear or tabular coordinate, and only
        when you specify {\stfaf type='linear'} or {\stfaf type='tabular'} 
        (i.e. you supply units only for the specified linear of tabular
        coordinate), and if you set {\stfaf overwrite=T}, you can just overwrite
        the units with no further adjustments.   Otherwise, the {\stfaf
        overwrite} argument will be silently ignored.  Use argument
        {\stfaf which} to specify which coordinate if you have more
        than one of the specified type.

        You can recover the current axis units with function
        units. 



        Input Parameters:
        	value		 Units 
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear', 'tabules' or leave unset for all. 
        	overwrite	 Overwrite linear or tabular coordinate units? false 
        	which		 Which coordinate if more than one of same type. Default is first. -10 
        	
        Example:
        	

        '''
        #
        print '	----	 setunits Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        csys.summary()
        csys.setunits(value='deg rad mHz');
        csys.summary()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setunits(self, *args, **kwargs)

    def stokes(self):
        """
        stokes(self) -> std::vector< std::string >

        Summary
        	Recover the Stokes types

        Description
        	

        If the Coordinate System contains a Stokes Coordinate, this function recovers the
        Stokes types defining it.  If there is no Stokes
        Coordinate, an exception is generated.

        You can set the Stokes types with function
        setstokes. 


        Example:
        	

        '''
        #
        print '	----	 stokes Ex 1 	----'
        csys = cs.newcoordsys(stokes=['I','V'])
        print csys.stokes()
        #['I', 'V']
        csys = cs.newcoordsys(stokes='Q U')
        print csys.stokes()
        #['Q', 'U']
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_stokes(self)

    def summary(self, *args, **kwargs):
        """
        summary(self, doppler=string("RADIO"), list=True) -> std::vector< std::string >

        Summary
        	Summarize basic information about the Coordinate System

        Description
        	

        This function summarizes the information
        contained in the Coordinate System. 
            
        For spectral coordinates, the information is listed as a velocity as well as a
        frequency.  The argument {\stfaf doppler} allows you to specify what
        doppler convention it is listed in.  You can choose from {\stfaf radio,
        optical} and {\stfaf beta}.  Alternative names are {\stfaf z} for
        {\stfaf optical}, and {\stfaf relativistic} for {\stfaf
        beta}.  The default is {\stfaf radio}.  The definitions are

        egin{itemize}
        \item radio: $1 - F$
        \item optical: $-1 + 1/F$
        \item beta: $(1 - F^2)/(1 + F^2)$
        nd{itemize}
        where $F = 
        u/
        u_0$ and $
        u_0$ is the rest frequency.  If the rest
        frequency has not been set in your image, you can set it with
        the function setrestfrequency.

        These velocity definitions are provided by the measures
        system via the Doppler measure (see example).

        If you  set {\stfaf list=F}, then the summary will not be written
        to the global logger.     However, the return value will be a vector of strings
        holding the summary information, one string per line of the summary.

        For direction and spectral coordinates, the reference frame (e.g.  J2000
        or LSRK) is also listed.  Along side this, in parentheses, will be the
        conversion reference frame as well (if it is different from the native
        reference frame).  See function
        setconversion to see what this
        means. 



        Input Parameters:
        	doppler		 List velocity information with this doppler definition RADIO 
        	list		 List to global logger true 
        	
        Example:
        	

        '''
        #
        print '	----	 summary Ex 1 	----'
        d = me.doppler('beta')
        print me.listcodes(d)
        #[normal=RADIO Z RATIO BETA GAMMA OPTICAL TRUE RELATIVISTIC, extra=] 
        csys = cs.newcoordsys(direction=T, spectral=T)
        print csys.summary(list=F)
        #
        #Direction reference : J2000
        #Spectral  reference : LSRK
        #Velocity  type      : RADIO
        #Rest frequency      : 1.42041e+09 Hz
        #Telescope           : ATCA
        #Observer            : Karl Jansky
        #Date observation    : 2007/07/14/04:49:31
        #
        #Axis Coord Type      Name             Proj   Coord value at pixel    Coord incr Units
        #-------------------------------------------------------------------------------------
        #0    0     Direction Right Ascension   SIN  00:00:00.000     0.00 -6.000000e+01 arcsec
        #1    0     Direction Declination       SIN +00.00.00.000     0.00  6.000000e+01 arcsec
        #2    1     Spectral  Frequency                 1.415e+09     0.00  1.000000e+03 Hz
        #                     Velocity                    1140.94     0.00 -2.110611e-01 km/s
        #
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_summary(self, *args, **kwargs)

    def telescope(self):
        """
        telescope(self) -> string

        Summary
        	Return the telescope

        Description
        	

        This function returns the telescope
        contained in the Coordinate System  as a
        simple string. 

        The telescope position may be needed for reference code conversions; this is
        why it is maintained in the Coordinate System.  

        The conversion from string to position is done with
        Measures observatory.
        The example shows how.  


        Example:
        	

        '''
        #
        print '	----	 telescope Ex 1 	----'
        csys = cs.newcoordsys()
        print csys.telescope()
        #ATCA
        print me.observatory(csys.telescope())
        #{'type': 'position', 'refer': 'ITRF',
        # 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
        # 'm0': {'value': 2.6101423190348916, 'unit': 'rad'},
        # 'm2': {'value': 6372960.2577234386, 'unit': 'm'}}
        #
        '''


        We get the telescope as a string. 
         The Measures system is used to convert from
        the simple name to a position Measure.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_telescope(self)

    def toabs(self, *args, **kwargs):
        """
        toabs(self, value, isworld=-1) -> record *

        Summary
        	Convert relative coordinate to absolute

        Description
        	

        This function converts a relative coordinate to an absolute coordinate.
        The coordinate may be a pixel coordinate or a world coordinate.

        If the coordinate is a pixel coordinate, it is supplied as a numeric
        vector. If the coordinate is a world coordinate,  you may give it in all
        of the formats described in the
        \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

        If the coordinate value is supplied by a Coordsys 	ool\ function (e.g.
        toworld) then the coordinate 'knows'
        whether it is world or pixel (and absolute or relative). However, you
        might supply the value from some other source as a numeric vector (which
        could be world or pixel) in which case you must specify whether it is a 
        world or pixel coordinate via the {\stfaf isworld} argument.



        Input Parameters:
        	value		 Relative coordinate 
        	isworld		 Is coordinate world or pixel? Default is unset. -1 
        	
        Example:
        	

        '''
        #
        print '	----	 toabs Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        aw = csys.toworld([100,100,24], 's')
        rw = csys.torel(aw)
        aw2 = csys.toabs(rw)
        print aw
        #{'ar_type': 'absolute', 'pw_type': 'world', 
        # 'string': array(['23:53:19.77415678', '+01.40.00.84648186',
        #                  '1.41502400e+09 Hz'], dtype='|S19')}
        print rw
        #{'ar_type': 'relative', 'pw_type': 'world',
        # 'string': array(['-6.00084720e+03 arcsec', '6.00084648e+03 arcsec',
        #                  '2.40000000e+04 Hz'], dtype='|S23')}
        print aw2
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'string': array(['23:53:19.77415672', '+01.40.00.84648000',
        #                  '1.41502400e+09 Hz'], dtype='|S19')}
        #
        '''


        This example uses world coordinates.

        Example:
        	

        '''
        #
        print '	----	 toabs Ex 2 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        ap = csys.topixel()           # Reference value
        rp = csys.torel(ap)
        ap2 = csys.toabs(rp)
        print ap
        #{'ar_type': 'absolute', 'pw_type': 'pixel', 'numeric': array([ 0.,  0.,  0.])}
        print rp
        #{'ar_type': 'relative', 'pw_type': 'world',
        #     'numeric': array([  0.00000000e+00,   0.00000000e+00,  -1.41500000e+09])}
        print ap2
        #{'ar_type': 'absolute', 'pw_type': 'world', 'numeric': array([ 0.,  0.,  0.])}
        #
        '''

        This example uses pixel coordinates.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_toabs(self, *args, **kwargs)

    def toabsmany(self, *args, **kwargs):
        """
        toabsmany(self, value, isworld=-1) -> record *

        Summary
        	Convert many numeric relative coordinates to absolute

        Description
        	

        This function converts many relative coordinates to absolute. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with toabs). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to accept strings and quanta etc. like
        toabs can.  

        When dealing with world coordinates, the units of the numeric
        values must be the native units, given by function
        units.



        Input Parameters:
        	value		 Relative coordinates 
        	isworld		 Is coordinate world or pixel? Default is unset. -1 
        	
        Example:
        	

        '''
        #
        print '	----	 toabsmany Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)    # 3 axes
        rv = csys.referencevalue();                 # reference value
        w = csys.torel(rv)                          # make relative
        inc = csys.increment();                     # increment
        off=[]
        for idx in range(100):
          off.append(inc['numeric'][2]*idx)         # offset for third axis
        wrel = ia.makearray(0,[3,100])              # 100 conversions each of length 3
        for i in range(3):
          for j in range(100):
            wrel[i][j]=w['numeric'][i]
        for j in range(100):
          wrel[2][j] += off[j]                      # Make spectral axis values change
        wabs  = csys.toabsmany (wrel, T)['numeric'] # Convert
        print wabs[0][0],wabs[1][0],wabs[2,0]       # First absolute coordinate
        #0.0 0.0 1415000000.0
        print wabs[0][99],wabs[1][99],wabs[2][99]   # 100th absolute coordinate
        #0.0 0.0 1415099000.0
        #
        '''

        This example uses world coordinates.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_toabsmany(self, *args, **kwargs)

    def topixel(self, *args, **kwargs):
        """
        topixel(self, value) -> record *

        Summary
        	Convert from absolute world to pixel coordinate

        Description
        	

        This function converts between world (physical) coordinate and absolute pixel
        coordinate (0-rel).

        The world coordinate can be provided in one of four formats via the
        argument {\stfaf world}.  These match the output formats of function
        toworld.

        If you supply fewer world values than there are axes in the  Coordinate
        System, your coordinate vector will be padded out with the reference
        value for the missing axes. Excess values will be silently ignored.

        You may supply the world coordinate in all of the formats described in
        the \htmlref{formatting}{COORDSYS:FORMATTING} discussion.



        Input Parameters:
        	value		 Absolute world coordinate 
        	
        Example:
        	

        '''
        #
        print '	----	 topixel Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T, stokes='I V', linear=2)
        w = csys.toworld([-2,2,1,2,23,24], 'n')
        print csys.topixel(w)
        #{'ar_type': 'absolute', 'pw_type': 'pixel',
        # 'numeric': array([ -2.,   2.,   1.,   2.,  23.,  24.])}
        w = csys.toworld([-2,2,1,2,23,24], 'q')
        print csys.topixel(w)
        #{'ar_type': 'absolute', 'pw_type': 'pixel',
        # 'numeric': array([ -2.,   2.,   1.,   2.,  23.,  24.])}
        w = csys.toworld([-2,2,1,2,23,24], 'm')
        print csys.topixel(w)
        #{'ar_type': 'absolute', 'pw_type': 'pixel',
        # 'numeric': array([ -2.,   2.,   1.,   2.,  23.,  24.])}
        w = csys.toworld([-2,2,1,2,23,24], 's')
        print cs.topixel(w)
        #{'ar_type': 'absolute', 'pw_type': 'pixel',
        # 'numeric': array([ -2.,   2.,   1.,   2.,  23.,  24.])}
        w = csys.toworld([-2,2,1,2,23,24], 'mnq')
        print cs.topixel(w)                            
        #{'ar_type': 'absolute', 'pw_type': 'pixel',
        # 'numeric': array([ -2.,   2.,   1.,   2.,  23.,  24.])}
        #
        '''


        Example:
        	

        '''
        #
        print '	----	 topixel Ex 2 	----'
        csys = cs.newcoordsys (stokes='I V', linear=2)
        print csys.toworld([0,1,2], 's')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'string': array(['I', '1.00000000e+00 km', '2.00000000e+00 km'],
        #  dtype='|S18')}
        print csys.toworld([0,1,2], 'm')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'measure': {'stokes': 'I', 'linear': {'*1': {'value': 1.0, 'unit': 'km'},
        # '*2': {'value': 2.0, 'unit': 'km'}}}}
        print csys.toworld([0,1,2], 'q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 1.0, 'unit': ''},
        # '*2': {'value': 1.0, 'unit': 'km'}, '*3': {'value': 2.0, 'unit': 'km'}}}
        #
        '''


        Example:
        	

        '''
        #
        print '	----	 topixel Ex 3 	----'
        csys = cs.newcoordsys (spectral=T, linear=1)
        print csys.toworld([0,1,2], 'q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 1415000000.0, 'unit': 'Hz'},
        # '*2': {'value': 1.0, 'unit': 'km'}}}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_topixel(self, *args, **kwargs)

    def topixelmany(self, *args, **kwargs):
        """
        topixelmany(self, value) -> record *

        Summary
        	Convert many absolute numeric world coordinates to pixel

        Description
        	

        This function converts many absolute world coordinates to pixel coordinates. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with topixel). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to accept strings and quanta etc. like
        topixel can.  

        The units of the numeric values must be the native units, given by
        function units.



        Input Parameters:
        	value		 Absolute world coordinates 
        	
        Example:
        	

        '''
        #
        print '	----	 topixelmany Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)    # 3 axes
        rv = csys.referencevalue();                 # reference value
        inc = csys.increment();                     # increment
        off = []
        for idx in range(100):
          off.append(inc['numeric'][2] * idx)       # offset for third axis
        wabs = ia.makearray(0, [3,100])             # 100 conversions each of length 3
        for i in range(3):
          for j in range(100):
            wabs[i][j]=rv['numeric'][i]
        for j in range(100):
          wabs[2][j] += off[j]                      # Make spectral axis values change
        pabs  = csys.topixelmany (wabs)['numeric']; # Convert
        print pabs[0][0], pabs[1][0], pabs[1][2]    # First absolute pixel coordinate
        #0.0 0.0 0.0
        print pabs[0][99], pabs[1][99], pabs[2][99] # 100th absolute pixel coordinate
        #0.0 0.0 99.0
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_topixelmany(self, *args, **kwargs)

    def torecord(self):
        """
        torecord(self) -> record *

        Summary
        	Convert Coordinate System to a record

        Description
        	

        You can convert a Coordinate System to a record with this function.
        There is also fromrecord
        to set a Coordinate System from a record.

        These functions  allow
        Coordsys 	ools\ to be used as parameters in the methods of other tools.



        Example:
        	

        '''
        #
        print '	----	 torecord Ex 1 	----'
        csys = cs.newcoordsys(direction=T, stokes='I Q')
        rec = csys.torecord();
        cs2 = cs.newcoordsys();
        print cs2.ncoordinates()
        #0
        cs2.fromrecord(rec);
        print csys.ncoordinates(), cs2.ncoordinates()
        #2 2
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_torecord(self)

    def subimage(self, *args, **kwargs):
        """
        subimage(self, originshft, newshape=std::vector< int >()) -> record *

        Summary
        	delivers a coordinate origin re-referenced for a subimage

        Description
        	

          You can convert a Coordinate System to another coordinatesystem applicable to a
          subImage. The newshape does not matter as this is the coordinatesystem not the 
          image except for Stokes axis; therefore you can ignore {	t newshape} except 
          when your sub-image you are considering has only a section of your original Stokes 
          axis.




        Input Parameters:
        	originshft	 The shift value from original reference (vector of values in pixels) 
        	newshape	 The new shape of the image it will applicable to (pixel shape) 
        	
        Example:
        	

        '''
        #
        print '	----	 subimage Ex 1 	----'
        ia.open('original.image')
        csys = ia.coordsys()
        imshape=ia.shape()
        #want to make an empty sub image of the 11th channel
        #keeping other reference pixel as is
        refshft=[0,0,0,10]
        subcoordsysrec=csys.subimage(neworigin=refshft)
        imshape[3]=1
        ia.fromshape(outfile='Eleventh_chan_template.image', shape=imshape, csys=subcoordsysrec)

        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_subimage(self, *args, **kwargs)

    def torel(self, *args, **kwargs):
        """
        torel(self, value, isworld=-1) -> record *

        Summary
        	Convert absolute coordinate to relative

        Description
        	

        This function converts an absolute coordinate to a relative coordinate.
        The coordinate may be a pixel coordinate or a world coordinate.

        Relative coordinates are relative to the reference pixel (pixel coordinates)
        or the reference value (world coordinates) in the sense 
        $relative = absolute - reference$.

        If the coordinate is a pixel coordinate, it is supplied as a numeric
        vector. If the coordinate is a world coordinate,  you may give it in all
        of the formats described in the
        \htmlref{formatting}{COORDSYS:FORMATTING} discussion.

        If the coordinate value is supplied by a Coordsys 	ool\ function (e.g.
        toworld) then the coordinate 'knows'
        whether it is world or pixel (and absolute or relative). However, you
        might supply the value from some other source as a numeric vector (which
        could be world or pixel) in which case you must specify whether it is a 
        world or pixel coordinate via the {\stfaf isworld} argument.



        Input Parameters:
        	value		 Absolute coordinate 
        	isworld		 Is coordinate world or pixel? Default is unset. -1 
        	
        Example:
        	

        '''
        #
        print '	----	 torel Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        aw = csys.toworld([99,99,23], 's')
        rw = csys.torel(aw)
        aw2 = csys.toabs(rw)
        print aw
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'string': array(['23:53:23.78086843', '+01.39.00.82133427',
        # '1.41502300e+09 Hz'], dtype='|S19')}
        print rw
        #{'ar_type': 'relative', 'pw_type': 'world',
        # 'string': array(['-5.94082202e+03 arcsec', '5.94082133e+03 arcsec',
        # '2.30000000e+04 Hz'], dtype='|S23')}
        print aw2
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'string': array(['23:53:23.78086818', '+01.39.00.82133000',
        # '1.41502300e+09 Hz'], dtype='|S19')}
        #
        '''


        This example uses world coordinates.


        '''
        #
        print '	----	 torel Ex 2 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        ap = csys.topixel()           # Reference value
        rp = csys.torel(ap)
        ap2 = csys.toabs(rp)
        print ap
        #{'ar_type': 'absolute', 'pw_type': 'pixel', 'numeric': array([ 0.,  0.,  0.])}
        print rp
        #{'ar_type': 'relative', 'pw_type': 'pixel', 'numeric': array([ 0.,  0.,  0.])}
        print ap2
        #{'ar_type': 'absolute', 'pw_type': 'pixel', 'numeric': array([ 0.,  0.,  0.])}
        #
        '''

        This example uses pixel coordinates.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_torel(self, *args, **kwargs)

    def torelmany(self, *args, **kwargs):
        """
        torelmany(self, value, isworld=-1) -> record *

        Summary
        	Convert many numeric absolute coordinates to relative

        Description
        	

        This function converts many absolute coordinates to relative. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with torel). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to accept strings and quanta etc. like
        torel can.  

        When dealing with world coordinates, the units of the numeric
        values must be the native units, given by function
        units.



        Input Parameters:
        	value		 Absolute coordinates 
        	isworld		 Is coordinate world or pixel? Default is unset. -1 
        	
        Example:
        	

        '''
        #
        print '	----	 torelmany Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)    # 3 axes
        w = csys.referencevalue();                  # reference value
        inc = csys.increment();                     # increment
        off = []
        for idx in range(100):
          off.append(inc['numeric'][2] * idx)       # offset for third axis
        wabs = ia.makearray(0, [3,100])             # 100 conversions each of length 3
        for i in range(3):
          for j in range(100):
            wabs[i][j] = w['numeric'][i]
        for j in range(100):
          wabs[2][j] += off[j]                      # Make spectral axis values change
        wrel  = cs.torelmany (wabs, T)['numeric']   # Convert
        print wrel[0][0], wrel[1][0], wrel[2][0]    # First relative coordinate
        #0.0 0.0 0.0
        print wrel[0][99], wrel[1][99], wrel[2][99] # 100th relative coordinate
        #0.0 0.0 99000.0
        #
        '''

        This example uses world coordinates.

        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_torelmany(self, *args, **kwargs)

    def toworld(self, *args, **kwargs):
        """
        toworld(self, value=initialize_variant(""), format=string("n")) -> record *

        Summary
        	Convert from absolute pixel coordinate to world

        Description
        	

        This function converts between absolute pixel coordinate (0-rel)
        and absolute world (physical coordinate).

        If you supply fewer pixel values than there are axes in the  Coordinate
        System, your coordinate vector will be padded out with the reference
        pixel for the missing axes. Excess values will be silently ignored.

        You may ask for the world coordinate in all of the formats described in
        the \htmlref{discussion}{COORDSYS:FORMATTING} regarding the
        formatting possibilities available via argument {\stfaf format}.



        Input Parameters:
        	value		 Absolute pixel coordinate. Default is reference pixel. 
        	format		 Format string: combination of 'n', 'q', 's', 'm' n 
        	
        Example:
        	

        '''
        #
        print '	----	 toworld Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        print csys.toworld([-3,1,1], 'n')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'numeric': array([  3.00000051e+00,   1.00000001e+00,   1.41500100e+09])}
        print csys.toworld([-3,1,1], 'q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 3.0000005076962117, 'unit': '''},
        #              '*2': {'value': 1.0000000141027674, 'unit': '''},
        #              '*3': {'value': 1415001000.0, 'unit': 'Hz'}}}
        print csys.toworld([-3,1,1], 'm')
        #{'ar_type': 'absolute', 'pw_type': 'world', 'measure':
        # {'spectral': {'radiovelocity': {'type': 'doppler', 'm0': {'value': 1140733.0762829871, 'unit': 'm/s'}, 'refer': 'RADIO'},
        #             'opticalvelocity': {'type': 'doppler', 'm0': {'value': 1145090.2316004676, 'unit': 'm/s'}, 'refer': 'OPTICAL'},
        #                 'frequency': {'type': 'frequency', 'm0': {'value': 1415001000.0, 'unit': 'Hz'}, 'refer': 'LSRK'},
        #                'betavelocity': {'type': 'doppler', 'm0': {'value': 1142903.3485169839, 'unit': 'm/s'}, 'refer': 'TRUE'}},
        # 'direction': {'type': 'direction', 'm1': {'value': 0.0002908882127680503, 'unit': 'rad'},
        #                                    'm0': {'value': 0.00087266477368000634, 'unit': 'rad'}, 'refer': 'J2000'}}}
        print csys.toworld([-3,1,1], 's')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'string': array(['00:00:12.00000203', '+00.01.00.00000085', '1.41500100e+09 Hz'], dtype='|S19')}
        #
        '''


        Example:
        	

        '''
        #
        print '	----	 toworld Ex 2 	----'
        csys = cs.newcoordsys (stokes='I V', linear=2)
        print csys.toworld([0,1,2], 's')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'string': array(['I', '1.00000000e+00 km', '2.00000000e+00 km'],
        #      dtype='|S18')}
        print csys.toworld([0,1,2], 'm')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'measure': {'stokes': 'I', 'linear': {'*1': {'value': 1.0, 'unit': 'km'},
        #                                       '*2': {'value': 2.0, 'unit': 'km'}}}}
        print csys.toworld([0,1,2], 'q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 1.0, 'unit': ''},
        #              '*2': {'value': 1.0, 'unit': 'km'},
        #              '*3': {'value': 2.0, 'unit': 'km'}}}
        #
        '''


        Example:
        	

        '''
        #
        print '	----	 toworld Ex 3 	----'
        csys = cs.newcoordsys (spectral=T, linear=1)
        print cs.toworld([0,1,2], 'q')
        #{'ar_type': 'absolute', 'pw_type': 'world',
        # 'quantity': {'*1': {'value': 1415000000.0, 'unit': 'Hz'},
        #              '*2': {'value': 1.0, 'unit': 'km'}}}
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_toworld(self, *args, **kwargs)

    def toworldmany(self, *args, **kwargs):
        """
        toworldmany(self, value) -> record *

        Summary
        	Convert many absolute pixel coordinates to numeric world

        Description
        	

        This function converts many absolute pixel coordinates to world coordinates. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with toworld). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to produce strings and quanta etc. like
        toworld can.  

        The units of the output world values are the native units given by
        function units.



        Input Parameters:
        	value		 Absolute pixel coordinates 
        	
        Example:
        	

        '''
        #
        print '	----	 toworldmany Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)    # 3 axes
        rp = csys.referencepixel()['numeric'];            # reference pixel
        pabs = ia.makearray(0,[3,100])              # 100 conversions each of length 3
        for i in range(3):
          for j in range(100):
            pabs[i][j] = rp[i]
        for ioff in range(100):                     # offset for third axis
          pabs[2][ioff] += ioff;                    # Make spectral axis values change
        wabs  = csys.toworldmany (pabs)['numeric']; # Convert
        print wabs[0][0], wabs[1][0], wabs[2][0]    # First absolute pixel coordinate
        #0.0 0.0 1415000000.0
        print wabs[0][99], wabs[1][99], wabs[2][99] # 100th absolute pixel coordinate
        #0.0 0.0 1415099000.0
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_toworldmany(self, *args, **kwargs)

    def type(self):
        """
        type(self) -> string

        Summary
        	Return the type of this tool

        Description
        	

        This function returns the string `coordsys'.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_type(self)

    def units(self, *args, **kwargs):
        """
        units(self, type=string("")) -> std::vector< std::string >

        Summary
        	Recover the units for each axis

        Description
        	

        Each axis associated with the Coordinate System has a unit.
        This function returns those units
        (in world axis order).

        You can recover the units either for all coordinates (leave {\stfaf
        type} unset) or for a specific coordinate type (mimumum match of the
        allowed types will do).  If you ask for a non-existent coordinate an
        exception is generated.

        You can set the units with function
        setunits.



        Input Parameters:
        	type		 Coordinate type: 'direction', 'stokes', 'spectral', 'linear' or leave unset for all 
        	
        Example:
        	  

        '''
        #
        print '	----	 units Ex 1 	----'
        csys = cs.newcoordsys(direction=T, spectral=T)
        print csys.units()
        #[''', ''', 'Hz']
        print csys.units('spec')
        #Hz
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_units(self, *args, **kwargs)

    def velocitytofrequency(self, *args, **kwargs):
        """
        velocitytofrequency(self, value, frequnit=string(""), doppler=string("radio"), velunit=string("km/s")) -> std::vector< double >

        Summary
        	Convert velocity to frequency

        Description
        	

        This function converts velocities
        to frequencies.

        The input velocities are specified via a vector of numeric values, a
        specified unit ({\stfaf velunit}), and a  velocity doppler definition ({\stfaf
        doppler}).

        The frequencies are returned in a vector for which you specify the
        units ({\stfaf frequnit}).  If you don't give the unit, it is assumed that 
        the units are those given by function units 
        for the spectral coordinate.

        This function will return a fail if there is no spectral coordinate
        in the Coordinate System. See also the function
        frequencytovelocity.



        Input Parameters:
        	value		 Velocity to convert 
        	frequnit	 Unit of output frequencies. Default is intrinisic units. 
        	doppler		 Velocity doppler definition radio 
        	velunit		 Unit of input velocities km/s 
        	
        Example:
        	

        '''
        #
        print '	----	 velocitytofrequency Ex 1 	----'
        ia.fromshape('hcn.cube',[64,64,32,4], overwrite=true)
        csys = ia.coordsys()
        rtn = csys.findcoordinate('spectral')   # Find spectral axis
        pixel = csys.referencepixel();          # Use reference pixel for non-spectral
        pa = rtn['pixel']
        wa = rtn['world']
        nFreq = ia.shape()[pa]                  # Length of spectral axis
        freq = []
        for i in range(nFreq):
          pixel[pa] = i;                        # Assign value for spectral axis of pixel coordinate
          w = csys.toworld(value=pixel, format='n')# Convert pixel to world
          freq.append(w['numeric'][wa])         # Fish out frequency
        print 'freq=', freq
        vel = csys.frequencytovelocity(value=freq, doppler='optical', velunit='km/s')
        freq2 = csys.velocitytofrequency(value=vel, doppler='optical', velunit='km/s')
        print 'vel=',vel
        print 'freq2=',freq2
        csys.done()
        #
        exit() # This is last example so exit casapy if you wish.
        #
        '''


        In this example, we find the optical velocity in km/s of every pixel
        along the spectral axis of our image.  First we  obtain the Coordinate
        System from the image.  Then we find which axis of the Coordinate System
        (image) pertain to the spectral coordinate.  Then we loop over each
        pixel of the spectral axis, and convert a pixel coordinate (one for each
        axis of the image) to world.  We obtain the value for the spectral axis
        from that world vector, and add it to the vector of frequencies.  Then
        we convert that vector of frequencies to velocity.  Then we convert it
        back to frequency.  They better agree.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_velocitytofrequency(self, *args, **kwargs)

    def parentname(self):
        """
        parentname(self) -> string

        Summary
        	Get parent image name.

        Description
        	

        This function returns the parent image name for `coordsys'.


        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_parentname(self)

    def setparentname(self, *args, **kwargs):
        """
        setparentname(self, imagename) -> bool

        Summary
        	Set the parent image name (normally not needed by end-users)

        Input Parameters:
        	imagename	 String named parent image 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _coordsys.coordsys_setparentname(self, *args, **kwargs)

coordsys_swigregister = _coordsys.coordsys_swigregister
coordsys_swigregister(coordsys)

# This file is compatible with both classic and new-style classes.


