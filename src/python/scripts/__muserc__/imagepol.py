# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_imagepol', [dirname(__file__)])
        except ImportError:
            import _imagepol
            return _imagepol
        if fp is not None:
            try:
                _mod = imp.load_module('_imagepol', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _imagepol = swig_import_helper()
    del swig_import_helper
else:
    import _imagepol
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class imagepol(_object):
    """Proxy of C++ casac::imagepol class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, imagepol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, imagepol, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> imagepol"""
        this = _imagepol.new_imagepol()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _imagepol.delete_imagepol
    __del__ = lambda self : None;
    def imagepoltestimage(self, *args, **kwargs):
        """
        imagepoltestimage(self, outfile=string("imagepol.iquv"), rm=initialize_vector(1, (double)0.0), pa0=0.0, sigma=0.01, 
            nx=32, ny=32, nf=32, f0=1.4e9, bw=128.0e6) -> bool

        Summary
        	Attach the Imagepol tool to a test image file

        Description
        	

        This function can be used to generate a test image and then
        attach the Imagepol 	ool\ to it.

        The test image is 4-dimensional (RA, DEC, Stokes and Frequency).  The
        Stokes axis holds I,Q,U and V.  The source is just a constant I (if you
        don't add noise all spatial pixels will be identical) and V.  Q and U
        vary with frequency according to the specified Rotation Measure
        components (no attempt to handle bandwidth smearing within channels is
        made).  The actual values of I,Q,U, and V are chosen arbitrarily
        otherwise (could be added as arguments if desired). 

        You can use this image, in particular, to explore the Rotation Measure
        algorithms in functions rotationmeasure and
        fourierrotationmeasure. 

        If you don't specify the Rotation Measure, then it is chosen for you so
        that there is no position angle ambiguity between adjacent channels
        (the value will be sent to the Logger).

        The noise added to the image is specified as a fraction of the total
        intensity (constant).  Gaussian noise with a standard deviation of
        {\stfaf sigma * $I_{max}$} is then added to the image. 



        Input Parameters:
        	outfile		 Output image file name imagepol.iquv 
        	rm		 Rotation Measure (rad/m/m). Default is auto no-ambiguity determine. 0.0 
        	pa0		 Position angle (degrees) at zero wavelength 0.0 
        	sigma		 Fractional noise level 0.01 
        	nx		 Shape of image in x direction 32 
        	ny		 Shape of image in y direction 32 
        	nf		 Shape of image in frequency direction 32 
        	f0		 Reference frequency (Hz) 1.4e9 
        	bw		 Bandwidth (Hz) 128.0e6 
        	
        Example:
        	

        '''
        #
        print '	----	 imagepoltestimage Ex 1 	----'
        po.imagepoltestimage(outfile='imagepoltestimage', rm=200)
        po.rotationmeasure(rm='rm.out',rmmax=250)
        ia.open('rm.out')
        ia.statistics()
        #viewer()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_imagepoltestimage(self, *args, **kwargs)

    def complexlinpol(self, *args, **kwargs):
        """
        complexlinpol(self, outfile) -> bool

        Summary
        	Complex linear polarization

        Description
        	 

        This function  produces
        the complex linear polarization; $Q+iU$ and writes
        it to a disk image file.

        The Image 	ool\ cannot yet handle Complex
        images.  You must therefore write the Complex image to disk.  The 
        Viewer can display Complex images. Also the
        Table tool can access Complex images.



        Input Parameters:
        	outfile		 Output image file name 
        	
        Example:
        	

        '''
        #
        print '	----	 complexlinpol Ex 1 	----'
        po.open('stokes.image')
        po.complexlinpol('cplx')
        tb.open('cplx')
        #tb.browse()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_complexlinpol(self, *args, **kwargs)

    def complexfraclinpol(self, *args, **kwargs):
        """
        complexfraclinpol(self, outfile) -> bool

        Summary
        	Complex fractional linear polarization

        Description
        	 

        This function produces
        the complex fractional linear polarization; $(Q+iU)/I$ and writes
        it to a disk image file.

        The Image 	ool\ cannot yet handle Complex
        images.  You must therefore write the Complex image to disk.  The 
        Viewer can display Complex images. Also the
        Table tool can access Complex images.



        Input Parameters:
        	outfile		 Output image file name 
        	
        Example:
        	

        '''
        #
        print '	----	 complexfraclinpol Ex 1 	----'
        po.open('stokes.image')
        po.complexfraclinpol('cplx2')
        tb.open('cplx2')
        #tb.browse()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_complexfraclinpol(self, *args, **kwargs)

    def depolratio(self, *args, **kwargs):
        """
        depolratio(self, infile, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Linear depolarization ratio

        Description
        	 

        This function  returns the linear
        depolarization ratio computed from two frequencies; this is the ratio of
        the fractional linear polarization at the two frequencies.  Generally
        this is done when you have generated two images, each at a different frequency
        (continuum work). Thus if the fractional linear polarization images are
        $m_{
        u 1}$ and $m_{
        u 2}$ then the depolarization ratio is 
        $m_{
        u 1}/ m_{
        u 2}$.

        This function operates with two images; the first (at frequency $
        u 1$)
        is the one attached to your Imagepol 	ool.  The second (at
        frequency $
        u 2$) is supplied via the argument {\stfaf infile}, which
        is  a String holding the name of the
        \imagefile.

        In generating the depolarization ratio, you may optionally debias the 
        linearly polarized intensity.  This requires the standard deviation of
        the thermal noise.  You can either supply it if you know it, or it will
        be worked out for you with outliers from the mean clipped at the
        specified level. 

        You can get the depolarization ratio error image with function
        sigmadepolratio.



        Input Parameters:
        	infile		 Other image 
        	debias		 Debias the linearly polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        #print '	----	 depolratio Ex 1 	----'
        #po.open('stokes.4800')
        #dpr = po.depolratio(infile='stokes.8300')        # m_4800 / m_8300
        #edpr = po.sigmadepolratio(infile='stokes.8300');
        #dpr.done()
        #edpr.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_depolratio(self, *args, **kwargs)

    def close(self):
        """
        close(self) -> bool

        Summary
        	Close the image tool

        Description
        	

        This function closes the imagepol tool.  This means that it detaches
        the tool from its \imagefile\ (flushing all the changes first).  The
        imagepol tool is ``null'' after this change (it is not destroyed) and
        calling any 	oolfunction\ other than open will result in an
        error.


        Example:
        	

        '''
        #
        print '	----	 close Ex 1 	----'
        # First create image and attach it to imagepol tool
        po.imagepoltestimage('myimagepol')
        po.close()              # Detaches image from Imagepol tool
        print '!!!EXPECT ERROR HERE!!!'
        po.summary()            # No image so this results in an error.
        po.open('myimagepol')   # Image is reattached
        po.summary()            # No error
        po.close()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_close(self)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Close this Imagepol tool

        Description
        	



        This function is the same as close().


        Example:
        	

        '''
        #
        print '	----	 done Ex 1 	----'
        po.open('myimagepol')
        po.done()             # Detaches image from Imagepol tool
        print '!!!EXPECT ERROR HERE!!!'
        po.summary()          # No image so this results in an error.
        po.open('myimagepol') # Image is reattached
        po.summary()          # No error
        po.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_done(self)

    def fourierrotationmeasure(self, *args, **kwargs):
        """
        fourierrotationmeasure(self, complex=string(""), amp=string(""), pa=string(""), real=string(""), imag=string(""), 
            zerolag0=False) -> bool

        Summary
        	Find Rotation Measure (Fourier approach)

        Description
        	

        This function  will only work if
        you attach the Imagepol 	ool\ (using open) to an image containing
        Stokes Q and U, and a regular frequency axis.  It Fourier transforms
        the complex linear polarization (Q+iU) over the spectral axis to the
        rotation measure axis.  Thus, if your input image contained
        RA/DEC/Stokes/Frequency, the output image would be
        RA/DEC/RotationMeasure.  The Rotation Measure axis has as many pixels
        as the spectral axis.

        This method enables you to see the polarization as a function of
        Rotation Meausure.  Its main use is when searching for large RMs.  See
        Killeen, Fluke, Zhao and Ekers (1999, preprint) for a description of
        this method (or http://www.atnf.csiro.au/erb+~+nkilleen/rm.ps) and its
        advantages over the traditional method
        (rotationmeasure) of
        extracting the Rotation Measure. 

        Although you can write out the complex polarization image with the
        argument {\stfaf complex}, you can't do much with it because Image
        	ools\ cannot handle complex images.  Hence you can
        also write out the complex linear polarization image in any or all of
        the other forms. 

        The argument {\stfaf zerolag0} allows you to force the zero lag (or
        central bin) of the Rotation Measure spectrum to zero (effectively by
        subtracting the mean of Q and U from the Q and U images).  This may
        avoid Gibbs phenomena from any strong low Rotation Measure signal which
        would normally fall into the central bin. 



        Input Parameters:
        	complex		 Output complex linear polarization image file name. Default is unset. 
        	amp		 Output linear polarization amplitude image file name Default is unset. 
        	pa		 Output linear polarization position angle (degrees) image file name Default is unset. 
        	real		 Output linear polarization real image file name Default is unset. 
        	imag		 Output linear polarization imaginary angle image file name Default is unset. 
        	zerolag0	 Force zero lag to 0 ? false 
        	
        Example:
        	

        '''
        #
        print '	----	 fourierrotationmeasure Ex 1 	----'
        po.imagepoltestimage(outfile='iquv.im', rm=[5.0e5,1e6], nx=8, ny=8, nf=512, 
                             f0=1.4e9, bw=8e6)
        po.fourierrotationmeasure(amp='amp')
        ia.open('amp')
        ia.statistics()
        #viewer()                     # And reorder to put RM along X-axis 
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_fourierrotationmeasure(self, *args, **kwargs)

    def fraclinpol(self, *args, **kwargs):
        """
        fraclinpol(self, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Fractional linear polarization

        Description
        	 This function 
        returns the fractional linear polarization; $\sqrt{(Q^2+U^2)}/I$.

        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level. 



        Input Parameters:
        	debias		 Debias the linearly polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 fraclinpol Ex 1 	----'
        po.open('stokes.image')
        flp = po.fraclinpol()
        flp.summary()
        flp.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_fraclinpol(self, *args, **kwargs)

    def fractotpol(self, *args, **kwargs):
        """
        fractotpol(self, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Fractional total polarization

        Description
        	 This function 
        returns the fractional linear polarization; $\sqrt{(Q^2+U^2+V^2)}/I$.

        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level. 

        If your image contains only Q and U, or only V, then just
        those components contribute to the total polarized intensity.



        Input Parameters:
        	debias		 Debias the total polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 fractotpol Ex 1 	----'
        po.open('stokes.image')
        ftp = po.fractotpol()
        ftp.statistics()
        ftp.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_fractotpol(self, *args, **kwargs)

    def linpolint(self, *args, **kwargs):
        """
        linpolint(self, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Linearly polarized intensity

        Description
        	 This function 
        returns the linearly polarized intensity; $\sqrt{(Q^2+U^2)}$. 

        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level. 



        Input Parameters:
        	debias		 Debias the linearly polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 linpolint Ex 1 	----'
        po.open('stokes.image')
        lpi = po.linpolint()
        lpi.statistics()
        lpi.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_linpolint(self, *args, **kwargs)

    def linpolposang(self, *args, **kwargs):
        """
        linpolposang(self, outfile=string("")) -> casac::image *

        Summary
        	Linearly polarized position angle

        Description
        	 

        This function  returns the linearly
        polarized position angle image ($0.5 	an^{-1}(U/Q)$) in degrees. 



        Input Parameters:
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 linpolposang Ex 1 	----'
        po.open('stokes.image')
        lppa = po.linpolposang()
        lppa.statistics()
        lppa.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_linpolposang(self, *args, **kwargs)

    def makecomplex(self, *args, **kwargs):
        """
        makecomplex(self, complex, real=string(""), imag=string(""), amp=string(""), phase=string("")) -> bool

        Summary
        	Make a Complex image

        Description
        	 

        This function generates a Complex \imagefile\ from either
        a real and imaginary, or an amplitude and phase pair of images.
        If you give a linear position angle image for the phase, 
        it will be multipled by two before the real and imaginary
        parts are formed.



        Input Parameters:
        	complex		 Output complex image file name. Must be specified. 
        	real		 Input real image file name. Default is unset. 
        	imag		 Input imaginary image file name. Default is unset. 
        	amp		 Input amplitude image file name. Default is unset. 
        	phase		 Input phase image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 makecomplex Ex 1 	----'
        po.open('stokes.image')
        po.complexlinpol('qu.cplx1')        
        q = po.stokesq()
        u = po.stokesu()
        q2 = q.subimage('q',overwrite=true)
        u2 = u.subimage('u',overwrite=true)
        po.makecomplex('qu.cplx2', real='q', imag='u')
        po.close()
        #
        '''

        In this example we make two complex linear polarization
        images which should be identical.   

        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_makecomplex(self, *args, **kwargs)

    def open(self, *args, **kwargs):
        """
        open(self, image=initialize_variant("")) -> bool

        Summary
        	Open a new image with this imagepol tool

        Description
        	

        Before polarimetric analysis can commence, an \imagefile\ must be
        attached to the imagepol tool using the open function.  Also, use this
        function when you are finished analyzing the current \imagefile\ and
        want to attach to another one.  This function detaches the \imagetoolfrom the current \imagefile, if one exists, and reattaches it (opens)
        to the new \imagefile.

        The input image file may be in native \casa, its, or Miriad  
        format.  Look \htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
        information on foreign images.

        The input image must have a Stokes axis. The exact collection of
        Stokes that the image has, determines what the Imagepol tool can
        compute. Stokes I, Q, U, and V refer to total intensity, two
        components of linear polarization, and circular polatization,
        respectively. Therefore, if you ask for linear polarization and the
        image only has Stokes I and V, you will get an error.

        The input image may contain data at many frequencies. For example, the
        image may be a 4D image with axes RA, DEC, Stokes and Frequency (order
        not important) where the Frequency axis is regularly sampled. However,
        the image may also contain many frequencies at irregular
        intervals. Such an image may be created with the Image tool function
        imageconcat. It enables you to concatenate images along an axis, and
        it allows irregular coordinate values along that axis.





        Input Parameters:
        	image		 image file name or image record (generated by ia.torecord()) 
        	
        Example:
        	

        '''
        #
        print '	----	 open Ex 1 	----'
        po.open('stokes.image')
        po.close()
        #
        '''

        The {\stff open} function first closes the old \imagefile\ if one exists.

        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_open(self, *args, **kwargs)

    def pol(self, *args, **kwargs):
        """
        pol(self, which, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Polarized quantities

        Description
        	

        This function just packages the other specific polarization
        functions into one where you specify an operation with the
        argument {\stfaf which} (can be useful for scripts).  
        This argument can take the values:

        egin{itemize}
        \item 'lpi' - linearly polarized intensity (function 
          linpolint)

        \item 'tpi' - total polarized intensity (function 
           totpolint)

        \item 'lppa' linearly polarized position angle (function 
            linpolposang)

        \item 'flp' - fractional linear polarization (function 
           fraclinpol)

        \item 'ftp' - fractional total polarized intensity (function 
           fractotpol)

        nd{itemize}



        Input Parameters:
        	which		 Specify operation. One of 'lpi', 'tpi', 'lppa', 'flp', 'ftp' (case insensitive) 
        	debias		 Debias the polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 pol Ex 1 	----'
        po.open('stokes.image')
        lpi = po.pol('lpi')
        lpi.statistics()
        lpi.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_pol(self, *args, **kwargs)

    def rotationmeasure(self, *args, **kwargs):
        """
        rotationmeasure(self, rm=string(""), rmerr=string(""), pa0=string(""), pa0err=string(""), nturns=string(""), 
            chisq=string(""), sigma=-1, rmfg=0.0, rmmax=0.0, maxpaerr=1e30, plotter=string(""), 
            nx=5, ny=5) -> bool

        Summary
        	Find Rotation Measure (traditional approach)

        Description
        	

        This function generates the rotation
        measure image from a collection of different frequencies.  It will only
        work if the Imagepol 	ool\ is attached to an image containing
        Stokes $Q$ and $U$, and a frequency axis (regular or irregular) with at
        least 2 pixels.  It will work out the position angle images for you.

        See also the fourierrotationmeasure 
        function for a new Fourier-based approach.

        Rotation Measure algorithms that work robustly are not common.  The main
        problem is in trying to account for the $n- \pi$ ambiguity (see Leahy et
        al, Astronomy \& Astrophysics, 156, 234 or Killeen et al;
        http://www.atnf.csiro.au/erb+~+nkilleen/rm.ps). 

        The algorithm that this function uses is that of Leahy et al. (see Appendix A.1).  But as in all
        these algorithms, the basic process is that for each spatial pixel, a
        vector of position angles (i.e.  at the different frequencies) is fit to
        determine the rotation measure and the position angle at zero wavelength
        (and their errors).   An image containing
        the number of $n- \pi$ turns that were added to the data
        at each spatial pixel and for which the best fit was found can be written.
        The reduced chi-squared image for the fits can also be written.

        Note that no assessment of curvature (i.e. deviation
        from the simple linear position angle - $\lambda^2$ functional form)
        is made.  

        Any combination of output images can be written.

        The argument {\stfaf sigma} gives the thermal noise in Stokes Q and U.
        By default it is determined automatically using the image data.  But if it proves 
        to be inaccurate (maybe not many signal-free pixels), it may be specified.
        This is used for calculating the error in the
        position angles (propagation of Gaussian errors).

        The argument {\stfaf maxpaerr} specifies the maximum allowable error in
        the position angle that is acceptable.  The default is an infinite
        value.  From the standard propagation of errors, the error in the
        linearly polarized position angle is determined from the Stokes $Q$ and
        $U$ images (at each spatial pixel for each frequency).  At each spatial
        pixel we do a fit to the position angle vector (i.e.  at the different
        frequencies) to determine the rotation measure.  If the position angle
        error for any pixel in the vector exceeds the specified value, it is
        dropped from the fit.     The process generates an error for the
        fit and this is used to compute the errors in the output
        images.  

        Note that {\stfaf maxpaerr} is {\it not} used to specify that any pixel
        for which the output position angle error exceeds this value
        should be masked out.

        The argument {\stfaf rmfg} is used to specify a foreground RM value.  For
        example, you may know the mean RM in some direction out of the Galaxy,
        then including this can aid the algorithm by reducing ambiguity.

        The argument {\stfaf rmmax} specifies the maximum absolute RM that
        should be solved for.  This quite an important parameter.  If you leave
        it at the default, zero, no ambiguity handling will be
        used.  So some apriori information should be supplied; this
        is the basic problem with rotation measure algorithms. 



        Input Parameters:
        	rm		 Output Rotation Measure image file name. Default is unset. 
        	rmerr		 Output Rotation Measure error image file name. Default is unset. 
        	pa0		 Output position angle (degrees) at zero wavelength image file name. Default is unset. 
        	pa0err		 Output position angle (degrees) at zero wavelength error image file name. Default is unset. 
        	nturns		 Output number of turns image file name. Default is unset. 
        	chisq		 Output reduced chi squared image file name. Default is unset. 
        	sigma		 Estimate of the thermal noise. Default is auto estimate. -1 
        	rmfg		 Foreground Rotation Measure (rad/m/m) to subtract. 0.0 
        	rmmax		 Maximum rotation measure (rad/m/m) to solve for. IMPORTANT TO SPECIFY. 0.0 
        	maxpaerr	 Maximum input position angle error (degrees) to allow 1e30 
        	plotter		 Name of plotter. Default is none. 
        	nx		 Number of plots in x direction 5 
        	ny		 Number of plots in y direction 5 
        	
        Example:
        	

        '''
        #
        print '	----	 rotationmeasure Ex 1 	----'
        #im = ia.imageconcat(outfile='stokes.image', 
        #                    infiles='im.f1 im.f2 im.f3 im.f4 im.f5', axis=4)
        po.open('stokes.image')
        ok = po.rotationmeasure(rm='rm', rmerr='rmerr', rmmax=800, maxpaerr=10)
        #
        '''


        Say we have 5 images, each with axes RA, DEC, Stokes, and Frequency in
        that order.  We use the Image 	ool\ to concatenate these images
        along the frequency axis - you have ordered them in increasing or
        decreasing frequency order.  We then compute the Rotation Measure
        and Rotation Measure error images with the traditional method and
        write them out to disk.


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_rotationmeasure(self, *args, **kwargs)

    def sigma(self, clip=10.0):
        """
        sigma(self, clip=10.0) -> double

        Summary
        	Find best guess at thermal noise

        Description
        	 

        This function returns the standard deviation from V, Q\&U or I in that
        order of precedence.  It is attempting to give you the best estimate of
        the thermal noise it can from the data.  Outliers from the mean are
        clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	
        Example:
        	

        '''
        #
        print '	----	 sigma Ex 1 	----'
        po.open('stokes.image')
        sigma = po.sigma()
        print 'sigma=', sigma
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigma(self, clip)

    def sigmadepolratio(self, *args, **kwargs):
        """
        sigmadepolratio(self, infile, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Error in linear depolarization ratio

        Description
        	 

        This function  returns the error
        in the linear depolarization ratio computed from two frequencies; this
        is the ratio of the fractional linear polarization at the two
        frequencies.  Generally this is done when you have generated two
        images, each at a different frequency (continuum work). Thus if the
        fractional linear polarzation images are $m1$ and $m2$ then the
        depolarization ratio is $m1/m2$.

        This function operates with two images; the first is attached
        to the Imagepol 	ool.  The second is supplied via the
        argument {\stfaf infile}, which is  a String
        holding the name of the \imagefile.

        In generating the depolarization ratio, and hence its error, you may
        optionally debias the  linearly polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level. 

        You can get the depolarization ratio image with function
        depolratio.



        Input Parameters:
        	infile		 Other image. Required input. 
        	debias		 Debias the linearly polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	


        '''
        #
        #print '	----	 sigmadepolratio Ex 1 	----'
        #po.open('stokes.4800')
        #dpr = po.depolratio('stokes.8300')
        #edpr = po.sigmadepolratio('stokes.8300');
        #dpr.done()
        #edpr.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmadepolratio(self, *args, **kwargs)

    def sigmafraclinpol(self, *args, **kwargs):
        """
        sigmafraclinpol(self, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Error in fractional linear polarization

        Description
        	 

        This function  returns the
        error (standard deviation) of the fractional linear polarization.
        This result comes from standard propagation of errors.  The result is
        an on-the-fly Image tool as the error is signal-to-noise ratio
        dependent.

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	


        '''
        #
        print '	----	 sigmafraclinpol Ex 1 	----'
        po.open('stokes.image')
        sigflp = po.sigmafraclinpol()
        sigflp.statistics()
        sigflp.done()           # free up resources
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmafraclinpol(self, *args, **kwargs)

    def sigmafractotpol(self, *args, **kwargs):
        """
        sigmafractotpol(self, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Error in fractional total polarization

        Description
        	 

        This function  returns the
        error (standard deviation) of the fractional total polarization.  This
        result comes from standard propagation of errors.  The result is an
        on-the-fly Image tool as the error is signal-to-noise ratio dependent.

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	


        '''
        #
        print '	----	 sigmafractotpol Ex 1 	----'
        po.open('stokes.image')
        sigftp = po.sigmafractotpol()
        sigftp.statistics()
        sigftp.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmafractotpol(self, *args, **kwargs)

    def sigmalinpolint(self, *args, **kwargs):
        """
        sigmalinpolint(self, clip=10.0, sigma=-1, outfile=string("")) -> double

        Summary
        	Error in linearly polarized intensity

        Description
        	 

        This function  returns the error (standard
        deviation) of the linearly polarized intensity; $\sqrt{(Q^2+U^2)}$. 
        This result comes from standard propagation of statistical errors.
        The result is a float as the error is not signal-to-noise
        ratio dependent

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	


        '''
        #
        print '	----	 sigmalinpolint Ex 1 	----'
        po.open('stokes.image')
        siglpi = po.sigmalinpolint()
        print 'siglpi=', siglpi
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmalinpolint(self, *args, **kwargs)

    def sigmalinpolposang(self, *args, **kwargs):
        """
        sigmalinpolposang(self, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Error in linearly polarized position angle

        Description
        	 

        This function  returns the
        error (standard deviation) of the linearly polarized position angle
        ($0.5 	an^{-1}(U/Q)$$\sqrt{(Q^2+U^2)}$) in degrees.  This result
        comes from standard propagation of errors.  The result is an
        on-the-fly Image tool as the error is signal-to-noise ratio dependent.

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	


        '''
        #
        print '	----	 sigmalinpolposang Ex 1 	----'
        po.open('stokes.image')
        siglppa = po.sigmalinpolposang()
        siglppa.statistics()
        siglppa.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmalinpolposang(self, *args, **kwargs)

    def sigmastokes(self, *args, **kwargs):
        """
        sigmastokes(self, which, clip=10.0) -> double

        Summary
        	Find standard deviation of specified Stokes data

        Description
        	 

        This function  returns the standard
        deviation of the noise for the specified Stokes.  Outliers from the mean
        are clipped at the specified level. 



        Input Parameters:
        	which		 Must specify Stokes parameter. One of 'I', 'Q', 'U', 'V' (case insensitive) 
        	clip		 Clip level for auto-sigma determination 10.0 
        	
        Example:
        	

        '''
        #
        print '	----	 sigmastokes Ex 1 	----'
        po.open('stokes.image')
        sigq = po.sigmastokes('q', 10.0)
        print 'sigq=', sigq
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmastokes(self, *args, **kwargs)

    def sigmastokesi(self, clip=10.0):
        """
        sigmastokesi(self, clip=10.0) -> double

        Summary
        	Find standard deviation of Stokes I data

        Description
        	 

        This function  returns the standard deviation of the noise for the
        Stokes I data.  Outliers from the mean are clipped at the specified
        level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	
        Example:
        	

        '''
        #
        print '	----	 sigmastokesi Ex 1 	----'
        po.open('stokes.image')
        sigi = po.sigmastokesi(10.0)
        print 'sigi=', sigi
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmastokesi(self, clip)

    def sigmastokesq(self, clip=10.0):
        """
        sigmastokesq(self, clip=10.0) -> double

        Summary
        	Find standard deviation of Stokes Q data

        Description
        	 

        This function  returns the standard deviation of the noise for the
        Stokes Q data.  Outliers from the mean are clipped at the specified
        level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	
        Example:
        	

        '''
        #
        print '	----	 sigmastokesq Ex 1 	----'
        po.open('stokes.image')
        sigq = po.sigmastokesq(10.0)
        print 'sigq=', sigq
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmastokesq(self, clip)

    def sigmastokesu(self, clip=10.0):
        """
        sigmastokesu(self, clip=10.0) -> double

        Summary
        	Find standard deviation of Stokes U data

        Description
        	 

        This function  returns the standard
        deviation of the noise for the Stokes U data.  Outliers from the mean
        are clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	
        Example:
        	

        '''
        #
        print '	----	 sigmastokesu Ex 1 	----'
        po.open('stokes.image')
        sigu = po.sigmastokesu(10.0)
        print 'sigu=', sigu
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmastokesu(self, clip)

    def sigmastokesv(self, clip=10.0):
        """
        sigmastokesv(self, clip=10.0) -> double

        Summary
        	Find standard deviation of Stokes V data

        Description
        	 

        This function  returns the standard
        deviation of the noise for the Stokes V data.  Outliers from the mean
        are clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	
        Example:
        	

        '''
        #
        print '	----	 sigmastokesv Ex 1 	----'
        po.open('stokes.image')
        sigv = po.sigmastokesv(10.0)
        print 'sigv=', sigv
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmastokesv(self, clip)

    def sigmatotpolint(self, *args, **kwargs):
        """
        sigmatotpolint(self, clip=10.0, sigma=-1) -> double

        Summary
        	Error in total polarized intensity

        Description
        	 

        This function  returns the error (standard
        deviation) of the total polarized intensity; $\sqrt{(Q^2+U^2+V^2)}$. 
        This result comes from standard propagation of statistical errors.
        The result is a float as the error is not signal-to-noise
        ratio dependent

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level. 



        Input Parameters:
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noise. Default is auto determined. -1 
        	
        Example:
        	

        '''
        #
        print '	----	 sigmastotpolint Ex 1 	----'
        po.open('stokes.image')
        sigtpi = po.sigmatotpolint()
        print 'sigtpi=', sigtpi
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_sigmatotpolint(self, *args, **kwargs)

    def stokes(self, *args, **kwargs):
        """
        stokes(self, which, outfile=string("")) -> casac::image *

        Summary
        	Stokes

        Description
        	

        This function returns an on-the-fly image tool containing the
        specified Stokes only.  This interface can be useful for scripts.



        Input Parameters:
        	which		 Must specify Stokes. One of 'I', 'Q', 'U', 'V' (case insensitive) 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 stokes Ex 1 	----'
        po.open('stokes.image')
        q = po.stokes('q')
        q.statistics()
        q.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_stokes(self, *args, **kwargs)

    def stokesi(self, *args, **kwargs):
        """
        stokesi(self, outfile=string("")) -> casac::image *

        Summary
        	Stokes I

        Description
        	
        This function returns an on-the-fly image tool containing Stokes I only.


        Input Parameters:
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 stokesi Ex 1 	----'
        po.open('stokes.image')
        i = po.stokesi()
        i.statistics()
        i.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_stokesi(self, *args, **kwargs)

    def stokesq(self, *args, **kwargs):
        """
        stokesq(self, outfile=string("")) -> casac::image *

        Summary
        	Stokes Q

        Description
        	
        This function returns an on-the-fly image tool containing Stokes Q only.


        Input Parameters:
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 stokesq Ex 1 	----'
        po.open('stokes.image')
        q = po.stokesq()
        q.statistics()
        q.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_stokesq(self, *args, **kwargs)

    def stokesu(self, *args, **kwargs):
        """
        stokesu(self, outfile=string("")) -> casac::image *

        Summary
        	Stokes U

        Description
        	
        This function returns an on-the-fly image tool containing Stokes U only.


        Input Parameters:
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 stokesu Ex 1 	----'
        po.open('stokes.image')
        u = po.stokesu()
        u.statistics()
        u.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_stokesu(self, *args, **kwargs)

    def stokesv(self, *args, **kwargs):
        """
        stokesv(self, outfile=string("")) -> casac::image *

        Summary
        	Stokes V

        Description
        	
        This function returns an on-the-fly image tool containing Stokes V only.


        Input Parameters:
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 stokesv Ex 1 	----'
        po.open('stokes.image')
        v = po.stokesv()
        v.statistics()
        v.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_stokesv(self, *args, **kwargs)

    def summary(self):
        """
        summary(self) -> bool

        Summary
        	Summarise Imagepol tool

        Description
        	

        This function just lists a summary of the Imagepol 	ool\ to the logger. 
        Currently it just summarizes the image to which the tool is attached.



        Example:
        	

        '''
        #
        print '	----	 summary Ex 1 	----'
        po.open('stokes.image')
        po.summary()
        #
        #Image name       : stokes.image
        #Object name      :
        #Image type       : PagedImage
        #Image quantity   : Intensity
        #Pixel mask(s)    : None
        #Region(s)        : None
        #
        #Direction reference : J2000
        #Spectral  reference : TOPO
        #Velocity  type      : RADIO
        #Rest frequency      : 1.4e+09 Hz
        #Telescope           : UNKNOWN
        #Observer            : UNKNOWN
        #Date observation    : UNKNOWN
        #
        #Axis Coord Type      Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
        #------------------------------------------------------------------------------------------------
        #0    0     Direction Right Ascension   SIN    32   32  00:00:00.000    16.00 -6.000000e+01 arcsec
        #1    0     Direction Declination       SIN    32   32 +00.00.00.000    16.00  6.000000e+01 arcsec
        #2    1     Stokes    Stokes                    4    4       I Q U V
        #3    2     Spectral  Frequency                32   32       1.4e+09    16.00  4.000000e+06 Hz
        #                     Velocity                                     0    16.00 -8.565499e+02 km/s
        #
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_summary(self)

    def totpolint(self, *args, **kwargs):
        """
        totpolint(self, debias=False, clip=10.0, sigma=-1, outfile=string("")) -> casac::image *

        Summary
        	Total polarized intensity

        Description
        	 This function 
        returns the total polarized intensity; $\sqrt{(Q^2+U^2+V^2)}$. 
        If your image contains only Q and U, or only V, then just
        those components contribute to the total polarized intensity.

        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level. 



        Input Parameters:
        	debias		 Debias the total polarized intensity ? false 
        	clip		 Clip level for auto-sigma determination 10.0 
        	sigma		 Standard deviation of thermal noised. Default is auto determined. -1 
        	outfile		 Output image file name. Default is unset. 
        	
        Example:
        	

        '''
        #
        print '	----	 totpolint Ex 1 	----'
        po.open('stokes.image')
        tpi = po.totpolint()
        tpi.statistics()
        tpi.done()
        #
        '''


        --------------------------------------------------------------------------------
        	      
        """
        return _imagepol.imagepol_totpolint(self, *args, **kwargs)

imagepol_swigregister = _imagepol.imagepol_swigregister
imagepol_swigregister(imagepol)

# This file is compatible with both classic and new-style classes.


