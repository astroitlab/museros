# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_deconvolver', [dirname(__file__)])
        except ImportError:
            import _deconvolver
            return _deconvolver
        if fp is not None:
            try:
                _mod = imp.load_module('_deconvolver', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _deconvolver = swig_import_helper()
    del swig_import_helper
else:
    import _deconvolver
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class deconvolver(_object):
    """Proxy of C++ casac::deconvolver class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, deconvolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, deconvolver, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> deconvolver"""
        this = _deconvolver.new_deconvolver()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _deconvolver.delete_deconvolver
    __del__ = lambda self : None;
    def open(self, *args, **kwargs):
        """
        open(self, dirty=string(""), psf=string(""), warn=True) -> bool

        Summary
        	Open a new dirty image and PSF

        Description
        	
        Close the current images and open a new dirty image and PSF
        instead. The current state of {	t deconvolver} is retained, except for
        the data selection.


        Input Parameters:
        	dirty		 Dirty image to be processed 
        	psf		 point spread function to be processed 
        	warn		 Produce warning messages if psf is not provided true 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_open(self, *args, **kwargs)

    def reopen(self):
        """
        reopen(self) -> bool

        Summary
        	Reopen the dirty image and PSF

        Description
        	
        Close and reopen the current dirty and PSF images, and make
        new convolvers and cleaners.  The main benefit of this method
        is to flush the residual image and replace it with the dirty image.

        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_reopen(self)

    def close(self):
        """
        close(self) -> bool

        Summary
        	Close the deconvolver tool

        Description
        	
        This is used to close {	t deconvolver} tools. Note that the
        data is written to disk. The {	t deconvolver} process keeps running
        until a done tool function call is performed.

        Example:
        	

        dc.open('3C273XC1.dirty', '3C273XC1.psf')      
        dc.clean(model='3C273XC1.clean');
        dc.close()


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_close(self)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Terminate the deconvolver process

        Description
        	
        This is used to totally stop the {	t deconvolver} process. It is a good idea
        to conserve memory use on your machine by stopping the process once
        you no longer need it.

        Example:
        	

        dc.open('3C273XC1.dirty', '3C273XC1.psf')      
        dc.clean(model='3C273XC1.clean');
        dc.close()
        dc.done()


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_done(self)

    def summary(self):
        """
        summary(self) -> bool

        Summary
        	Summarize the current state

        Description
        	
        Writes a summary of the properties of the deconvolver to the
        default logger. This includes:
        egin{itemize}
        \item The names of the dirty image and PSF (set in construction or via the
        open function.
        \item The current beam fit
        nd{itemize}

        Example:
        	

        dc.open('3C273XC1.dirty', '3C273XC1.psf')      
        dc.summary()


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_summary(self)

    def boxmask(self, *args, **kwargs):
        """
        boxmask(self, mask=string(""), blc=initialize_vector(1, (int)-1), trc=initialize_vector(1, (int)-1), 
            fillvalue=initialize_variant("1.0Jy"), outsidevalue=initialize_variant("0.0Jy")) -> bool

        Summary
        	Construct a mask from blc, trc

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        deconvolver to control the region selected in a deconvolution. 

        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. boxmask does not enforce
        this requirement.



        Input Parameters:
        	mask		 name of mask image 
        	blc		 Bottom left corner -1 
        	trc		 Top right corner -1 
        	fillvalue	 Value to fill in 1.0Jy 
        	outsidevalue	 outside value 0.0Jy 
        	
        Example:
        	

        dc.boxmask(mask='bigmask', blc=[56,45,1,1], trc=[87,93,4,1])
        dc.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_boxmask(self, *args, **kwargs)

    def regionmask(self, *args, **kwargs):
        """
        regionmask(self, mask=string(""), region=initialize_record(""), boxes=initialize_variant(""), value=1.0) -> bool

        Summary
        	Construct a mask image from a region

        Description
        	
        A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution. 

        In  Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value is discouraged but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. {	t regionmask} does not enforce
        this requirement. 

        The function regionmask also allows multiple regions to be used. A record of the regions can be made as in the example below. 

        Regions can be made in many different ways using the
        regionmanager functions. An example
        using wbox function is given
        below. The default regionmanager tool 'rg' can be used for cases the user want to have flexibility in manipulating regions. The {	t region} parameter takes a record that comes from the regionmanager output.
        The parameter boxes allow the user to sent in a list of 4 elements numbers representing blc's and trc's 

        If both the parameters, {	t regions} and {	t boxes} are used the a union is done with the two sets of region thus defined.



         



        Input Parameters:
        	mask		 name of mask image 
        	region		 Region record usually from regionmanager unset 
        	boxes		 list of 4 elements lists e.g [[xblc1, yblc1, xtrc1, ytrc1], [[xblc2, yblc2, xtrc2, ytrc2]] 
        	value		 Value to set the mask to 1.0 
        	
        Example:
        	


        Makes a mask  then cleans using it.

        dc.open(dirty.image', 'psf.image')
        a=[100.0, 100.0, 200, 200.0]
        b=[50, 50, 80, 80]
        dc.regionmask(mask='bigmask', boxes[a,b])
        dc.clean(algorithm='hogbom', mask='bigmask', model='model.clean.masked', niter=1000)

        Another example using rg.wbox function: 
        ia.open('dirty')
        cs:=ia.coordsys()
        rg.setcoordinates(cs.record())
        r1:=dg.wbox(blc=['173pix', '347pix'], trc=['183pix', '370pix'])
        c.regionmask(mask='bigmask',region=r1)

        Or using a dict of regions:

        r2=rg.wbox(blc=['180pix', '344pix'], trc=['191pix', '369pix'])
        r3=rg.wbox(blc=['189pix', '341pix'], trc=['204pix', '364pix'])
        regs={'reg1'':r1, 'reg2':r2, 'reg3':r3}
        rec=rg.makeunion(regs)
        dc.regionmask(mask='bigmask',region=rec)

        If quantities are to be used to define regions the following is a an example

        dc.regionmask(mask='joetest',boxes=['15:23:32.902','+05.19.32.089','15:22:28.631','+05.28.52.474'])





        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_regionmask(self, *args, **kwargs)

    def clipimage(self, *args, **kwargs):
        """
        clipimage(self, clippedimage=string(""), inputimage=string(""), threshold=initialize_variant("0.0Jy")) -> bool

        Summary
        	Zero all pixels where Stokes I is below
        a threshold

        Description
        	
        All pixels in the image with Stokes I less than some threshold
        are set to zero. This is useful prior to self-calibration where one 
        oftens wishes to remove negative pixels from the model. Note that
        if the image has polarization information, then the polarized
        part of a pixel is also set to zero if Stokes I is less than the
        threshold.


        Input Parameters:
        	clippedimage	 name of clipped image 
        	inputimage	 name of input image 
        	threshold	 Threshold 0.0Jy 
        	
        Example:
        	

        dc.clipimage(image='clean', threshold='50mJy')
        ###the ft that model into an MS and do gaincal for e.g


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_clipimage(self, *args, **kwargs)

    def clarkclean(self, *args, **kwargs):
        """
        clarkclean(self, niter=1000, gain=0.1, threshold=initialize_variant("0Jy"), displayprogress=False, 
            model=string(""), mask=string(""), histbins=500, psfpatchsize=initialize_vector(2,(int)51, (int)51), 
            maxextpsf=0.2, speedup=0.0, maxnumpix=10000, maxnummajcycles=-1, 
            maxnumminoriter=-1) -> bool

        Summary
        	Make a clean image using the Clark Clean
        a threshold

        Description
        	

        In the Clark Clean algorithm, the cleaning is split into minor and major
        cycles. In the minor cycles only the brightest points are cleaned,
        using a subset of the point spread function.  In the major cycle, the
        points thus found are subtracted correctly by using an FFT-based
        convolution.


        Input Parameters:
        	niter		 Number of iterations 1000 
        	gain		 Loop Gain for CLEANing 0.1 
        	threshold	 Flux level at which to stop CLEANing 0Jy 
        	displayprogress	 Display the progress of the cleaning? false 
        	model		 Name of images 
        	mask		 Name of mask images used for CLEANing 
        	histbins	 Number of bins in the pixel-flux histogram 500 
        	psfpatchsize	 Size of PSF for minor cycle 51 51 
        	maxextpsf	 maximum external sidelobe, used to set depth of minor cycle clean 0.2 
        	speedup		 Cleaning speedup exponent 0.0 
        	maxnumpix	 Maximum number of pixels used in each minor cycle 10000 
        	maxnummajcycles	 Max number of major cycles; -1 = no restrictions -1 
        	maxnumminoriter	 Max number of minor iterations; -1 = no restrictions -1 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_clarkclean(self, *args, **kwargs)

    def fullclarkclean(self, *args, **kwargs):
        """
        fullclarkclean(self, niter=1000, gain=0.1, threshold=initialize_variant("0Jy"), model=string(""), mask=string(""), 
            cyclefactor=1.5) -> record *

        Summary
        	Make a clean image using the Clark Clean
        a threshold

        Description
        	

        This is similar to clarkclean except that it accepts casa standard images. I.e it has to have 4 axes with the canonical order of
        (direction1, direction2, stokes, spectral). 
        This function further will clean more than the quarter of the image if the mask coverage is larger than a quarter of the image size.
        It is useful for CLI level parallelization, i.e use imager to make a dirty image and psf and use this function to deconvolve. 
        If in doubt use 
        clarkclean
         


        Input Parameters:
        	niter		 Number of iterations 1000 
        	gain		 Loop Gain for CLEANing 0.1 
        	threshold	 Flux level at which to stop CLEANing 0Jy 
        	model		 Name of model image that will contain the clean components 
        	mask		 Name of mask image used for CLEANing 
        	cyclefactor	 Factor to determine how deep to go in a Clark minor cycle 1.5 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_fullclarkclean(self, *args, **kwargs)

    def dirtyname(self):
        """
        dirtyname(self) -> string

        Summary
        	Return the name of the dirty-image table
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_dirtyname(self)

    def psfname(self):
        """
        psfname(self) -> string

        Summary
        	Return the name of the PSF-image table
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_psfname(self)

    def make(self, *args, **kwargs):
        """
        make(self, image=string(""), async=False) -> bool

        Summary
        	Make an empty image

        Description
        	
        Make an empty image with the properties (co-ordinate system etc.)
        borrowed from the dirty image.


        Input Parameters:
        	image		 Name of the new image on the disk 
        	async		 Run asynchronously in the background? false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_make(self, *args, **kwargs)

    def convolve(self, *args, **kwargs):
        """
        convolve(self, convolvemodel=string(""), model=string("")) -> bool

        Summary
        	Convolves an image with the PSF

        Description
        	
        Convolves an image (e.g., the model image) with the PSF


        Input Parameters:
        	convolvemodel	 Name of the output image on the disk to hold the result of the convolution 
        	model		 The input image to be convolved with the PSF 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_convolve(self, *args, **kwargs)

    def makegaussian(self, *args, **kwargs):
        """
        makegaussian(self, gaussianimage=string(""), bmaj=initialize_variant("0rad"), bmin=initialize_variant("0rad"), 
            bpa=initialize_variant("0deg"), normalize=True, async=False) -> bool

        Summary
        	Make an image with a single gaussian
        component

        Description
        	
        Make a model image with the a single gaussian.  The
        properties of the output image (e.g. the co-ordinate system, etc.) are
        borrowed from the dirty image.

        The image is made as follows:

           I(x,y)= Delta function of unit amplitude at (0,0)

           Temp(x,y) = Gaussian(x,y,Amplitude, Center, Sigma, PA)

           I(x,y) = Convovlution of Temp(x,y) with I(x,y).

        If {	t normalize=T} I(x,y) = I(x,y)/(area under the gaussian).



        Input Parameters:
        	gaussianimage	 Name of the output image on the disk 
        	bmaj		 The major axis of the gaussian 0rad 
        	bmin		 The minor axis of the gaussian 0rad 
        	bpa		 The Position Angle of the gaussian 0deg 
        	normalize	 Normalize the area under the gaussian to 1.0? true 
        	async		 Run asynchronously in the background? false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_makegaussian(self, *args, **kwargs)

    def state(self):
        """
        state(self) -> bool

        Summary
        	Return the ``state'' of the tool

        Description
        	
        Prints the name of the Dirty Image and the PSF and the parameters of
        the gaussian fitted to the main lobe of the PSF (the ``Clean Beam'').

        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_state(self)

    def updatestate(self, *args, **kwargs):
        """
        updatestate(self, f=string(""), method=string("INIT")) -> bool

        Summary
        	[A GUI builders related function]Update the GUI to reflect the currect state

        Description
        	
        Updates the GUI to reflect the currect state of the tool.  This
        function is used by toolmanager.  See documentation of the toolmanager
        for details about ``methods'' used to update the GUI.


        Input Parameters:
        	f		 Glish variable for the GUI to be updated 
        	method		 The method to be used for updating DONE close INIT 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_updatestate(self, *args, **kwargs)

    def clean(self, *args, **kwargs):
        """
        clean(self, algorithm=string("hogbom"), niter=1000, gain=0.1, threshold=initialize_variant("0Jy"), 
            displayprogress=False, model=string(""), mask=string(""), async=False) -> record *

        Summary
        	Make a clean image with Hogbom or MultiScale Clean

        Description
        	
            
            Makes a clean image using either the Hogbom or MultiScale
            algorithms. The MultiScale algorithm is the default. The clean is
            performed on the residual image calculated from the dirty image minus
            the point spread function convolved with the model currently selected.
            Thus if you want to restart a clean, simply set the model to the model
            that was previously produced by clean.
            
            Rather than explicit CLEAN boxes, mask images are used to constrain
            the region that is to be deconvolved. To make mask images,
            use either boxmask (to define a mask
            via the corner locations blc and trc) or 
            mask (to define a mask via
            thresholding an existing image). The default mask is the inner quarter
            of the image.
            
            The CLEAN deconvolution is joint in whatever Stokes parameters are
            present. Thus it searchs for peaks in either $I$ or $I+|V|$ or
            $I+\sqrt{Q^2+U^2+V^2}$, the rationale for the latter two forms being
            to be biased towards finding strongly polarized pixels first (these
            forms are also the maximum eigenvalue of the coherency matrix).  The
            PSF is constrained to be the same in all polarizations (a feature of
            this implementation, not of the Hamaker-Bregman-Sault formalism).
            
            The clean algorithms possible are:
            egin{description}
            \item[Hogbom] The classic algorithm: delta function units of emission
            are found iteratively by searching for the peak. Each point is
            subtracted from the full residual image using the shifted and scaled
            point spread function.
            
            \item[Multi-Scale] As the Multi-Scale Clean algorithm is quite new,
            we provide entensive information on its use.
            
            In the Multi-scale Clean, the image is cleaned simultaneously with
            several different beams given by the point spread function convolved
            with components of various shapes and sizes.  The components we use in
            this implementation are upside-down paraboloids multiplied by first
            order spheroidal functions (ie, the same functions used in gridding
            Fourier plane data).  The paraboloids are truncated at zero, and the
            multiplication by the spheroidal function results in a smooth shape
            with minimal power at long baselines.  This shape is scaled to the
            component sizes specified in
            setscales.  As these
            functions have finite extent (unlike a Gaussian), they can easily be
            used with mask images.
            
            For each iteration, the scale size which is able to subtract the most
            flux is chosen (but with a caveat, see below).  The model is then
            built up out of the spheroidal functions of the various scale
            sizes. The scale sizes are set by the
            setscales function, which
            will permit the user to specify the scale sizes explicitly, or will
            optionally take the number of scale sizes to clean for and calculate
            the scale sizes themselves from a power law.
            
            Most images deconvolved with Multi-scale Clean will be dominated by
            extended structure, and the largest scale size will initially remove
            the most flux from the dirty image.  As the algorithm reduces the
            residuals on the largest scale, the residuals on the smaller scales
            will also be reduced, even without cleaning on those size scales (a
            falling sea sinks all boats).  However, at some point, the residual
            image will be dominated by features on smaller size scales.  These
            smaller features will be both positive and negative (ie, to correct
            for the largest size scale being the wrong shape for the true emission
            features).  Later in the algorithm, the magnitude of the residuals on
            all scales will be approximately equal.  At this stage, most of the
            deconvolvable flux has been assimilated into the largest scale size
            components and detailed corrections to the large scale components must
            be made.  At this point, the user may consider switching to a faster
            algorithm such as the Clark Clean.
            
            Masking is fully available with Multi-scale Clean.  No component is
            permitted to place any of its wings outside of the user-supplied
            mask.  If the masking were based upon the different scale components'
            center positions, then the large scale components could place their
            wings outside the mask, but the smaller scale components would
            not be able to make fine scale corrections.  Hence, the
            Multi-scale Clean uses a different mask for each different size
            scale internally.  If the mask is too restrictive or the scales
            are too large, the algorithm may not be able to fit the large
            scales into the mask at all, and the user is warned of this
            condition.
            
            Traditional Clean algorithms use a small loop gain such as 0.1 to
            avoid confusing emission and sidelobes when extended emission is
            present.  However, as MultiScale Clean can image large extended
            structure in a single spheroidal component, a loop gain in the range
            0.5 to 1.0 can be used.  If the largest residual oscillates between
            positive and negative with iteration number, as it can for some
            brightness distributions which include point sources, a lower loop
            gain will improve the imaging and the convergence.
            
            A mild bias favoring cleaning small scale emission has been built into
            the Multi-scale algorithm.  To illustrate the requirement of this bias,
            consider the case of a bright point source with very faint extended
            emission.  Each scale may find its optimal component to subtract at
            the position of the bright point source, but each successively larger
            component will integrate more extended flux.  Hence, the largeest
            scale component will be removed from the residuals.  If most of the
            flux were in the point source, then several smaller negative
            components must be subtracted from the largest component, and finally
            the point component itself may be removed after the extended emission
            has been taken care of.  To prevent this situation from occurring,
            we bias the selection of small-sized components.
            
            nd{description}
            
            Note that for all of these functions except fullmsclean, only a
            quarter of the image may be cleaned. If no mask is set, then the
            cleaned region defaults to the inner quarter. If a mask larger than a
            quarter of the image is set, then only the quarter starting at the
            bottom left corner is used. Algorithm fullmsclean will deconvolve the
            entire field. This is useful when performing a limited accuracy 
            deconvolution (as needed for example in wide-field imaging) but will
            diverge if pushed too deep.
            
            The clean threshold may be either absolute ('0.5Jy') or relative
            ('1\%').
            
          

        Input Parameters:
        	algorithm	 Algorithm to use fullmsclean msclean hogbom 
        	niter		 Number of Iterations, set to zero for no CLEANing 1000 
        	gain		 Loop Gain for CLEANing, try 0.7 for msclean or fullmsclean 0.1 
        	threshold	 Flux level at which to stop CLEANing 0Jy 
        	displayprogress	 Display progress false 
        	model		 Name of images 
        	mask		 Name of mask images used for CLEANing 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	
            
            dc.clean(image='3C273XC1.clean.image', model='3C273XC1.clean.model',
            mask='3C283XC1.mask', niter=1000, gain=0.25, threshold=0.03)

          
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_clean(self, *args, **kwargs)

    def setscales(self, *args, **kwargs):
        """
        setscales(self, scalemethod=string("nscales"), nscales=5, uservector=initialize_vector(3,(double)0.0, (double)3.0, (double)10.0)) -> bool

        Summary
        	Set the scale sizes for MultiScale Clean

        Description
        	
        Set the scale sizes, all required PSF's and Dirty Images for
        MultiScale Clean will be calculated.
        You can either give the number of scales, in which case the the scale
        sizes are set via a power law, or give a vector of scale sizes in pixels.


        Input Parameters:
        	scalemethod	 Method by which scales are set uservector nscales 
        	nscales		 Number of scales 5 
        	uservector	 Vector of scale sizes to use 0.0 3.0 10.0 
        	
        Example:
        	

        dc.setscales(6);


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_setscales(self, *args, **kwargs)

    def ft(self, *args, **kwargs):
        """
        ft(self, model=string(""), transform=string(""), async=False) -> bool

        Summary
        	Fourier transform the specified model

        Description
        	
        Fourier transform the specified model to an image.


        Input Parameters:
        	model		 Name of image 
        	transform	 Name of transform image 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

        deco.ft(model='3C273XC1.nnls.model', transform='3C273XC1.nnls.model.ft')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_ft(self, *args, **kwargs)

    def restore(self, *args, **kwargs):
        """
        restore(self, model=string(""), image=string(""), bmaj=initialize_variant("0rad"), bmin=initialize_variant("0rad"), 
            bpa=initialize_variant("0deg"), async=False) -> bool

        Summary
        	Restore the residuals

        Description
        	
        Restore the residuals to a smoothed version of the model. The model
        images are convolved with the specified Gaussian beam and then the
        residual images are added.  If the beam is not supplied, one will
        be fit to the PSF.


        Input Parameters:
        	model		 Name of input model 
        	image		 Name of output restored image 
        	bmaj		 Major axis of beam 0rad 
        	bmin		 Minor axis of beam 0rad 
        	bpa		 0deg Position angle of beam 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        deco.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
        bmaj='2.0arcsec', bmin='2.0arcsec')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_restore(self, *args, **kwargs)

    def residual(self, *args, **kwargs):
        """
        residual(self, model=string(""), image=string(""), async=False) -> bool

        Summary
        	Find the residuals

        Description
        	
        Calculate the residuals corresponding to the model.
        componentlist. 


        Input Parameters:
        	model		 Names of input models 
        	image		 Names of output residual images 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        deco.residual(model='3C273XC1.clean', complist='3C273XC1.cl',
        image='3C273XC1.clean.residual')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_residual(self, *args, **kwargs)

    def smooth(self, *args, **kwargs):
        """
        smooth(self, model=string(""), image=string(""), bmaj=initialize_variant("0rad"), bmin=initialize_variant("0rad"), 
            bpa=initialize_variant("0deg"), normalize=True, async=False) -> bool

        Summary
        	smooth the image

        Description
        	
        The model image is convolved with the specified Gaussian beam.  By
        default (normalize=T), the beam volume is normalized to unity so that
        the smoothing is flux preserving. The smoothing used in restoration is
        not normalized.


        Input Parameters:
        	model		 Name of input model 
        	image		 Name of output smoothed image 
        	bmaj		 Major axis of beam 0rad 
        	bmin		 Minor axis of beam 0rad 
        	bpa		 Position angle of beam 0deg 
        	normalize	 Normalize volume of psf to unity true 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        - deco.smooth(model='3C273XC1.clean', image='3C273XC1.clean.restored',
        bmaj='2.0arcsec', bmin='2.0arcsec')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_smooth(self, *args, **kwargs)

    def mem(self, *args, **kwargs):
        """
        mem(self, entropy=string("entropy"), niter=20, sigma=initialize_variant("0.001Jy"), targetflux=initialize_variant("1.0Jy"), 
            constrainflux=False, displayprogress=False, 
            model=string(""), prior=string(""), mask=string(""), imageplane=False, async=False) -> bool

        Summary
        	Make the mem image

        Description
        	
        Makes a mem image using the Cornwell-Evans algroithm, using either
        maximum entropy (entropy) or maxmimum emptiness (emptiness).  The
        maximum entropy algorithm is the default.  You can restart a MEM
        deconvolution on an existing model image, but the alpha and beta
        parameters are not yet saved.

        Mask images can be used to restrict where the algorithm puts flux.  A
        prior, or bias, image can provide a priori information to the
        algorithm and effectively limit the support as well as a mask.  The
        prior image can be constructed by smoothing an existing estimate for
        the brightness distribution and clipping.  Any pixel values below 1e-6
        will be clipped to this level, so zero or negative pixels will not
        cause problems.

        Currently, only one Stokes parameter may be deconvolved at a time.
        Stokes $I$ images can be deconvolved with either maximum entropy 
        or maxmimum emptiness.  Stokes $Q$, $U$, or $V$ should be deconvolved
        with maxmimum emptiness, which permits negative pixel values.
        Joint polarization MEM deconvolution is planned for the future.

        The mem entropies possible are:
        egin{description}
        \item[entropy]  The smoothness of the image, relative to some
        prior (also called default or bias) image is maximized.  
        The functional form of the entropy is $H = \sum I ln (I/M)$,
        where $I$ is the mem image brightness and $M$ is the prior image.
        As the prior image is positive definite, the entropy constrains the mem 
        image pixels to be positive, hence only stokes $I$ can be imaged.
        \item[emptiness] The number of pixels with absolute value of the flux
        greater than the noise level is minimized.  This treats positive
        and negative pixel values equally, so it is appropriate for any
        Stokes image.
        nd{description}

        This MEM algorithm works in the image plane (ie, is ignorant of
        visibility data), but performs the convolution by multiplication in
        the Fourier plane.  Not to be confused with this usage of the term
        'image plane', some problems are 'image plane' problems, such as a
        single dish performing On-The-Fly mapping.  Independent noise is added
        at each integration as the beam sweeps over the object (ie, in the
        image plane).  This can lead to a noise signal at non-physically large
        spatial frequencies.  This non-physical signal can be removed by
        convolving the residual image with the PSF.  Also key to this problem
        is that the PSF is of finite extent, permitting the deconvolution of
        nearly the entire dirty image rather than just the inner quarter.
        These options are accessed by setting {	t imageplane} to T.



        Input Parameters:
        	entropy		 entropy to use emptiness entropy 
        	niter		 Number of Iterations, set to zero for no MEMing 20 
        	sigma		 Noise level to try to achieve 0.001Jy 
        	targetflux	 Total image flux to try to achieve 1.0Jy 
        	constrainflux	 Use targetflux as a constraint? (or starting flux) false 
        	displayprogress	 Display progress false 
        	model		 Name of input/output model image 
        	prior		 Name of prior (default) image used for mem 
        	mask		 Mask image restricting emission (all pixels 0 or 1) 
        	imageplane	 Is this an image plane problem (like single dish)? false 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

        deco.mem(entropy='entropy', niter=30, sigma=0.01, targetflux=10.0,
        model='3C273XC1.mem.image', prior='3C283XC1.prior')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_mem(self, *args, **kwargs)

    def makeprior(self, *args, **kwargs):
        """
        makeprior(self, prior=string(""), templateimage=string(""), lowclipfrom=initialize_variant("0.0Jy"), 
            lowclipto=initialize_variant("0.0Jy"), highclipfrom=initialize_variant("9e20Jy"), 
            highclipto=initialize_variant("9e20Jy"), blc=initialize_vector(1, (int)-1), 
            trc=initialize_vector(1, (int)-1), async=False) -> bool

        Summary
        	Make the mem's prior image, or make a mask

        Description
        	
        Makes a prior image for the mem function.  A general way to make a
        prior image is to start with a low resolution image, obtained
        from a smaller array configuration or a lower frequency observation,
        from another image which has been smoothed, or from a single dish
        image.  The low resolution image can then be doctored via clipping
        and regioning to make it acceptable for the mem function.

        Currently, only one Stokes parameter may be used at a time.



        Input Parameters:
        	prior		 output prior image 
        	templateimage	 starting point for prior image 
        	lowclipfrom	 Clip any pixel below this level 0.0Jy 
        	lowclipto	 Any clipped pixel will be given this value 0.0Jy 
        	highclipfrom	 Clip any pixel above this level 9e20Jy 
        	highclipto	 Any clipped pixel will be given this value 9e20Jy 
        	blc		 Bottom left hand corner for box; outside box is clipped -1 
        	trc		 Top right hand corner for box; outside box is clipped -1 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

        deco.makeprior(prior='3C283XC1.prior', templateimage='3C283XC1.mem.smooth',
        clipfrom='0.01Jy', clipto='0.0001Jy', blc=[100,100], trc=[150,150])


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_makeprior(self, *args, **kwargs)

    def mtopen(self, *args, **kwargs):
        """
        mtopen(self, ntaylor=2, scalevector=initialize_vector(3,(double)0.0, (double)3.0, (double)10.0), 
            psfs=std::vector< string >(1, ""), async=False) -> bool

        Summary
        	Init : Make a series of images using a Multi-Term Clean algorithm

        Description
        	
            
            Makes a series of images.

            For N terms in the polynomial, supply a list of 2N-1 Hessian elements (psfs), and the
            scale sizes.
            
          

        Input Parameters:
        	ntaylor		 Number of terms in the taylor polynomial 2 
        	scalevector	 Vector of scale sizes to use 0.0 3.0 10.0 
        	psfs		 Intpu : List of names of 2N-1 psfs. This is valid only for a Taylor-polynomial model. 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

         xxx    

          
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_mtopen(self, *args, **kwargs)

    def mtclean(self, *args, **kwargs):
        """
        mtclean(self, residuals=std::vector< string >(1, ""), models=std::vector< string >(1, ""), niter=1000, 
            gain=0.1, threshold=initialize_variant("0Jy"), displayprogress=False, 
            mask=string(""), async=False) -> record *

        Summary
        	Make a series of images using a Multi-Term Clean algorithm

        Description
        	
            
            Makes a series of images.

            Supply a list of N residual images and a corresponding list of 2N-1 Hessian elements (psfs).
            
            This way, for each field or partial-run, one can choose how many terms to operate with, 
            changing this number depending on the signal-to-noise level. 
         
          

        Input Parameters:
        	residuals	 Input : List of names of N residual images 
        	models		 Output : List of names of N model images 
        	niter		 Number of Iterations, set to zero for no CLEANing 1000 
        	gain		 Loop Gain for CLEANing, try 0.7 for msclean or fullmsclean 0.1 
        	threshold	 Flux level at which to stop CLEANing 0Jy 
        	displayprogress	 Display progress false 
        	mask		 Name of mask images used for CLEANing 
        	async		 Run asynchronously in the background? false 
        	
        Example:
        	

         xxx    

          
        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_mtclean(self, *args, **kwargs)

    def mtrestore(self, *args, **kwargs):
        """
        mtrestore(self, models=std::vector< string >(1, ""), residuals=std::vector< string >(1, ""), images=std::vector< string >(1, ""), 
            bmaj=initialize_variant("0rad"), bmin=initialize_variant("0rad"), 
            bpa=initialize_variant("0deg"), async=False) -> bool

        Summary
        	Restore the Multi-Term residuals

        Description
        	

        The model images are smoothed by the specified Gaussian beam.
        The principal solution is computed from the residuals.
        The smoothed models are added to these new residuals. 

        This ensures that any undeconvolved source flux has been transformed
        into the Taylor-coefficient basis, before being added into the smoothed
        Taylor-coefficient model images.

        ( If the beam is not supplied, one will be fit to the PSF ). 


        Input Parameters:
        	models		 Input : Name of input model 
        	residuals	 Input : Name of residual image 
        	images		 Output : Name of output restored image 
        	bmaj		 Major axis of beam 0rad 
        	bmin		 Minor axis of beam 0rad 
        	bpa		 0deg Position angle of beam 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        deco.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
        bmaj='2.0arcsec', bmin='2.0arcsec')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_mtrestore(self, *args, **kwargs)

    def mtcalcpowerlaw(self, *args, **kwargs):
        """
        mtcalcpowerlaw(self, images=std::vector< string >(1, ""), residuals=std::vector< string >(1, ""), alphaname=string(""), 
            betaname=string(""), threshold=initialize_variant("0.0Jy"), 
            calcerror=False, async=False) -> bool

        Summary
        	Interpret Taylor coefficients as a power law, and compute spectral index

        Description
        	

        Take ratios of restored images to compute alpha and beta



        Input Parameters:
        	images		 Input : Names of input restored images 
        	residuals	 Input : Names of input residuals images ( for error calcs ) 
        	alphaname	 Output : Name of output spectral-index image 
        	betaname	 Output : Name of output spectral-curvature image 
        	threshold	 Threshold 0.0Jy 
        	calcerror	 Calculate an error image for spectral index false 
        	async		 Run asynchronously in the background false 
        	
        Example:
        	

        deco.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
        bmaj='2.0arcsec', bmin='2.0arcsec')


        --------------------------------------------------------------------------------
        	      
        """
        return _deconvolver.deconvolver_mtcalcpowerlaw(self, *args, **kwargs)

deconvolver_swigregister = _deconvolver.deconvolver_swigregister
deconvolver_swigregister(deconvolver)

# This file is compatible with both classic and new-style classes.


