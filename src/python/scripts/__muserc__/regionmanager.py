# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_regionmanager', [dirname(__file__)])
        except ImportError:
            import _regionmanager
            return _regionmanager
        if fp is not None:
            try:
                _mod = imp.load_module('_regionmanager', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _regionmanager = swig_import_helper()
    del swig_import_helper
else:
    import _regionmanager
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class regionmanager(_object):
    """Proxy of C++ casac::regionmanager class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, regionmanager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, regionmanager, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> regionmanager"""
        this = _regionmanager.new_regionmanager()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _regionmanager.delete_regionmanager
    __del__ = lambda self : None;
    def absreltype(self, absrelvalue=0):
        """
        absreltype(self, absrelvalue=0) -> string

        Summary
        	Convert region type value to a string

        Description
        	

        This function is not intended for general user use.

        Regions may be specified with coordinates which are absolute or
        relative.  This function converts the integer code defining the
        absolute/relative type of the coordinates (which is stored in the
        region) into a string (maybe for printing purposes).

        The different types are


        Integer     String      Description
        1            abs        Absolute coordinate
        2            relref     Relative reference pixel
        3            relcen     Relative to center of image
        4            reldir     Relative to some direction

         


        Input Parameters:
        	absrelvalue	 Region type value 0 Integer - 1, 2, 3, 4 
        	
        Example:
        	

        - r = rg.box(blc=[3,40], trc=[80,90])   # Create region
        - v = r.get('arblc')                    # Get absrel value vector for blc
        - for i in range( len(v) ):
        +    print rg.absreltype(v[i])          # Print string conversion for each axis
        -


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_absreltype(self, absrelvalue)

    def box(self, *args, **kwargs):
        """
        box(self, blc=initialize_vector(1, (double)0), trc=initialize_vector(1, (double)-1), inc=initialize_vector(1, (double)1), 
            absrel=string("abs"), frac=False, comment=string("")) -> record *

        Summary
        	Create a pixel box region

        Description
        	

        This function creates a multi-dimensional pixel box region.  The box is
        specified by a bottom-left corner, and top-right corner and an increment
        (or stride).  Pixel coordinates are considered to run from 1 at the
        bottom left corner of the image to the image shape at the top-right
        corner of the image. 

        You can specify whether the coordinates are given as pixel coordinates
        ({\stfaf frac=F}) or fractions of the image shape ({\stfaf frac=T}). 
        Absolute fractions are in the range [0,1]. 

        You can also specify whether the coordinates are given as absolute
        coordinates ({\stfaf absrel='abs'}) or relative to the reference pixel
        ({\stfaf absrel='relref'}) or relative to the center of the image
        ({\stfaf absrel='relcen'}). 



        Input Parameters:
        	blc		 blc of the box 0 Unity 
        	trc		 trc of the box -1 Shape 
        	inc		 increment 1 
        	absrel		 Absolute or relative coordinates relref relcen abs 
        	frac		 Pixel or fractional coordinates false F 
        	comment		 A comment stored with the region 
        	
        Example:
        	  

        ia.open('myimage')
        ia.shape()
        [155 178 256]

        r = rg.box()                 # create region
        -
        - ia.boundingbox(r)
        [blc=[1 1 1] , trc=[155 178 256] , inc=[1 1 1] , bbShape=[155 178 256] , 
        regionShape=[155 178 256] , imageShape=[155 178 256] ] 


        This region, on application to an image, selects the entire image.


        Example:
        	  

        - ia.open('myimage')
        - ia.shape()
        [155 178 256]  
        -
        - r=rg.box(blc=[5,10])
        - ia.boundingbox(r)
        [blc=[5 10 1] , trc=[155 178 256] , inc=[1 1 1] , bbShape=[151 169 256] , 
        regionShape=[151 169 256] , imageShape=[155 178 256] ] 


        This region is only specified for the first two axes of the blc.  
        Automatic extension rules apply for the other axis and the trc
        (defaults to the shape).


        Example:
        	  

        - ia.open('myimage')
        - ia.shape()
        [155 178 256]
        -
        - r = rg.box(blc=[10, 10, 10], trc=[20, 20, 20], inc=[2, 2, 2])
        - ia.boundingbox(r)                                        
        [blc=[10 10 10] , trc=[20 20 20] , inc=[2 2 2] , bbShape=[11 11 11] , 
        regionShape=[6 6 6] , imageShape=[155 178 256] ] 
        -
        stats=ia.statistics(region=r, list=False);
        stats['npts'][0]
        216


        This region picks out every other pixel in the 3D box.  The
        ``regionShape'' field of the bounding box record does reflect the
        increment whereas ``bbShape'' does not.  You can see that the number of
        points used in determining the statistics (216) reflects the increment
        as well. 


        Example:
        	  

        THIS EXAMPLE IS NOT VALID YET

        - ia.open('myimage')
        - ia.shape()
        [64 128]  
        -
        - rmd = rg.dflt()
        - r = rg.box([-5,-10], [rmd,20], absrel='relcen')
        -
        - ia.boundingbox(r)
        [blc=[28 55] , trc=[64 85] , inc=[1 1] , bbShape=[37 31] , 
        regionShape=[37 31] , imageShape=[64 128] ] 


        The region is specified in pixels relative to the center of the image. 
        Note the use of the default value ({\cf rg.dflt()}) to default the first
        axis of the trc argument to the image shape without having to know the
        image shape. 


        Example:
        	  

        - ia.open('myimage')
        - ia.shape()
        [155 178 256] 
        -
        - summ=ia.summary(list=False)
        - summ['header']['refpix']
        [90 90 1]
        -
        - r = rg.box([-0.25,-0.3], [0.25, 0.5], frac=True, absrel='relref')
        - ia.boundingbox(r)
        [blc=[39 37 1] , trc=[116 178 256] , inc=[1 1 1] , bbShape=[78 142 256] , 
        regionShape=[78 142 256] , imageShape=[155 178 256] ] 


        This example shows selection by relative to reference pixel fractional
        coordinates plus auto extension to unspecified axes. 


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_box(self, *args, **kwargs)

    def frombcs(self, *args, **kwargs):
        """
        frombcs(self, csys=initialize_record(""), shape=initialize_vector(1, (int)0), box=string(""), chans=string(""), 
            stokes=string(""), stokescontrol=string("a"), region=initialize_variant("")) -> record *

        Summary
        	Create a world coordinate region based on box-chan-stokes input

        Description
        	

        This function creates a multi-dimensional world coordinate region based
        on box, chans, stokes inputs familiar from image analysis tasks. It is
        being introduced as a temporary means of refactoring some python level
        task code into C++. However, if users find it to have value, its existence
        can be permanent.


        Input Parameters:
        	csys		 Coordinate system record. Must be specified. 
        	shape		 shape of the image. Necessary for boundedness checks. Must have the same number of dimensions as the associated coordinate system. Default = [] 0 
        	box		 Direction plane box specification as normally provided in image analysis tasks. '' means use entire directional plane as specified in shape. Default ''. 
        	chans		 Channel spec as normally provided to image analysis tasks. '' means use all channels, Default ''. 
        	stokes		 Stokes spec as normally provided to image analysis tasks. '' means use stokescontrol for setting stokes. Default ''. 
        	stokescontrol	 Polarization set to use if stokes parameter is not specified. Choices are 'a' (use all stokes) and 'f' (use first stokes). Default 'a'. a 
        	region		 Named region in the form imagename:regionname or region dictionary. Used only if box, chans, stokes not specified. Default ''. 
        	
        Example:
        	  


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_frombcs(self, *args, **kwargs)

    def complement(self, *args, **kwargs):
        """
        complement(self, region=initialize_variant(""), comment=string("")) -> record *

        Summary
        	Create the complement of a world region

        Description
        	
        This function (short-hand name {	t comp}) creates the complement of
        a world region(s). 

        The region parameter can be a single region record defining a simple
        or complex region or it can contain several region records in a 
        Python dictionary.  If multiple regions are given then the union of
        this set of regions is taken first, and the complement is found from
        the union.

        NOTE: ia.statistics() is UNABLE to handle complement regions in CASA yet.



        Input Parameters:
        	region		 The world region Region tool 
        	comment		 A comment stored with the region String 
        	
        Example:
        	  

        - ia.open('hcn')
        - csys = ia.coordsys()
        - ia.shape()
        [155 178]
        -
        - blc = '17:42:29.303 -28.59.18.600'
        - trc = '17:42:28.303 -28.59.10.600'
        - r2 = rg.wbox(blc,trc,[1,2],csys.torecord())
        - r3 = rg.complement(r2);
        -
        - ia.statistics(region=r2)                          # Some output discarded 
        Selected bounding box [90, 90] to [103, 98]         
        No pts   = 126
        -
        - ia.statistics(region=r3)
        Selected bounding box [1, 1] to [155, 178]     # Some output discarded 
        No pts   = 27464


        As expected,  the number of pixels in the complement
        is $(155*178)-126=27464$

        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_complement(self, *args, **kwargs)

    def concatenation(self, *args, **kwargs):
        """
        concatenation(self, box=initialize_variant(""), regions=initialize_variant(""), comment=string("")) -> record *

        Summary
        	Concatenate world regions along a new axis

        Description
        	
        This function (short-hand name {	t concat}) creates a region which is
        the concatenation along a new axis of the given world regions. 

        This function is similar to the
        extension function.  The
        {\stfaf concatenation} function allows you to take many world regions,
        and concatenate them along one axis (rather than take one region and
        extend it along many axes which is what function {\stff extension}
        does).

        For example, you may have generated a different polygonal region for
        each spectral pixel of a spectral-line cube and you wish to concatenate them
        together to form the overall region for use in a deconvolution
        application. 

        The axis to concatenate along is specified as a 1-dimensional world box.
        The shape of the 1D box must contain as many pixels (although you
        don't have to specify it in pixels) as there are regions
        to concatenate.   

        Because this function is most likely to be used in a script, the
        interface takes a record containing {\stff region} records, Python
        dictionaries, as there might be a lot of them.



        Input Parameters:
        	box		 The axis to concatenate along world box region 
        	regions		 World regions Record containing world regions 
        	comment		 A comment stored with the region String 
        	
        Example:
        	

        - ia.open('cube')
        - csys = ia.coordsys()
        - rg.setcoordinates(csys.torecord(), verbose=False) # Don't tell us each time
                                                            # private coordinates used
        - box = rg.wbox(blc='20pix', trc='25pix', pixelaxes=[2])
        - bb = ia.boundingbox(box)
        -
        - regs = {};
        - local x, y;
        - for i in bb.blc[3]:bb.trc[3]:
        + # Some code in function `mypolygon' generates the 
        + # x and y vectors for this spectral pixel, perhaps interactively
        +    
        +    mypolygon(x,y);
        +    regs['reg'+str(j)] = rg.wpolygon(x,y,[0,1])
        - rc = rg.concatenation(box, regs)
        -
        - ia.statistics(region=rc, axes=[1,2])
        Plane Freq         Npts Sum            Mean           Rms            Sigma          Minimum        Maximum        
        20    1.413724e+09 25   -4.778154e+00  -1.911262e-01  2.578399e-01   1.766359e-01   -4.252437e-01  1.820721e-01   
        21    1.413744e+09 40   -7.476902e+00  -2.990761e-01  3.692736e-01   2.210687e-01   -6.073643e-01  1.634156e-01   
        22    1.413763e+09 32   -2.696485e+00  -1.078594e-01  1.916686e-01   1.617070e-01   -3.295788e-01  1.422531e-01   
        23    1.413783e+09 77   4.889158e-01   1.955663e-02   3.148451e-02   2.518293e-02   -3.671944e-02  6.521463e-02   
        24    1.413803e+09 25   -1.337832e+00  -5.351327e-02  6.296221e-02   3.385893e-02   -1.232493e-01  1.014871e-02   
        25    1.413823e+09 15   1.091297e+00   4.365189e-02   7.252339e-02   5.910932e-02   -6.364560e-02  1.630955e-01   



        In this example, we create a 1D box and use it to concatenate 2D xy
        polygons along the z axis.  We then ask for the statistics of each plane
        in the region.  There is a differerent number of pixels per plane 
        as each polygon is different.


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_concatenation(self, *args, **kwargs)

    def deletefromtable(self, *args, **kwargs):
        """
        deletefromtable(self, tablename=string(""), regionname=string("")) -> bool

        Summary
        	Delete regions from a Table

        Description
        	


        This function deletes a region stored in an casa  Table.  

        For the {\stfaf tablename} argument, 

        you have to give  the name of an existing
        CASA table on disk (any kind of table).

        You specify the name of the region with the {\stfaf regionname}
        arguments.  If you set {\stfaf regionname=''} then nothing is done.  The names of all the regions stored in a Table can be found
        with the function
        namesintable. 



        Input Parameters:
        	tablename	 The table Image tool, table tool or String 
        	regionname	 Name(s) of the region(s) to delete Vector of strings 
        	
        Example:
        	

        - names = rg.namesintable(hcn)
        - rg.deletefromtable(img, names[0])

         
        In this example, we delete the first region that is reported to be in the Table {	t 'hcn'}.

        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_deletefromtable(self, *args, **kwargs)

    def difference(self, *args, **kwargs):
        """
        difference(self, region1=initialize_record(""), region2=initialize_record(""), comment=string("")) -> record *

        Summary
        	Create the difference of two world regions

        Description
        	
        This function (short-hand name {\stff diff}) creates
        a region which is the difference of two world regions.  The order
        of the regions is important.

        The difference consists of all pixels masked-on in the first
        region and not masked-on in the second region.



        Input Parameters:
        	region1		 The first world region 
        	region2		 The second world region Region tool 
        	comment		 A comment stored with the region String 
        	
        Example:
        	  

        - ia.open('hcn')
        - csys = ia.coordsys()
        - rg.setcoordinates(csys.torecord())
        -
        - blc = '10pix 10pix'
        - trc = '60pix 60pix'
        - r1 = rg.wbox(blc,trc,[0,1])
        -
        - blc = '50pix 50pix'
        - trc = '80pix 80pix'
        - r2 = rg.wbox(blc, trc, [0,1])
        - 
        - r3 = rg.difference(r1, r2)                        # r1 - r2
        -
        - ia.statistics(region=r1)                          # Some output discarded 
        Selected bounding box [10, 10] to [60, 60]
        No pts   = 2601
        -
        - ia.statistics(region=r3)                          # Some output discarded 
        Selected bounding box [10, 10] to [60, 60]
        No pts   = 2480
        -
        -
        - r4 = rg.difference(r2, r1)                        # r2 - r1
        -
        - ia.statistics(region=r2)                          # Some output discarded 
        Selected bounding box [50, 50] to [80, 80]
        No pts   = 961
        -
        - ia.statistics(region=r4)                          # Some output discarded 
        Selected bounding box [50, 50, 1] to [80, 80, 64]
        No pts   = 840


        We use pixel units and boxes in this example to make it clear what is
        happening.  The two regions overlap in the top right corner area of
        region {\stf r1} by an area of $11	imes11=121$~pixels.  Therefore, the
        difference region {\stf r3} has $2601-121=2480$~pixels in it.  For
        difference region {\stf r4}, the region of overlap is the bottom left
        corner area of region {\stf r2} and still contains 121~pixels.  We expect
        $961-121=840$~pixels in the differnce region.  


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_difference(self, *args, **kwargs)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Destroy this regionmanager

        Description
        	
         
        This function destroys the contents of the {\stf regionmanager} 	ool(including its GUI).  The 	ool\ still exists as a Glish variable, but
        it is no longer a Regionmanager ! You are unlikely to need this
        function. 
         

        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_done(self)

    def selectedchannels(self, *args, **kwargs):
        """
        selectedchannels(self, specification=string(""), shape=initialize_vector(1, (int)0)) -> std::vector< int >

        Summary
        	Get an array of zero-based selected channel numbers from an input string specificaiton.

        Description
        	
        This method returns all the selected zero-based channel numbers from the specified string within the image.



            

        Input Parameters:
        	specification	 Valid channel specification. See help par.chans for examples. 
        	shape		 Image shape. Used to determine if the specificaiton lies outside the image. 0 
        	
        Example:
        	
                ia.fromshape('',[20,20,20])
                rg.setcoordinates(ia.coordsys().torecord())
                selected_channels = rg.selectedchannels(specification='range=[40km/s,50km/s]', shape=ia.shape())
                ia.done()
            
        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_selectedchannels(self, *args, **kwargs)

    def fromtextfile(self, *args, **kwargs):
        """
        fromtextfile(self, filename=string(""), shape=initialize_vector(1, (int)0), csys=initialize_record("")) -> record *

        Summary
        	Create a region dictionary from a region text file.

        Description
        	
        This function reads a text file containing region descriptions and
        converts it to a python dictionary.

            

        Input Parameters:
        	filename	 List of text file containing the region description 
        	shape		 Image shape. 0 
        	csys		 Coordinate system record. Defaults to coordinate system used in rg.setcoordinates() 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_fromtextfile(self, *args, **kwargs)

    def fromtext(self, *args, **kwargs):
        """
        fromtext(self, text=string(""), shape=initialize_vector(1, (int)1), csys=initialize_record("")) -> record *

        Summary
        	Create a region dictionary from a region text string.

        Description
        	
        This function reads a region region text descriptions and
        converts it to a python region dictionary.

            

        Input Parameters:
        	text		 region description 
        	shape		 Image shape, only used if first region is a difference. 1 
        	csys		 Coordinate system record. Defaults to coordinate system used in rg.setcoordinates() 
        	
        Example:
        	
        ia.open('test.image')
        csys=ia.coordsys()
        rg.setcoordinates(csys.torecord())
        a=rg.fromtext('ellipse [[04h31m38.44139, 18d13m57.0861], [1.0arcsec, 1.0arcsec], 0.00000000deg]', shape=[1500, 1500,    1, 1])
        ia.done()
         
        In this example, we create a circular region of 1 arcsec radius centered on J2000 04h31m38.44139  18d13m57.0861


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_fromtext(self, *args, **kwargs)

    def fromfiletorecord(self, *args, **kwargs):
        """
        fromfiletorecord(self, filename=string(""), verbose=True, regionname=string("")) -> record *

        Summary
        	Create a region record(s) from a file(s).

        Description
        	
        This function reads files containing ImageRegion objects and turns them
        into Region Records.

        The intended use for this method is to read the file saved by the casa
        viewer and turn the files contents into regions that are usabla by the
        image analysis tool.



        Input Parameters:
        	filename	 List of files containing the Image Regions File name(s) 
        	verbose		 Report successful saves true true 
        	regionname	 Name(s) of the region(s) when saved in the table Self naming 
        	
        Example:
        	

        - img = ia.open('hcn')
        - rg.fromfiletorecord(T, 'x1 x2', 'file1, file2', r1, r2)
        - ia.statistics( region=r1, verbose=True )
        - ia.statistics( region=r2, verbose=True ) 

         
        In this example, we create two regions called  {\stf r1} and {\stf r2} 
        from the files ???
        The regions are renamed to `x1' and `x2' as they are stored.


        Example:
        	
        e
        - img = ia.open('hcn')
        - r1 = rg.box()f
        - r2 = rg.quarter()
        - rg.fromglobaltotable(img, T, F, '', r1, r2)
        - rg.namesintable(img)
        x1 x2

         
        In this example, we save two regions called {\stf r1} and {\stf r2} to
        the table (previously containing no regions) referred to by the image
        tool {\stf im}.  The names for regions are made up for us as we don't
        specify them.  Note that because the regions are specified by the
        special \glish\ `...' argument (it has no actual argument name), we
        must give the {\stfaf regionname} argument explcitly as an empty vector
        of strings (else \glish\ will take the empty string as a region). 


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_fromfiletorecord(self, *args, **kwargs)

    def tofile(self, *args, **kwargs):
        """
        tofile(self, filename=string(""), region=initialize_record("")) -> bool

        Summary
        	Create a region record file that can be read by from filetorecord.

        Description
        	
        This function is to store a region created by the regionmanager in a disk file for future use



        Input Parameters:
        	filename	 List of files containing the Image Regions File name(s) 
        	region		 region record/dict to store in the file 
        	
        Example:
        	

        - img = ia.open('hcn')
        - imcs=ia.coordsys()
        - blc = ['16:28:25.50',  '+040.49.05.61']
        - trc = ['16:24:28.67', '+041.45.28.43']
        - r1 = rg.wbox(blc=blc,trc=trc,pixelaxes=[0,1],csys=imcs.torecord())
        - rg.tofile('myboxregion', r1)
        - r1readback=rg.fromfiletorecord('myboxregion')

         
        In this example we create a box region using world coordinates for blc and trc. We save that on disk in a file called {	t 'myboxregion'}.
        Then we read it back using the function rg.fromfiletorecord and store it in a variable {	t r1readback}. {	t r1} and {	t r1readback} should be
        identical. 


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_tofile(self, *args, **kwargs)

    def fromrecordtotable(self, *args, **kwargs):
        """
        fromrecordtotable(self, tablename=string(""), regionname=initialize_variant(""), regionrec=initialize_record(""), 
            asmask=False, verbose=True) -> string

        Summary
        	Save regions stored in a record into a Table

        Description
        	


        This function saves regions into an casa Table
        For the {\stfaf tablename} argument the user should be the name of an existing
        ipspp\ Table on disk (any kind of table).

        If the parameter {	t asmask} is {	t True} then the table has to be an image table.
        A mask makes sense with an image only.  


        You can specify the name the region will have ({\stfaf
        regionname}) when it is saved in the Table.  If you don't specify this,
        a digit based name is assigned to it or if specify a name that already
        exists a new one will be generated which is close but different. The
        function returns you the name the region is assigned



        Input Parameters:
        	tablename	 The table Image tool, table tool or String 
        	regionname	 Name(s) of the region(s) when saved in the table Vector of strings 
        	regionrec	 Region(s) to save Record of region tool(s) 
        	asmask		 save region as a mask rather than region false false 
        	verbose		 Report successful saves true True 
        	
        Example:
        	

        - ia.open('hcn')
        - cs=ia.coordsys()
        - blc = '16:28:25.50 +040.49.05.61'
        - trc = '16:24:28.67 +041.45.28.43'
        - r1 = rg.wbox(blc='10pix 20pix',trc='30pix 40pix',pixelaxes=[0,1],csys=cs.torecord())
        - r2 = rg.wbox(blc=blc,trc=trc,pixelaxes=[0,1],csys=cs.torecord())
        - rg.fromrecordtotable('hcn', 'x', r1)
        x
        - rg.fromrecordtotable('hcn', 'x', r2)
        x0
        - rg.namesintable('hcn')
        x x0


         


        Example:
        	
        2 CASA image files on disk 'hcn1' 'hcn2'

        - names = rg.namesintable('hcn1')
        - r = rg.fromtabletorecord('hcn1', names[0])
        - rg.namesintable('hcn2')
        - rg.fromrecordtotable('hcn2', names[0], r)


        In this example, we recover a region into a record
        from one image, and then copy them to another.


        Example:
        	

        ####In this example a region is saved as a mask 
        ia.open('myfancy.image')
        csys=ia.coordsys()
        ia.done()
        ##Lets make a world-box  region 
        wbox=rg.wbox(['10pix', '10pix', '0pix', '0pix'], ['20pix', '20pix', '0pix', '0pix'], csys=csys.torecord())
        ###save that into the image as a mask rather than just a region and assign it the name
        ###mask1
        rg.fromrecordtotable('myfancy.image', 'mask1', wbox, asmask=True)
        ###now let us set that as default mask
        ia.open('myfancy.image')
        ia.maskhandler('set', 'mask1')
        ia.done()
        ###and now let us view that image
        viewer('myfancy.image')

        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_fromrecordtotable(self, *args, **kwargs)

    def fromtabletorecord(self, *args, **kwargs):
        """
        fromtabletorecord(self, tablename=string(""), regionname=initialize_variant(""), verbose=True) -> record *

        Summary
        	Restore regions from a Table to a record

        Description
        	

        This function restores a region from an ipspp\ Table
        to the global name space.

        For the {\stfaf tablename} argument, you can specify an
        image 	ool, a table 	ool,
        or a string.  If you give a string, it should be the name of an existing
        ipspp\ table on disk (any kind of table). 

        If {\stfaf numberfields} is F, then the field names of the
        record are the same as they are in the Table.  Otherwise,
        the regions are put into numbered fields (the field
        names could be anything).

        You can use the function
        namesintable to find out the
        names of the regions in the Table. 



        Input Parameters:
        	tablename	 The table Image tool, table tool or String 
        	regionname	 Name of the region(s) to restore All 
        	verbose		 Report successful restores true True 
        	
        Example:
        	

        - img = ia.open('hcn')
        - rec = rg.fromtabletorecord(img, numberfields=T)
        - print is_region(rec[0])


        The record fields are numbered, not named.


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_fromtabletorecord(self, *args, **kwargs)

    def intersection(self, *args, **kwargs):
        """
        intersection(self, regions=initialize_variant(""), comment=string("")) -> record *

        Summary
        	Create the intersection of some world regions

        Description
        	
        This function (short-hand name {\stff int}) creates a region which is
        the intersection of the given world regions.   The input regions can
        themselves be compound regions (such as the union or intersection etc). 
        The input regions must be provided as a Python dictionary of regions
        (see examples).




        Input Parameters:
        	regions		 World regions and comment Region tools or record of region tools, and String 
        	comment		 A comment stored with the region String 
        	
        Example:
        	

        - ia.open('hcn')
        - csys = ia.coordsys()
        - rg.setcoordinates(csys.torecord())
        -
        - blc = '10pix 10pix 1pix'
        - trc = '60pix 60pix 1pix'
        - r1 = rg.wbox(blc=blc, trc=trc, pixelaxes=[0,1,2])
        -
        - x = qa.quantity([50,55,58,65,58,53,50], 'pix')
        - y = qa.quantity([50,53,69,70,63,58,55], 'pix')
        - r2 = rg.wpolygon(x=x, y=y, pixelaxes=[0,1])
        - 
        - regions= {'region1':r1, 'region2':r2}
        - r3 = rg.intersection(regions, 'This is the comment')
        - 
        - ia.boundingbox(r1)
        [blc=[10 10 1] , trc=[60 60 256] , regionShape=[51 51 256] , imageShape=[155 178 256] ] 
        - ia.boundingbox(r2)
        [blc=[50 50 1] , trc=[65 70 256] , regionShape=[16 21 256] , imageShape=[155 178 256] ] 
        - ia.boundingbox(r3)
        [blc=[50 50 1] , trc=[60 60 256] , regionShape=[11 11 256] , imageShape=[155 178 256] ]
        -
        - ia.statistics(region=r3)                           # Some output discarded
        NORMAL: Selected bounding box [50, 50, 1] to [60, 60, 1]
        Number points = 51            



        In this example, we use pixel coordinates so that it is clear what is
        happening.  You can see that the number of pixels in the intersection
        (51) is less than the number in the bounding box of the intersection
        (121) because the intersection is actually polygonal and does not fill
        the bounding box. 


        Example:
        	  

        - ia.open('onno')
        - csys = ia.coordsys()
        - x = qa.quantity([3,6,9,6,5,5,3],'pix')
        - y = qa.quantity([3,4,7,9,7,5,5],'pix')
        -
        - regions = {};
        - regions['poly'] = rg.wpoly(x,y,[1,2],csys.torecord())
        -
        - blc = '17:42:29.303 -28.59.18.600'
        - trc = '17:42:28.303 -28.59.10.600'
        - regions['box'] = rg.wbox(blc,trc,[0,1],csys.torecord())
        -
        - r3 = rg.intersection(regions,'The mysteries of CASA')


        This example is the same as the prevoius one, except the regions are
        provided to the intersection function in a record, rather than directly in the
        call sequence.


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_intersection(self, *args, **kwargs)

    def ispixelregion(self, *args, **kwargs):
        """
        ispixelregion(self, region=initialize_record("")) -> bool

        Summary
        	Is this region a pixel region ?

        Description
        	
        NOT IMPLEMENTED IN CASA

        This function returns T if the region is a pixel region.
        For any other \glish\ variable it returns F.



        Input Parameters:
        	region		 The region Region tool 
        	
        Example:
        	

        - ia.open('hcn')
        - csys = ia.coordsys()
        - r1 = rg.box()                          # A pixel region
        - r2 = rg.wbox(csys=csys.torecord())     # A world region
        - rg.ispixelregion(r1)
        T
        - rg.ispixelregion(r2)
        F
        - x = [20,30]
        - rg.ispixelregion(x)
        F


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_ispixelregion(self, *args, **kwargs)

    def isworldregion(self, *args, **kwargs):
        """
        isworldregion(self, region=initialize_record("")) -> bool

        Summary
        	Is this region a world region ?

        Description
        	
        NOT IMPLEMENTED IN CASA

        This function returns T if the region is a world region.
        For any other \glish\ variable it returns F.



        Input Parameters:
        	region		 The region Region tool 
        	
        Example:
        	

        - ia.open('hcn')
        - csys = ia.coordsys()
        - r1 = rg.box()                         # A pixel region
        - r2 = rg.wbox(csys=csys.torecord())    # A world region
        - rg.isworldregion(r1)
        F
        - rg.isworldregion(r2)
        T
        - x = [20,30]
        - rg.isworldregion(x)
        F


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_isworldregion(self, *args, **kwargs)

    def namesintable(self, *args, **kwargs):
        """
        namesintable(self, tablename=string("")) -> std::vector< std::string >

        Summary
        	Find the names of the regions stored in a Table

        Description
        	

        This function returns the names of regions stored in an CASA Table.  

        For the {\stfaf tablename} argument, you can specify a string; it should be the name of an existing
        ipspp\ table on disk (any kind of table). 



        Input Parameters:
        	tablename	 The table Image tool, table tool or String 
        	
        Example:
        	


        - names=rg.namesintable('hcn')
        - names
        r1 poly2 int0


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_namesintable(self, *args, **kwargs)

    def setcoordinates(self, *args, **kwargs):
        """
        setcoordinates(self, csys=initialize_record("")) -> bool

        Summary
        	Set new default Coordinate System

        Description
        	
         
        This function allows you to (re)set the default Coordinate System
        used by the functions that make world regions.  If you don't specifiy a
        Coordinate System when you make the world region, the default Coordinate
        System, if there is one, is used.   The Coordinate System is
        stored in a {\stf coordinates} 	ool\ and is created with
        the coordsys 	oolfunction.

        Normally, the world region creating functions like
        wbox and
        wpolygon will issue a message
        each time the private Coordinate System is used.  However, if you set
        {\stfaf verbose=F} then this will not occur. 

         


        Input Parameters:
        	csys		 Default Coordinate System for use in world regions Coordinate tool 
        	
        Example:
        	

        - ia.open('quiqui')
        - csys = ia.coordsys()
        - rg.setcoordinates(csys.torecord())
        - r1 = rg.wbox()
        Using private CoordinateSystem from image 'quiqui'


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_setcoordinates(self, *args, **kwargs)

    def makeunion(self, *args, **kwargs):
        """
        makeunion(self, regions=initialize_variant(""), comment=string("")) -> record *

        Summary
        	Create a union of world regions

        Description
        	

        This function takes a minimum of two world regions and creates a region which
        is the union of the given regions.  The input regions can themselves be
        compound regions (such as the union or intersection etc).   The input
        regions must be a Pythion dictionary of at leat two regions
        (see examples).



        Input Parameters:
        	regions		 World regions and comment Record/dict of regions to be unionized (the key names are immaterial) 
        	comment		 A comment stored with the region 
        	
        Example:
        	  

        - ia.open('onno')
        - csys = ia.coordsys()
        - x = qa.quantity([3,6,9,6,5,5,3],'pix')
        - y = qa.quantity([3,4,7,9,7,5,5],'pix')
        - r1 = rg.wpoly(x,y,[1,2],csys.torecord())
        -
        - blc = '17:42:29.303 -28.59.18.600'
        - trc = '17:42:28.303 -28.59.10.600'
        - r2 = rg.wbox(blc,trc,[0,1],csys.torecord())
        -
        - regions= {'region1':r1, 'region2':r2}
        - r3 = rg.makeunion(regions,'The mysteries of CASA')
        - 
        - ia.shape()
        [155 178 256]  
        - ia.boundingbox(r1)
        [blc=[3 3 1] , trc=[9 9 256] , inc=[1 1 1] , bbShape=[7 7 256] ,
        regionShape=[7 7 256] , imageShape=[155 178 256] ] 
        - ia.boundingbox(r2)
        [blc=[90 90 1] , trc=[103 98 256] ,  inc=[1 1 1] , bbShape=[14 9 256] ,
        regionShape=[14 9 256] , imageShape=[155 178 256] ] 
        - ia.boundingbox(r3)
        [blc=[3 3 1] , trc=[103 98 256] ,  inc=[1 1 1] , bbShape=[101 96 256] ,
        regionShape=[101 96 256] , imageShape=[155 178 256] ] 
        -
        - ia.statistics(region=r1)
        Selected bounding box [3, 3, 1] to [9, 9, 256]
        Number points = 6400          
        -
        - ia.statistics(region=r2)
        Selected bounding box [90, 90, 1] to [103, 98, 256]
        Number points = 32256         
        -
        - ia.statistics(region=r3) 
        Selected bounding box [3, 3, 1] to [103, 98, 256]
        Number points = 38656         


        When the polygon only is applied, it is auto extended along the third
        axis.  The {\stff statistics} function finds 6400 pixels in the region,
        which is $6400/256=25$ pixels per plane.  Likewise, when the box only is
        applied, the {\stff statistics} function finds 32256 pixels in the
        region, which is $32256/256=126$ pixels per plane.  When the union is
        applied, the {\stff statistics} function finds 38656 pixels in the
        region.  First it finds the union of the polygon and box (which are
        specified only in the XY plane) and that union is extended.  Thus we
        expect $(25+126)*256=38656$ pixels in the region of the union, as found.


        Example:
        	  

        - ia.open('onno')
        - csys = ia.coordsys()
        - x = qa.quantity([3,6,9,6,5,5,3],'pix')
        - y = qa.quantity([3,4,7,9,7,5,5],'pix')
        -
        - regions = {}
        - regions['poly'] = rg.wpoly(x,y,[0,1],csys.torecord())
        -
        - blc = '17:42:29.303 -28.59.18.600'
        - trc = '17:42:28.303 -28.59.10.600'
        - regions['box'] = rg.wbox(blc,trc,[0,1],csys.torecord())
        -
        - r3 = rg.union(regions,'The mysteries of CASA')


        This example is the same as the prevoius one, except the regions are
        provided to the union function in a record, rather than directly in the
        call sequence.


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_makeunion(self, *args, **kwargs)

    def wbox(self, *args, **kwargs):
        """
        wbox(self, blc=initialize_variant(""), trc=initialize_variant(""), pixelaxes=initialize_vector(1, (int)-1), 
            csys=initialize_record(""), absrel=string("'abs'"), comment=string("")) -> record *

        Summary
        	Create a world box region

        Description
        	

        This function creates a multi-dimensional world box region; the
        corners of the box are specified in world coordinates.  However, the box
        is not a true world volume in that its sides do not follow world
        contours.  Its sides are parallel to the pixel axes.  If you are in a
        region of high world coordinate contour non-linearity (e.g.  near a
        pole), you are probably better off using a world polygon. 

        The box is specified by a bottom-left corner, and a top-right corner. 
        The coordinates are given as quantities, and you can give a vector of
        quantities (e.g.  {\cf blc = qa.quantity('1rad 20deg')} or a
        quantity of a vector (e.g.{\cf blc = qa.quantity([10,30], 'rad')}). 

        You can specify whether the coordinates are given as absolute coordinates
        ({\stfaf absrel='abs'}) or relative to the reference pixel ({\stfaf 
        absrel='relref'}) or relative to the center of the image ({\stfaf
        absrel='relcen'}).  You can specify this for each axis (the same for the
        blc and trc).   If you specify less values than the number of
        values in {\stfaf blc} or {\stfaf trc} then the last value you
        did specify is used as the default for all higher numbered axes
        (e.g. {\stfaf absrel='relref'} means {\stfaf absrel='relref relref'}
        for two axes).

        You specify which pixel axes in the image the {\stfaf blc} and {\stfaf
        trc} vector refer to with the {\stfaf pixelaxes} argument.  If you
        don't, it defaults to [0,1,2,...].  This specification is an important
        part of world regions. 

        You must also specify the Coordinate System with the {\stfaf csys}
        argument.  The Coordinate System is encapsulated in a {\stfaf coordinates}
        tool and can be recovered from an image with the
        coordsys tool function.  You can
        also set a default Coordinate System in the regionmanager\ with the
        setcoordinates 
        function.

        In the regionmanager\ we have defined units `pix' and `frac'; these are
        then known to the quanta system.  This means
        that you can effectively define a pixel box (except for the stride
        capability) as a world box with most of the advantages of world regions
        (can be used for compound regions).  However, it is still not very
        portable to other images because the coordinates are pixel based,
        not world based. 

        Note that the need to deal with the {\stfaf pixelaxes} and {\stfaf csys}
        is hidden from you when using the gui
        interface of the regionmanager. 



        Input Parameters:
        	blc		 blc of the box ; a vector of quantities Unity 
        	trc		 trc of the box; a vector of quantities Shape 
        	pixelaxes	 Which pixel axes -1 [0,1,2,...] 
        	csys		 Coordinate System Private Coordinate System 
        	absrel		 Absolute or relative coordinates Vector of strings from 'abs', 'relref' and 'relcen' 'abs' 
        	comment		 A comment stored with the region 
        	
        Example:
        	  

        - r = rg.wbox()


        This region, on application to an image, will select the entire
        image.


        Example:
        	  

        - ia.open('ada')
        - csys = ia.coordsys()
        - csys.summary()

        Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
        --------------------------------------------------------------------------- 
        Frequency                64   16  1.413350e+09     1.00  1.968717e+04 Hz
        Velocity                          1.378053e+02     1.00 -4.174021e+00 km/s
        Declination       SIN   178   89 -28.59.18.600    90.00  1.000000e+00 arcsec
        Right Ascension   SIN   155   31  17:42:29.303    90.00 -1.000000e+00 arcsec
        -
        -
        - blc = '17:42:29.303 -28.59.18.600'
        - trc = '17:42:28.303 -28.59.10.600'
        - r1 = rg.wbox(blc=blc,trc=trc,pixelaxes=[0,1],csys=csys.torecord())
        - ia.boundingbox(r1)
        [blc=[1 90 90] , trc=[64 98 103] , regionShape=[64 9 14], imageShape=[64 178 155] ] 


        We have specified an RA and DEC for the blc and the trc (they should
        be quantities; for blc we do that explicitly, but for the trc
        we just give a vector of strings which is automatically converted
        for us to a vector of quantities).

        From the {\stff summary} listing you can see that RA and DEC correspond
        to pixel axes 3 and 2 respectively (don't be confused by the dual
        listing for the spectral axis) so that is why the {\stfaf pixelaxes}
        argument is set to [3,2].  If we had set blc/trc in DEC/RA order then we
        would have put {\stfaf pixelaxes=[1,2]}.  For the unspecified frequency
        axis, all pixels are selected. 


        Example:
        	  

        - ia.open('bork')
        - csys = ia.coordsys()
        - csys.summary()

        Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
        --------------------------------------------------------------------------- 
        Right Ascension   SIN   155   31  17:42:29.303    90.00 -1.000000e+00 arcsec
        Declination       SIN   178   89 -28.59.18.600    90.00  1.000000e+00 arcsec

        - rg.setcoordinates(cs)
        T
        - blc = '-10pix -28.59.18.6'
        - trc = '10pix  -28.59.1.6'
        - r1 = rg.wbox(blc=blc,trc=trc,absrel='relref abs')   # pixelaxes defaults to [0,1]
        Using private CoordinateSystem from image 'bork'
        - ia.boundingbox(r1)
        [blc=[80 90] , trc=[100 107] , regionShape=[21 18] , imageShape=[155 178] ] 


        In this example, we use pixel coordinates relative to the reference
        pixel for the RA axis and absolute world coordinates for the DEC axis. 
        We also set the state of the regionmanager\ with a Coordinate
        System to use when making world regions.  You can see that when the
        region was made, a message was issued reminding you that the internal
        Coordinate System from the image {\sff bork} was being used. 


        Example:
        	  

        - ia.open('hcn')
        - csys = ia.coordsys()
        - csys.summary()

        Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
        --------------------------------------------------------------------------- 
        Right Ascension   SIN   155   31  17:42:29.303    90.00 -1.000000e+00 arcsec
        Declination       SIN   178   89 -28.59.18.600    90.00  1.000000e+00 arcsec
        Frequency                64   16  1.413350e+09     1.00  1.968717e+04 Hz
        Velocity                          1.378053e+02     1.00 -4.174021e+00 km/s
        T 
        -
        - blc = '1.414E9Hz'
        - trc = '1.4145GHz'
        - r = rg.wbox(blc=blc, trc=trc, pixelaxes=[2], csys=cs)
        - ia.boundingbox(r)
        [blc=[1 1 34] , trc=[155 178 59] , regionShape=[155 178 26] , imageShape=[155 178 64] ] 


        In this example we only specified a region for the frequency axis (note
        we used different units for the blc and trc).  Therefore, on
        application, the region selected for the RA and DEC axes is
        automatically the full image.  


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_wbox(self, *args, **kwargs)

    def wpolygon(self, *args, **kwargs):
        """
        wpolygon(self, x=initialize_variant(""), y=initialize_variant(""), pixelaxes=initialize_vector(1, (int)-1), 
            csys=initialize_record(""), absrel=string("abs"), comment=string("")) -> record *

        Summary
        	Create a world polygon region with quantities

        Description
        	

        This function (short-hand name {\stff wpoly}) creates a 2D world
        polygon region.  The polygon is specified by an {\stfaf x} and a {\stfaf y}
        vector.  These must be quantities of a vector (the 
        world box function
        allows both
        quantities of vectors and vectors of quantities).  This means that the
        units are common to all elements of each vector.  Thus, {\cf
        qa.quantity([1,2,3],'rad')} (a quantity of a vector) is different from
        {\cf qa.quantity('1rad 2rad 3rad')} (a vector of quantities) although
        the information that they specify is the same. 

        You specify which pixel axes in the image the {\stfaf x} and {\stfaf 
        y} vectors pertain to with the {\stfaf pixelaxes} argument.  If you don't,
        it defaults to [0,1].  This specification is an important part of
        world regions. 

        You can specify whether the {\stfaf x} and {\stfaf y} vector coordinates are
        given as absolute coordinates ({\stfaf absrel='abs'}) or relative to the
        reference pixel ({\stfaf absrel='relref'}) or relative to the center of the
        image ({\stfaf absrel='relcen'}).  This argument applies to both the axes
        of the polygon. 

        You must also specify the Coordinate System with the {\stfaf csys}
        argument.  The Coordinate System is encapsulated in a {\stfaf coordinates}
        	ool\ and can be recovered from an image with the
        coordsys function.  You can
        also set a default Coordinate System in the Regionmanager with the
        setcoordinates 
        function.

        In the regionmanager\ we have defined units `pix' and `frac'; these are
        then known to the quanta system.  This means
        that you can effectively define a pixel box (except for the stride
        capability) as a world box with most of the advantages of world regions
        (can be used for compound regions).  However, it is still not very
        portable to other images because the coordinates are pixel based,
        not world based. 

        Note that the need to deal with the {\stfaf pixelaxes} and {\stfaf csys}
        is hidden from you when using the gui
        interface of the regionmanager. 



        Input Parameters:
        	x		 The x vector; a vector of quantities 
        	y		 The y vector; vector of quantities Quantity vector 
        	pixelaxes	 which pixel axes; vector of integers ..default -1 means [0,1] -1 [1,2] 
        	csys		 Coordinate System Private Coordinate System 
        	absrel		 Absolute or relative coordinates; possibilities are 'abs', 'rel', 'relcen' abs 'abs' 
        	comment		 A comment stored with the region 
        	
        Example:
        	  

        ia.open('myim.im')
        csys = ia.coordsys()
        x = ['3pix', '6pix', '9pix', '6pix', '5pix','5pix','3pix']
        y = ['3pix','4pix','7pix','9pix','7pix','5pix','5pix']
        r1 = rg.wpolygon(x=x, y=y, pixelaxes=[0,1], csys=csys.torecord())
        stats = ia.statistics(region=r1)
        ia.done()


        We applied the 2D polygon, defined in the XY plane with absolute pixel
        coordinates, to a 3D image.  Therefore, the third (Z) axis was
        automatically extended to the whole image. 


        --------------------------------------------------------------------------------
        	      
        """
        return _regionmanager.regionmanager_wpolygon(self, *args, **kwargs)

regionmanager_swigregister = _regionmanager.regionmanager_swigregister
regionmanager_swigregister(regionmanager)

# This file is compatible with both classic and new-style classes.


