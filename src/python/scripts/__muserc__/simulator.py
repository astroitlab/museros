# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_simulator', [dirname(__file__)])
        except ImportError:
            import _simulator
            return _simulator
        if fp is not None:
            try:
                _mod = imp.load_module('_simulator', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _simulator = swig_import_helper()
    del swig_import_helper
else:
    import _simulator
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class simulator(_object):
    """Proxy of C++ casac::simulator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, simulator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, simulator, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> simulator"""
        this = _simulator.new_simulator()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _simulator.delete_simulator
    __del__ = lambda self : None;
    def open(self, *args, **kwargs):
        """
        open(self, ms=string("")) -> bool

        Summary
        	Construct a simulator tool and creating a new MeasurementSet

        Description
        	
            This is used to construct {	t simulator} tools.  A simulator tool
            can either be instantiated from an existing MeasurementSet, predicting
            and/or corrupting data on the given coordinates, or it can be used to
            create a fundamentally new MeasurementSet from descriptions of the
            array configuration and the observational parameters.  This
            is useful for making a simulator
            tool which will make a MeasurementSet from scratch.  In order to
            do this, you must also run {	t setconfig}, {	t setfield}, 
            {	t setspwindow}, {	t setfeed}, and {	t settimes}.  Creating the
            actual MS is performed by {	t observe}.  Data can be {	t predict}-ed
            and then {	t corrupted}-ed.  In this
            example, we read in the antenna coordinates from an ASCII file:
          

        Input Parameters:
        	ms		 MeasurementSet to be created 
        	
        Example:
        	
            
            tabname = 'VLAC.LOCAL.TAB'
            asciifile = 'VLAC.LOCAL.STN'
            mytab=table.create()
            mytab.fromascii(tabname, asciifile);
            xx=[]; yy:=[]; zz:=[]; diam:=[];
            xx = mytab.getcol('X');  
            yy = mytab.getcol('Y');
            zz = mytab.getcol('Z');
            diam = mytab.getcol('DIAM');
            #
            sm.open('NEW1.ms')
            # do configuration
            posvla = me.observatory('vla');  #  me.observatory('ALMA') also works!
            sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
        	         mount='alt-az', antname='VLA',
                         coordsystem='local', referencelocation=posvla);

            # Initialize the spectral windows    
            sm.setspwindow(spwname='CBand', freq='5GHz',
        		   deltafreq='50MHz',
        		   freqresolution='50MHz',
        		   nchannels=1,
        		   stokes='RR RL LR LL');
            sm.setspwindow(spwname='LBand', freq='1.420GHz',
        		   deltafreq='3.2MHz',
        		   freqresolution='3.2MHz',
        		   nchannels=32,
        		   stokes='RR LL');
            
            # Initialize the source and calibrater
            sm.setfield(sourcename='My cal',
        		sourcedirection=['J2000','00h0m0.0','+45.0.0.000'],
        		calcode='A');
            sm.setfield(sourcename='My source',
        		sourcedirection=['J2000','01h0m0.0','+47.0.0.000']);
          
            sm.setlimits(shadowlimit=0.001, elevationlimit='8.0deg');
            sm.setauto(autocorrwt=0.0);
            
            sm.settimes(integrationtime='10s', usehourangle=F, 
                        referencetime=me.epoch('utc', 'today'));
            
            sm.observe('My cal', 'LBand', starttime='0s', stoptime='300s');
            sm.observe('My source', 'LBand', starttime='310s', stoptime='720s');
            sm.observe('My cal', 'CBand', starttime='720s', stoptime='1020s');
            sm.observe('My source', 'CBand', starttime='1030s', stoptime='1500s');
            
            sm.setdata(spwid=1, fieldid=1);
            sm.predict(imagename='M31.MOD');
            sm.setdata(spwid=2, fieldid=2);
            sm.predict(imagename='BigLBand.MOD');
            sm.close();
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_open(self, *args, **kwargs)

    def openfromms(self, *args, **kwargs):
        """
        openfromms(self, ms=string("")) -> bool

        Summary
        	Construct a simulator tool using an already existing  MS

        Description
        	
            This is used to construct {	t simulator} tools operating on
            an existing MS.  Data can be predicted and/or corrupted on the MS's given coordinates.
          

        Input Parameters:
        	ms		 MeasurementSet to be processed 'MS' 
        	
        Example:
        	
            
            sm.openfromms('3C273XC1.MS');
            sm.predict('3C273XC1.imagename');
            sm.setnoise(simplenoise='10mJy');
            sm.setgain(interval='100s', amplitude=0.01);
            sm.corrupt();
            sm.close();
            
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_openfromms(self, *args, **kwargs)

    def close(self):
        """
        close(self) -> bool

        Summary
        	Close the newsimulator tool

        Description
        	
            This is used to close {	t newsimulator} tools. Note that the
            data is written to disk. This is a synonym for done.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_close(self)

    def done(self):
        """
        done(self) -> bool

        Summary
        	Close the newsimulator tool

        Description
        	
            This is used to close and {	t newsimulator} tools. Note that the
            data is written to disk. This is a synonym for close.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_done(self)

    def name(self):
        """
        name(self) -> string

        Summary
        	Provide the name of the attached MeasurementSet

        Description
        	
            Returns the name of the attached MeasurementSet.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_name(self)

    def summary(self):
        """
        summary(self) -> bool

        Summary
        	Summarize the current state

        Description
        	
            Writes a summary of the properties of the simulator to the
            default logger.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_summary(self)

    def type(self):
        """
        type(self) -> string

        Summary
        	Return the type of this tool

        Description
        	
            This function returns the string `simulator'.  It is used so that  in
            a script, you can make sure this  variable is a simulator
            	ool.
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_type(self)

    def settimes(self, *args, **kwargs):
        """
        settimes(self, integrationtime=initialize_variant("10s"), usehourangle=True, referencetime=initialize_variant("50000.0d")) -> bool

        Summary
        	Set integration time, {em etc.}

        Description
        	 The start and stop times are referenced to
            {	t referencetime}.  Use either starttime/stoptime or startha/stopha.
            If the hour angles are specified, then the start and stop times are
            calculated such that the start time is later than the reference time,
            but less than one day later.  The hour angles refer to the first
            source observed.
          

        Input Parameters:
        	integrationtime	 Integration time 10s 
        	usehourangle	 Use starttime/stoptime as hour angles - else they are referenced to referencetime true 
        	referencetime	 Reference time for starttime and stoptime. Epoch Measure . E.g me.epoch('UTC', '50000.0d') 50000.0d epoch measure 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_settimes(self, *args, **kwargs)

    def observe(self, *args, **kwargs):
        """
        observe(self, sourcename=string(""), spwname=string(""), starttime=initialize_variant("0s"), stoptime=initialize_variant("3600s"), 
            add_observation=False, state_sig=True, 
            state_ref=False, state_cal=0.0, state_load=0.0, state_sub_scan=0, state_obs_mode=string("OBSERVE_TARGET.ON_SOURCE"), 
            observer=string("CASA simulator"), 
            project=string("CASA simulation")) -> bool

        Summary
        	Observe a given configuration

        Description
        	
            Observe a given source with a given spectral window for the specified
            times, including start, stop, integration, and gap times.  The start
            and stop times are referenced to {	t referencetime}.  Use either
            starttime/stoptime or startha/stopha.  If the hour angles are
            specified, then the start and stop times are calculated such that the
            start time is later than the reference time, but less than one day
            later.  The hour angles refer to the first source observed.
          

        Input Parameters:
        	sourcename	 Name of source or field (must be specified) None 
        	spwname		 Unique user-supplied name for this spectral window None 
        	starttime	 Start time referenced to referenceepoch 0s 
        	stoptime	 Stop time referenced to referenceepoch 3600s 
        	add_observation	 Add a new line to the OBSERVATION subtable for this call false 
        	state_sig	 a new line will be added to STATE if the following don't match true 
        	state_ref	 false 
        	state_cal	 0.0 
        	state_load	 0.0 
        	state_sub_scan	 0 
        	state_obs_mode	 OBSERVE\_TARGET.ON\_SOURCE 
        	observer	 CASA simulator 
        	project		 CASA simulation 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_observe(self, *args, **kwargs)

    def observemany(self, *args, **kwargs):
        """
        observemany(self, sourcenames=std::vector< string >(1, ""), spwname=string(""), starttimes=std::vector< string >(1, ""), 
            stoptimes=std::vector< string >(1, ""), directions=std::vector< string >(1, ""), 
            add_observation=False, state_sig=True, state_ref=False, 
            state_cal=0.0, state_load=0.0, state_sub_scan=0, state_obs_mode=string("OBSERVE_TARGET#ON_SOURCE"), 
            observer=string("CASA simulator"), project=string("CASA simulation")) -> bool

        Summary
        	Observe a given configuration

        Description
        	
            Observe given sources with a given spectral window for the specified
            times, including start, stop, integration, and gap times.  The start
            and stop times are referenced to {	t referencetime}.  Use either
            starttime/stoptime or startha/stopha.  If the hour angles are
            specified, then the start and stop times are calculated such that the
            start time is later than the reference time, but less than one day
            later.  The hour angles refer to the first source observed.
          

        Input Parameters:
        	sourcenames	 Name of sources None 
        	spwname		 Unique user-supplied name for this spectral window None 
        	starttimes	 Start times referenced to referenceepoch 0s 
        	stoptimes	 Stop time referenced to referenceepoch 3600s 
        	directions	 
        	add_observation	 Add a new line to the OBSERVATION subtable for this call false 
        	state_sig	 a new line will be added to STATE if the following don't match true 
        	state_ref	 false 
        	state_cal	 0.0 
        	state_load	 0.0 
        	state_sub_scan	 0 
        	state_obs_mode	 OBSERVE\_TARGET#ON\_SOURCE 
        	observer	 CASA simulator 
        	project		 CASA simulation 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_observemany(self, *args, **kwargs)

    def setlimits(self, *args, **kwargs):
        """
        setlimits(self, shadowlimit=1e-6, elevationlimit=initialize_variant("10deg")) -> bool

        Summary
        	Set limits for observing

        Description
        	
            Data are flagged for two conditions:
            egin{description}
            \item[Below elevation limit] If either of the antennas point below the
            specified elevation limit then the data are flagged. The elevation
            is calculated correctly for antennas at different locations (such as
            occurs in VLBI).
            \item[Shadowing] If one antenna shadows another such that the
            fractional (geometric) blockage is greater than the specified limit
            then the data are flagged. No correction for blockage is made for
            shadowed but non-flagged points.
            nd{description}
          

        Input Parameters:
        	shadowlimit	 Maximum fraction of geometrically shadowed area before flagging occurs 1e-6 1e-6 
        	elevationlimit	 Minimum elevation angle before flagging occurs 10deg 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setlimits(self, *args, **kwargs)

    def setauto(self, autocorrwt=0.0):
        """
        setauto(self, autocorrwt=0.0) -> bool

        Summary
        	Set autocorrelation weight

        Description
        	
          

        Input Parameters:
        	autocorrwt	 Weight to assign autocorrelations (0=none) 0.0 0.0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setauto(self, autocorrwt)

    def setconfig(self, *args, **kwargs):
        """
        setconfig(self, telescopename=string("VLA"), x=initialize_vector(1, (double)0), y=initialize_vector(1, (double)0), 
            z=initialize_vector(1, (double)0), dishdiameter=initialize_vector(1, (double)0), 
            offset=initialize_vector(1, (double)0), mount=std::vector< string >(1, ""), 
            antname=std::vector< string >(1, ""), padname=std::vector< string >(1, ""), 
            coordsystem=string("global"), referencelocation=initialize_variant("ALMA")) -> bool

        Summary
        	Set the antenna configuration

        Description
        	
            Set the positions of the antennas.  Note that the name of the telescope will
            control which voltage pattern is applied to the data.
          

        Input Parameters:
        	telescopename	 Name of the telescope we are simulating (determines VP) VLA 'VLA' 
        	x		 Vector of x values of all antennas [currently m] 0 [] 
        	y		 Vector of y values of all antennas [currently m] 0 [] 
        	z		 Vector of z values of all antennas [currently m] 0 [] 
        	dishdiameter	 Vector of diameters of all antennas [currently m] 0 [] 
        	offset		 Vector of offset of all antennas [currently m] 0 [] 
        	mount		 Vector of mount types of all antennas (recognized mounts are 'ALT-AZ', 'EQUATORIAL', 'X-Y', 'ORBITING', 'BIZARRE' ALT-AZ [] 
        	antname		 Vector of names of all antennas A [] 
        	padname		 Vector of names of pads or stations P [] 
        	coordsystem	 Coordinate system of antenna positions [x,y,z], possibilities are 'global', 'local' , 'longlat' global 'global' 
        	referencelocation	 Reference location [required for local coords] Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', -20.2deg', 6000km') or me.observatory('ALMA') ALMA position measure 
        	
        Example:
        	
            
            diam := [25, 25, 25, 25, 25]
            xx := [50, 100, 150, 200, 250]
            yy := [2, -5, -20, -50, -100]
            zz := [-0.5, -1.0, -1.5, -2.0, -2.5]
            posvla := dm.observatory('vla');
            sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
                         mount='alt-az', antname='VLA',
                         coordsystem='local', referencelocation=posvla);
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setconfig(self, *args, **kwargs)

    def setknownconfig(self, *args, **kwargs):
        """
        setknownconfig(self, arrayname=string("VLA")) -> bool

        Summary
        	Set the antenna configuration to a
            known array

        Description
        	
            Sets the configuration to a known array such as VLAA, VLBA, EVN or
            ATCA6.0A. The arrays are those known to
            simhelper. All the information needed by
            setconfig is filled in.
          

        Input Parameters:
        	arrayname	 Name of the telescope configurationwe are simulating VLA 'VLA' 
        	
        Example:
        	
            
            sm.setknownconfig('ATCA6.0A');
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setknownconfig(self, *args, **kwargs)

    def setfeed(self, *args, **kwargs):
        """
        setfeed(self, mode=string(""), x=initialize_vector(1, (double)0), y=initialize_vector(1, (double)0), 
            pol=std::vector< string >(1, "")) -> bool

        Summary
        	Set the feed parameters

        Description
        	
            The goal is to let the feed parameters be specified for each antenna and
            each spectral window.  At this moment, you only have the choice between
            'perfect R L' and 'perfect X Y' (i.e., you cannot invent your own
            corrupted feeds yet).  Doesn't need to be run if you want perfect R and
            L feeds.  
          

        Input Parameters:
        	mode		 Mode for specifying feed parameters (currently, perfect only) 
        	x		 Some very secretive feed array parameter x 0 
        	y		 Some more very secretive feed array parameter y 0 
        	pol		 Guess its the polarization of feed arrays... your guess is as good as mine....if you know better let us know please ! R 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setfeed(self, *args, **kwargs)

    def setfield(self, *args, **kwargs):
        """
        setfield(self, sourcename=string("SOURCE"), sourcedirection=initialize_variant(""), calcode=string(""), 
            distance=initialize_variant("0m")) -> bool

        Summary
        	Set one or more observed fields

        Description
        	
            Set one or more observed fields, including name, coordinates, calibration code.
            Can be invoked multiple times for a complex observation.
            Must be invoked at least once before {	t observe}.
            
            If the distance to the object is set then the phase term includes a
            curvature for the near-field effect at the center of the image.
          

        Input Parameters:
        	sourcename	 Name of source or field (must be specified) SOURCE 'unknown' 
        	sourcedirection	 Direction Measure of Coordinates of source to be observed. E.g me.direction('J2000', '30.5deg','-20.2deg'). 
        	calcode		 Calibration code 'OBJ' 
        	distance	 Distance to the object 0m 
        	
        Example:
        	
            
            sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
                         mount='alt-az', antname='VLA',
                         coordsystem='local', referencelocation=dm.observatory('vla'));

            sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=1, stokes='RR
                           LL');
            dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
            sm.setfield(sourcename='SIMU1', sourcedirection=dir0);
            sm.observe('SIMU1', 'XBAND', integrationtime='10s', usehourangle=T,
                       starttime='0s', stoptime='3600s', 
            referencetime=reftime);
            
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setfield(self, *args, **kwargs)

    def setmosaicfield(self, *args, **kwargs):
        """
        setmosaicfield(self, sourcename=string("SOURCE"), calcode=string(""), fieldcenter=initialize_variant(""), 
            xmosp=1, ymosp=1, mosspacing=initialize_variant("1arcsec"), distance=initialize_variant("0m")) -> bool

        Summary
        	Set observed mosaic fields

        Description
        	
            Set mosaic fields by internally invoking {	t setfield} multiple times.
            Currently only handle a rectangular mosaicing pattern.
            Either setfield or setmosaicfield must be invoked at least once before {	t observe}.
            
            If the distance to the object is set then the phase term includes a
            curvature for the near-field effect at the center of the image.
          

        Input Parameters:
        	sourcename	 Name of source or field (must be specified). SOURCE 'unknown' 
        	calcode		 Calibration code '' 
        	fieldcenter	 Coordinates of mosaic field center MDirection 
        	xmosp		 Number of mosaic pointing in horizontal direction 1 
        	ymosp		 Number of mosaic pointing in vertical direction 1 
        	mosspacing	 Spacing between mosaic pointings 1arcsec 
        	distance	 Distance to the object 0m 
        	
        Example:
        	
            
            sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam,
                         mount='alt-az', antname='VLA',
                         coordsystem='local', referencelocation=dm.observatory('vla'));
                                                                                        
            sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=1, stokes='RR
                           LL');
            dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
            sm.setmosaicfield(sourcename='SIMU1', fieldcenter=dir0,
                              xmosp=2, ymosp=2, mosspacing='154.5arcsec');
            sm.settimes(integrationtime='10s');
            sm.observe('SIMU1_1', 'XBAND', starttime='0s', stoptime='100s');
            sm.observe('SIMU1_2', 'XBAND', starttime='110s', stoptime='210s');
            sm.observe('SIMU1_3', 'XBAND', starttime='220s', stoptime='320s');
            sm.observe('SIMU1_4', 'XBAND', starttime='330s', stoptime='430s');
            
            
          
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setmosaicfield(self, *args, **kwargs)

    def setspwindow(self, *args, **kwargs):
        """
        setspwindow(self, spwname=string("XBAND"), freq=initialize_variant("8.0e9Hz"), deltafreq=initialize_variant("50e6Hz"), 
            freqresolution=initialize_variant("50.e6Hz"), refcode=string("TOPO"), 
            nchannels=1, stokes=string("RR LL")) -> bool

        Summary
        	Set one or more spectral windows

        Description
        	
        Set one or more spectral windows for the observations, including starting
        frequency, number of channels, channel increment and resolution, and stokes
        parameters observed.  Can be invoked multiple times for a complex observation.
        Must be invoked at least once before {	t observe}.


        Input Parameters:
        	spwname		 Unique user-supplied name for this spectral window XBAND 'XBAND' 
        	freq		 Starting frequency 8.0e9Hz 
        	deltafreq	 Frequency increment per channel 50e6Hz 
        	freqresolution	 Frequency resolution per channel 50.e6Hz 
        	refcode		 Spectral reference code e.g. LSRK, TOPO, BARY TOPO LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB 
        	nchannels	 Number of channels 1 
        	stokes		 Stokes types to simulate RR LL 'RR LL' 
        	
        Example:
        	

        To simulate a two spectral window (or two IF's in VLA jargon) data
        set, use setpwid as follows (here we are simulating 16 channels, 50MHz
        wide channel for each spectral window)


        sm.setspwindow(spwname='CBAND', freq='2GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=16, stokes='RR LL');

        sm.setspwindow(spwname='SBAND', freq='5GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=16, stokes='RR LL');



        Note that the spwname is used in {	t observe} to determine which spectral window
        is used.


        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setspwindow(self, *args, **kwargs)

    def setdata(self, *args, **kwargs):
        """
        setdata(self, spwid=initialize_vector(1, (int)0), fieldid=initialize_vector(1, (int)0), msselect=string("")) -> bool

        Summary
        	Set the data parameters selection for subsequent processing

        Description
        	
        This setup tool function selects which data are to be used
        subsequently. After invocation of setdata, only the selected data are
        operated on. 



        Input Parameters:
        	spwid		 Spectral Window Ids (0 relative) to select 0 
        	fieldid		 Field Ids (0 relative) to select 0 
        	msselect	 TQL select string applied as a logical 'and' with the other selections String 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setdata(self, *args, **kwargs)

    def predict(self, *args, **kwargs):
        """
        predict(self, imagename=std::vector< string >(1, ""), complist=string(""), incremental=False) -> bool

        Summary
        	Predict astronomical data from an image

        Description
        	
        Predict astronomical data from an image.  The (u,v) coordinates already
        exist, either from a MeasurementSet we have read in or by generating the
        MeasurementSet coordinates and empty data through {	t create()}.  We
        simply predict onto these coordinates.


        Input Parameters:
        	imagename	 Name of image from which to predict visibilities 
        	complist	 Name of component list String 
        	incremental	 Add this model to the existing Data Visibilities? false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_predict(self, *args, **kwargs)

    def setoptions(self, *args, **kwargs):
        """
        setoptions(self, ftmachine=string("ft"), cache=0, tile=16, gridfunction=string("SF"), location=initialize_variant("ALMA"), 
            padding=1.3, facets=1, maxdata=2000.0, wprojplanes=1) -> bool

        Summary
        	Set various processing options

        Description
        	

        For most of these, set the options for {	t predict} details.  See also {	t imager} help
        for more details.

        To simulate single dish data, use gridft=SD and gridfunction=PB.



        Input Parameters:
        	ftmachine	 Fourier transform machine. Possibilities are 'ft', 'sd' ft 'ft' 
        	cache		 Size of gridding cache in complex pixels 0 
        	tile		 Size of a gridding tile in pixels (in 1 dimension) 16 
        	gridfunction	 Gridding function. String: 'SF'|'BOX'|'PB' SF 'SF' 
        	location	 Location used in phase rotations. Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', '-20.2deg', '6000km') or me.observatory('ALMA') ALMA position measure 
        	padding		 Padding factor in image plane (\>=1.0) 1.3 
        	facets		 Number of facets 1 
        	maxdata		 Maximum data to write to a single TSM file (MB) 2000.0 
        	wprojplanes	 Number of projection planes when using wproject as the ft-machine 1 
        	
        Example:
        	

        sm.setoptions(cache=10000000, tile=32, gridfunction='BOX', me.location('vla'))


        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setoptions(self, *args, **kwargs)

    def setvp(self, *args, **kwargs):
        """
        setvp(self, dovp=True, usedefaultvp=True, vptable=string(""), dosquint=True, parangleinc=initialize_variant("360deg"), 
            skyposthreshold=initialize_variant("180deg"), pblimit=1.0e-2) -> bool

        Summary
        	Set the voltage pattern model for subsequent processing

        Description
        	
        Set the voltage pattern model (and hence, the primary beam) used for a Telecope.
        There are currently two ways to set the voltage pattern: by using the extensive
        list of defaults which the system knows about, or by creating a voltage pattern
        description with the vpmanager.  The default voltage patterns
        include both a high and a low frequency VP for the WSRT, a VP for each observing
        band at the AT, several VP's for the VLA, including the approrpiate beam squint for
        each observing band, and  Gaussian for the BIMA dishes.
        If you are simulating a telescope which doesn't yet exist, you will need to supply
        a model voltage pattern using the vpmanager.


        Input Parameters:
        	dovp		 Multiply by the voltage pattern (ie, primary beam) when simulating true 
        	usedefaultvp	 Look up the default VP for this telescope and frequency? true 
        	vptable		 If usedefaultvp is false, provide a VP Table made with vpmanager Table 
        	dosquint	 Activate the beam squint in the VP model true 
        	parangleinc	 Parallactice angle increment for squint application 360deg 
        	skyposthreshold	 Position threshold on the sky for feed arrays ?? 180deg 
        	pblimit		 Primary beam limit to use in feed arrays ? 1.0e-2 
        	
        Example:
        	

        sm.setvp(dovp=T, usedefaultvp=F, vptable='MyAlternateVLAPBModel.TAB', dosquint=F);


        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setvp(self, *args, **kwargs)

    def corrupt(self):
        """
        corrupt(self) -> bool

        Summary
        	Corrupt the data with visibility errors

        Description
        	
        Add errors specified by the {	t set} functions (such as noise, 
        gains, polarization leakage, bandpass, etc) to the visibility data.
        The errors are applied to the MODEL\_DATA, and written to the
        DATA and CORRECTED\_DATA columns.   Note that {	t corrupt} handles
        only visibility-plane effects, not image-plane effects such as
        pointing errors and voltage patterns, which get applied in {	t predict}.
        Note, the function applies errors to both cross- and auto-correlation
        data; The auto-correlation data are corrupted properly only for
        the thermalnoise set by {	t setnoise}.



        Example:
        	

        sm,openfromms('3C273XC1.MS');
        sm.predict('3C273XC1.FAKE.IMAGE');
        sm.setnoise( mode='simplenoise', simplenoise='0.1Jy');
        sm.setpa( mode='calculate');
        sm.corrupt();


        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_corrupt(self)

    def reset(self):
        """
        reset(self) -> bool

        Summary
        	Reset the corruption terms

        Description
        	
        Reset the visibility corruption terms: this means that {	t corrupt}
        introduces no errors.

        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_reset(self)

    def setbandpass(self, *args, **kwargs):
        """
        setbandpass(self, mode=string("calculate"), table=string(""), interval=initialize_variant("3600s"), 
            amplitude=initialize_vector(1, (double)0.0)) -> bool

        Summary
        	Set the bandpasses

        Description
        	
        Set the level of bandpass errors. The error distributions are normal, mean
        zero, with the variances as specified. (Not yet implemented).


        Input Parameters:
        	mode		 Mode of operation. String: 'calculate'|'table' calculate 'calculate' 
        	table		 Name of table '' 
        	interval	 Coherence interval e.g. '1h' 3600s 
        	amplitude	 Variances errors in amplitude and phase 0.0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setbandpass(self, *args, **kwargs)

    def setapply(self, *args, **kwargs):
        """
        setapply(self, table=string(""), type=string(""), t=0.0, field=initialize_variant(""), interp=string("linear"), 
            calwt=False, spwmap=initialize_vector(1, (int)-1), opacity=0.0) -> bool

        Summary
        	Arrange for corruption by existing cal tables

        Description
        	
        Arrange for corruption by existing cal tables, in a manner exactly analogous to
        calibrater.setapply. 


        Input Parameters:
        	table		 Calibration table name 
        	type		 Component type B BPOLY G GSPLINE D P T TOPAC GAINCURVE 
        	t		 Interpolation interval (seconds) 0.0 
        	field		 Select on field 
        	interp		 Interpolation type (in time) aipslin nearest linear 
        	calwt		 Calibrate weights? false 
        	spwmap		 Spectral windows to apply -1 
        	opacity		 Array-wide zenith opacity (for type='TOPAC') 0.0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setapply(self, *args, **kwargs)

    def setgain(self, *args, **kwargs):
        """
        setgain(self, mode=string("fbm"), table=string(""), interval=initialize_variant("10s"), amplitude=initialize_vector(1, (double)0.01)) -> bool

        Summary
        	Set the gains

        Description
        	
        Set the level of gain errors.  Gain drift is implemented as fractional brownian
        motion with rms amplitude as specified.  Interval is not currently used, 
        but future statistical models for gain errors (e.g. simple Gaussian) will use it.



        Input Parameters:
        	mode		 Mode of operation. String: 'fbm' fbm 'fbm' 
        	table		 Optional name of table to write '' 
        	interval	 timescale for gain variations NOT USED 10s 
        	amplitude	 amplitude scale (RMS) for gain variations [real,imag] or scalar 0.01 [] 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setgain(self, *args, **kwargs)

    def settrop(self, *args, **kwargs):
        """
        settrop(self, mode=string("screen"), table=string(""), pwv=3.0, deltapwv=0.15, beta=1.1, windspeed=7.) -> bool

        Summary
        	Set tropospheric gain corruptions

        Description
        	
        Set the atmosphere. 


        Input Parameters:
        	mode		 Mode of operation - screen or individual antennas screen 'screen' 
        	table		 Name of cal table '' 
        	pwv		 total precipitable water vapour in mm 3.0 
        	deltapwv	 RMS PWV fluctuations *as a fraction of PWV parameter* 0.15 
        	beta		 exponent of fractional brownian motion 1.1 
        	windspeed	 wind speed for screen type corruption (m/s) 7. 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_settrop(self, *args, **kwargs)

    def setpointingerror(self, *args, **kwargs):
        """
        setpointingerror(self, epjtablename=string(""), applypointingoffsets=False, dopbcorrection=False) -> bool

        Summary
        	Set the Pointing error

        Description
        	
        Set the pointing error from a calpointing table


        Input Parameters:
        	epjtablename	 Name of a table that has E-Jones errors for Pointing 
        	applypointingoffsets	 Apply pointing offsets false 
        	dopbcorrection	 apply primary beam correction false 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setpointingerror(self, *args, **kwargs)

    def setleakage(self, *args, **kwargs):
        """
        setleakage(self, mode=string("constant"), table=string(""), amplitude=initialize_vector(1, (double)0.01), 
            offset=initialize_vector(1, (double)0.)) -> bool

        Summary
        	Set the polarization leakage

        Description
        	
        Set the level of polarization leakage between feeds.
        Currently, no time dependence is available.


        Input Parameters:
        	mode		 Mode of operation. String: 'constant' constant 'constant' 
        	table		 Optional name of table to write '' 
        	amplitude	 Magnitude of pol leakage [real,imag] 0.01 [] 
        	offset		 Meam of pol leakage [real,imag] 0. [] 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setleakage(self, *args, **kwargs)

    def oldsetnoise(self, *args, **kwargs):
        """
        oldsetnoise(self, mode=string("calculate"), table=string(""), simplenoise=initialize_variant("0.0Jy"), 
            antefficiency=0.8, correfficiency=0.85, spillefficiency=0.85, tau=0.1, 
            trx=50, tatmos=230.0, tcmb=2.7) -> bool

        Summary
        	Set the noise level fixed sigma (mode=simplenoise) or
           Brown's equation (mode=calculate) OBSOLETE VERSION

        Description
        	
        Set various system parameters from which the thermal (ie, random additive) noise level 
        will be calculated.  

        For mode=simplenoise, one specifies the standard deviation for the noise to be
        added to real and imaginary parts of the visibility.

        For mode=calculate, the noise will vary with dish diameter, antenna efficiency,
        system temperature, opacity, sky temperature, etc.  The noise will increase with
        the airmass if {	t tau} is greater than zero.  The noise is calculated according to
        the {\it Brown Equation} (ie, R.L. Brown's calculation of MMA sensitivity, 3Oct95):
        egin{equation}
        \Delta S = rac{ 4 \sqrt{2} [ T_{rx}e^{	au A} + T_{atm} ( e^{	au A} - psilon_{l}) + T_{cmb}] }
                        {  psilon_{q} psilon_{a} \pi D^2 \sqrt{\Delta 
        u \Delta t }}
        nd{equation}


        Input Parameters:
        	mode		 Mode of operation. String: 'simplenoise'|'calculate' calculate 'simplenoise' 'calculate' 
        	table		 Name of noise table - not currently implemented '' 
        	simplenoise	 Level of noise (if mode=simplenoise) 0.0Jy 
        	antefficiency	 antenna efficiency 0.8 0.8 
        	correfficiency	 Correlation efficiency 0.85 0.85 
        	spillefficiency	 Forward spillover efficiency 0.85 0.85 
        	tau		 Atmospheric Opacity 0.1 0.1 
        	trx		 Receiver temp (ie, all non-atmospheric Tsys contributions) [K] 50 50 
        	tatmos		 (Physical, not Brightness) Temperature of atmosphere [K] 230.0 230.0 
        	tcmb		 Temperature of cosmic microwave background [K] 2.7 2.7 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_oldsetnoise(self, *args, **kwargs)

    def setnoise(self, *args, **kwargs):
        """
        setnoise(self, mode=string("simplenoise"), table=string(""), simplenoise=initialize_variant("0.1Jy"), 
            pground=initialize_variant("560mbar"), relhum=20.0, altitude=initialize_variant("5000m"), 
            waterheight=initialize_variant("200m"), pwv=initialize_variant("1mm"), 
            tatmos=250.0, tau=0.1, antefficiency=0.8, spillefficiency=0.85, 
            correfficiency=0.88, trx=50, tground=270.0, tcmb=2.73, OTF=True, senscoeff=0., 
            rxtype=0) -> bool

        Summary
        	Set the noise level fixed sigma (mode=simplenoise) or
           Brown's equation using the ATM model for frequency-dependent atmospheric
           opacity (mode=tsys-atm) or Brown's equation, manually specifying the zenith
           opacity (constant across the band) and atmospheric temperature 
           (mode=tsys-manual)

        Description
        	
        Set various system parameters from which the thermal (ie, random additive) noise level 
        will be calculated.  

        For mode=simplenoise, one specifies the standard deviation for the noise to be
        added to real and imaginary parts of the visibility.

        For mode=tsys-atm or tsys-atm, the noise will vary with dish diameter, antenna efficiency,
        system temperature, opacity, sky temperature, etc.  The noise will increase with
        the airmass if tau is greater than zero.  The noise is calculated according to
        the Brown Equation (ie, R.L. Brown's calculation of MMA sensitivity, 3Oct95):
        dS = 4 sqrt(2) [ T\_rx e\^{tau A} + T\_atm ( e\^{tau A} - epsilon\_l) + T\_cmb] / 
                       [ epsilon\_q epsilon\_a pi D\^2 sqrt{Delta nu Delta t} ]

        For mode=tsys-atm, the sky brightness temperature is calculated using an atmospheric model created for the user-input PWV.
        For mode=tsys-manual, the user specifies the sky brightness temperature 
        manually.


        Input Parameters:
        	mode		 Mode of operation. simplenoise 'simplenoise' 'tsys-atm' 'tsys-manual' 
        	table		 Name of optional cal table to write '' 
        	simplenoise	 Level of noise if not calculated 0.1Jy 
        	pground		 Ground pressure for ATM model (if tsys-atm) 560mbar 
        	relhum		 ground relative humidity for ATM model (if tsys-atm) 20.0 
        	altitude	 site altitude for ATM model (if tsys-atm) 5000m 
        	waterheight	 Height of water layer for ATM model (if tsys-atm) 200m 
        	pwv		 Precipitable Water Vapor ATM model (if tsys-atm) 1mm 
        	tatmos		 Temperature of atmosphere [K] (if tsys-manual) 250.0 
        	tau		 Zenith Atmospheric Opacity (if tsys-manual) 0.1 
        	antefficiency	 Antenna efficiency 0.8 
        	spillefficiency	 Forward spillover efficiency 0.85 
        	correfficiency	 Correlation efficiency 0.88 
        	trx		 Receiver temp (ie, all non-atmospheric Tsys contributions) [K] 50 
        	tground		 Temperature of ground/spill [K] 270.0 
        	tcmb		 Temperature of cosmic microwave background [K] 2.73 
        	OTF		 calculate noise on-the-fly (WARNING: only experts with high-RAM machines should use False) true 
        	senscoeff	 sensitivity constant (1./sqrt(2) for interferometer [default]; 1. for total power) 0. 
        	rxtype		 Receiver type; 0=2SB, 1=DSB e.g. ALMA B9 0 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setnoise(self, *args, **kwargs)

    def setpa(self, *args, **kwargs):
        """
        setpa(self, mode=string("calculate"), table=string(""), interval=initialize_variant("10s")) -> bool

        Summary
        	Corrupt phase by the parallactic angle

        Description
        	
        Corrupt phase by the parallactic angle


        Input Parameters:
        	mode		 Mode of operation. String: 'calculate'|'table' calculate 'calculate' 
        	table		 Name of table '' 
        	interval	 Interval for parallactic angle application, e.g. '10s' 10s 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setpa(self, *args, **kwargs)

    def setseed(self, seed=185349251):
        """
        setseed(self, seed=185349251) -> bool

        Summary
        	Set the seed for the random number generator

        Description
        	



        Input Parameters:
        	seed		 Seed 185349251 185349251 
        	
        --------------------------------------------------------------------------------
        	      
        """
        return _simulator.simulator_setseed(self, seed)

simulator_swigregister = _simulator.simulator_swigregister
simulator_swigregister(simulator)

# This file is compatible with both classic and new-style classes.


