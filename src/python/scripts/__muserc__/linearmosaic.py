# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_linearmosaic', [dirname(__file__)])
        except ImportError:
            import _linearmosaic
            return _linearmosaic
        if fp is not None:
            try:
                _mod = imp.load_module('_linearmosaic', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _linearmosaic = swig_import_helper()
    del swig_import_helper
else:
    import _linearmosaic
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class linearmosaic(_object):
    """Proxy of C++ casac::linearmosaic class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, linearmosaic, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, linearmosaic, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> linearmosaic"""
        this = _linearmosaic.new_linearmosaic()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _linearmosaic.delete_linearmosaic
    __del__ = lambda self : None;
    def defineoutputimage(self, *args, **kwargs):
        """
        defineoutputimage(self, nx=128, ny=-1, cellx=initialize_variant("1.0"), celly=initialize_variant(""), imagecenter=initialize_variant("0"), 
            outputimage=string(""), outputweight=string("")) -> bool

        Summary
        	Set the output direction image parameters and name

        Description
        	
        Define the direction axes output image parameters.
        The output image will get the same number of spectral and polarization planes as the input images. This function create a fresh new output image. If an image of the same name exist on disk it will be erased. The spectral and polarization part of the image will be identical to the images that are being mosaiced.

        The output image will by default be flux correct and the weight image will be ${\sum_p A_p^2(	heta)}$ where the primary beam is $  A_p(	heta)$



        Input Parameters:
        	nx		 Total number of spatial pixels in x 128 
        	ny		 Total number of spatial pixels in y -1 
        	cellx		 Cellsize in x (e.g. '1arcsec') 1.0 
        	celly		 Cellsize in y (e.g. '1arcsec') 
        	imagecenter	 Direction of phase center as a diretion measure 0 
        	outputimage	 output image name 
        	outputweight	 output weight image name 
        	
        Example:
        	

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos', outputweight='test.weightlinmos')



        --------------------------------------------------------------------------------
        	      
        """
        return _linearmosaic.linearmosaic_defineoutputimage(self, *args, **kwargs)

    def setoutputimage(self, *args, **kwargs):
        """
        setoutputimage(self, outputimage=string(""), outputweight=string(""), imageweighttype=1, weighttype=1) -> bool

        Summary
        	Use this function to mosaic on an existing image and weight image

        Description
        	
        Use this function if the mosaicing is to be done onto a previous mosaic or image. For now the stokes and spectral characteristic of the images to be mosaic and the output image has to be similar (i.e the user has to regrid them prior to linearmosaic if necessary).
        The weightimage represents the sensitivity image of the image (for example the weighted primary beam coverage of a mosaic)

        {	t imageweighttype} parameter:

        If the image is of the type that has been normalized to be flux correct then the imageweighttype should 0.
        If the image has been  apodized by a primary beam then imageweighttype should be 1 
        and if the image is multiplied by $PB^2$ then it should be 2.

        {	t weighttype} parameter:
        This should be 1 if the weight image is the sum of Primary beams or equivalent
        and it should be 2 if it is the sum of of $PB^2$ 





        Input Parameters:
        	outputimage	 Existing mosaic imagename 
        	outputweight	 Existing weight image for mosaic 
        	imageweighttype	 what kind of weight was already applied to image 
         0: flux correct 
         1: Primary beam equivalent weight 
         2: $PB^2$ equivalent weight 
         1 0 1 2 
        	weighttype	 what kind of weight is weight image 
         1: Primary beam equivalent weight 
         2: $PB^2$ equivalent 
         1 1 2 
        	
        Example:
        	
        lm.setoutputimage(outputimage='testoo.linmos', outputweight='testoo.linmos.weight', imageweightype=0, weighttype=2)



        --------------------------------------------------------------------------------
        	      
        """
        return _linearmosaic.linearmosaic_setoutputimage(self, *args, **kwargs)

    def saultweightimage(self, *args, **kwargs):
        """
        saultweightimage(self, outputimage=string(""), fracpeak=0.1) -> bool

        Summary
        	Use this function to create a Sault-weighted image

        Description
        	
         'Sault weighted' image is one which is more pleasant to view (without high noise at the edges of mosaic images), it is flux correct upto a where the beam coverage becomes low and is tapered off onwards just to keep the noise from rising in the overall image(see  Eq[2] from Sault, Staveley-Smith and Brouw (1996), Astron. Astrophys. Suppl, 120, 375)



        Input Parameters:
        	outputimage	 Name of image to create the Sault-Weighted image 
        	fracpeak	 Upto what fraction of peak of coverage should the image be flux correct 0.1 
        	
        Example:
        	

         lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos')
        lm.makemosaic(images=['FIELD_31/img.image', 'FIELD_33/img.image'], weightimages=['FIELD_31/img.pb', 'FIELD_33/img.pb'])
        ###the above will make a flux correct mosaic of the 2 images in a flux correct fashion in test.linmos
        #Now make a Sault weighted image to use in the viewer
        lm.saultweightimage('test_sault.linmos')


        --------------------------------------------------------------------------------
        	      
        """
        return _linearmosaic.linearmosaic_saultweightimage(self, *args, **kwargs)

    def setlinmostype(self, *args, **kwargs):
        """
        setlinmostype(self, linmostype=string("optimal")) -> bool

        Summary
        	Use this function to set if you want to mosaic in flatnoise domain

        Description
        	
        Use this function if the mosaicing is to be done using a non optimal weighting mode.



        Input Parameters:
        	linmostype	 Type of weighting for linear mosaic optimal optimal pbweight 
        	
        Example:
        	

        --------------------------------------------------------------------------------
        	      
        """
        return _linearmosaic.linearmosaic_setlinmostype(self, *args, **kwargs)

    def makemosaic(self, *args, **kwargs):
        """
        makemosaic(self, images=initialize_variant(""), weightimages=initialize_variant(""), imageweighttype=1, 
            weighttype=1) -> bool

        Summary
        	mosaic images in a weighted fashion onto ouput image

        Description
        	
        Put the list of images onto the mosaic image using the weight images


        Input Parameters:
        	images		 Name of images to mosaic 
        	weightimages	 Name of images to mosaic 
        	imageweighttype	 what kind of weight is already applied to image 
         0: flux correct 
         1: Primary beam equivalent weight 
         2: PB^2 equivalent 
         1 0 1 2 
        	weighttype	 what kind of weight image it is 
         1: Primary beam equivalent weight 
         2: PB^2 equivalent 
         1 1 2 
        	
        Example:
        	
         lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos')

        ###make a mosaic of two fields
        lm.makemosaic(images=['FIELD_31/img.image', 'FIELD_33/img.image'], weightimages=['FIELD_31/img.pb', 'FIELD_33/img.pb'])

        ####now we have another submosaic (which is flux corrected) we want to add to this mosaic

        lm.makemosaic(images='submosaic.image', weightimages='submosaic.flux',  imageweighttype=0, weighttype=1)



        --------------------------------------------------------------------------------
        	      
        """
        return _linearmosaic.linearmosaic_makemosaic(self, *args, **kwargs)

linearmosaic_swigregister = _linearmosaic.linearmosaic_swigregister
linearmosaic_swigregister(linearmosaic)

# This file is compatible with both classic and new-style classes.


