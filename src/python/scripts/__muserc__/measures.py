# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_measures', [dirname(__file__)])
        except ImportError:
            import _measures
            return _measures
        if fp is not None:
            try:
                _mod = imp.load_module('_measures', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _measures = swig_import_helper()
    del swig_import_helper
else:
    import _measures
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class measures(_object):
    """Proxy of C++ casac::measures class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, measures, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, measures, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_dot_touvw"] = _measures.measures__dot_touvw_set
    __swig_getmethods__["_dot_touvw"] = _measures.measures__dot_touvw_get
    if _newclass:_dot_touvw = _swig_property(_measures.measures__dot_touvw_get, _measures.measures__dot_touvw_set)
    __swig_setmethods__["_xyz_touvw"] = _measures.measures__xyz_touvw_set
    __swig_getmethods__["_xyz_touvw"] = _measures.measures__xyz_touvw_get
    if _newclass:_xyz_touvw = _swig_property(_measures.measures__xyz_touvw_get, _measures.measures__xyz_touvw_set)
    __swig_setmethods__["_xyz_expand"] = _measures.measures__xyz_expand_set
    __swig_getmethods__["_xyz_expand"] = _measures.measures__xyz_expand_get
    if _newclass:_xyz_expand = _swig_property(_measures.measures__xyz_expand_get, _measures.measures__xyz_expand_set)
    def __init__(self): 
        """__init__(self) -> measures"""
        this = _measures.new_measures()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _measures.delete_measures
    __del__ = lambda self : None;
    def dirshow(self, *args, **kwargs):
        """
        dirshow(self, v) -> string

        Summary
        	

        Show direction measure as a string.
           

        Description
        	
        dirshow will convert a direction measure to a string


        Input Parameters:
        	v		 a direction measure value to be converted to string 
        	
        Example:
        	

        print '	----	 dirshow Ex 1 	----'
        print me.dirshow(me.direction('venus'))
        #[0, 90] deg  VENUS


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_dirshow(self, *args, **kwargs)

    def show(self, *args, **kwargs):
        """
        show(self, v, refcode=True) -> string

        Summary
        	 Show a measure as a string
           

        Description
        	
        show will convert a measure to a string.

        All measures are catered for (at this moment {m direction, position, epoch,
        radialvelocity, frequency, doppler, baseline, uvw, earthmagnetic} ).


        Input Parameters:
        	v		 measure value to be converted to string 
        	refcode		 add the reference code to output true 
        	
        Example:
        	

        print '	----	 show Ex 1 	----'
        print me.show(me.frequency('lsrk', qa.constants('HI')))
        #1.42041e+09 Hz LSRK
        print me.show(me.frequency('lsrk', qa.constants('HI')), refcode=false)
        #1.42041e+09 Hz


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_show(self, *args, **kwargs)

    def epoch(self, *args, **kwargs):
        """
        epoch(self, rf=string("UTC"), v0=initialize_variant(""), off=initialize_record("")) -> record *

        Summary
        	define an epoch measure

        Description
        	
        epoch defines an epoch measure from the CLI. It has to specify a
        reference code, an epoch quantity value (see introduction for the
        action on a scalar quantity with either a vector or scalar value),

        and optionally it can specify an offset, which in itself has to be an
        epoch. Allowable reference codes are:
        {m UTC TAI LAST LMST GMST1 GAST UT1 UT2 TDT TCG TDB TCB}.\
        Note that additional ones may become available. Check in \casa\ with:

        egin{verbatim}
        print '	----	 epoch Ex 1 	----'
        print me.listcodes(me.epoch())
        #{'normal': ['LAST', 'LMST', 'GMST1', 'GAST', 'UT1', 'UT2', 'UTC', 'TAI',
        # 'TDT', 'TCG', 'TDB', 'TCB', 'IAT', 'GMST', 'TT', 'ET', 'UT'], 'extra': []}
        #
        nd{verbatim}

        See quantity for possible time formats.


        Input Parameters:
        	rf		 reference code UTC 
        	v0		 epoch value 
        	off		 optional offset epoch measure 
        	
        Example:
        	

        print '	----	 epoch Ex 2 	----'
        print me.epoch('utc','today') 
        #{'m0': {'value': 54048.861237743055, 'unit': 'd'},
        # 'refer': 'UTC',
        # 'type': 'epoch'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_epoch(self, *args, **kwargs)

    def direction(self, *args, **kwargs):
        """
        direction(self, rf=string("J2000"), v0=initialize_variant(""), v1=initialize_variant(""), off=initialize_record("")) -> record *

        Summary
        	define a direction measure

        Description
        	
        direction defines a direction measure from the CLI. It has to specify a 
        reference code, direction quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value),

        and optionally it can specify an
        offset, which in itself has to be a direction. Allowable reference codes are:
        {m J2000 JMEAN JTRUE APP B1950 BMEAN BTRUE GALACTIC HADEC AZEL 
        SUPERGAL ECLIPTIC MECLIPTIC TECLIPTIC MERCURY
        VENUS MARS JUPITER SATURN URANUS NEPTUNE PLUTO MOON SUN COMET}.\
        Note that additional ones may become available. Check in \casa\ with:

        egin{verbatim}
        print '	----	 direction Ex 1 	----'
        print me.listcodes(me.direction())
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN',
        #'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
        #'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
        #'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'], 'extra': ['MERCURY',
        #'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE', 'PLUTO',
        #'SUN', 'MOON', 'COMET']}
        nd{verbatim}
          
        The direction quantity values should be longitude(angle) and
        latitude(angle) (none needed for planets: the frame epoch defines coordinates).
        See quantity for possible angle formats.


        Input Parameters:
        	rf		 reference code J2000 
        	v0		 longitude 
        	v1		 latitude 
        	off		 optional offset direction measure 
        	
        Example:
        	

        print '	----	 direction Ex 2 	----'
        print me.direction('j2000','30deg','40deg')
        #{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
        # 'm1': {'value': 0.69813170079773168, 'unit': 'rad'},
        # 'refer': 'J2000',
        # 'type': 'direction'}
        #
        print me.direction('mars')
        #{'m0': {'value': 0.0, 'unit': 'rad'},
        # 'm1': {'value': 1.5707963267948966, 'unit': 'rad'},
        # 'refer': 'MARS',
        # 'type': 'direction'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_direction(self, *args, **kwargs)

    def getvalue(self, *args, **kwargs):
        """
        getvalue(self, v) -> record *

        Summary
        	get the value of a measure

        Description
        	
        getvalue gets the actual implementation value of the measure.


        Input Parameters:
        	v		 measure (array of measures) 
        	
        Example:
        	

        print '	----	 getvalue Ex 1 	----'
        b=me.direction('j2000','0deg','80deg')
        print me.getvalue(b)
        #{'m0': {'value': 0.0, 'unit': 'rad'},
        # 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_getvalue(self, *args, **kwargs)

    def gettype(self, *args, **kwargs):
        """
        gettype(self, v) -> string

        Summary
        	get the type of a measure

        Description
        	
        gettype gets the actual type of the measure.


        Input Parameters:
        	v		 measure (array of measures) 
        	
        Example:
        	

        print '	----	 gettype Ex 1 	----'
        b=me.direction('j2000','0deg','80deg')
        print me.getvalue(b)
        #{'m0': {'value': 0.0, 'unit': 'rad'},
        # 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}
        print me.gettype(b)
        #'Direction'


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_gettype(self, *args, **kwargs)

    def getref(self, *args, **kwargs):
        """
        getref(self, v) -> string

        Summary
        	get the reference code of a measure

        Description
        	
        gettype gets the actual reference code of the measure.


        Input Parameters:
        	v		 measure (array of measures) 
        	
        Example:
        	

        print '	----	 getref Ex 1 	----'
        b=me.direction('j2000','0deg','80deg')
        print me.getvalue(b)
        #{'m0': {'value': 0.0, 'unit': 'rad'},
        # 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}
        print me.gettype(b)
        #'Direction'
        print me.getref(b)
        #'J2000'


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_getref(self, *args, **kwargs)

    def getoffset(self, *args, **kwargs):
        """
        getoffset(self, v) -> record *

        Summary
        	get the offset of a measure

        Description
        	
        getoff gets the actual offset of the measure (as a measure) or F if no offset
        given. 


        Input Parameters:
        	v		 measure (array of measures) 
        	
        Example:
        	

        print '	----	 getoffset Ex 1 	----'
        b=me.direction('j2000','0deg','80deg')
        print me.getvalue(b)
        #{'m0': {'value': 0.0, 'unit': 'rad'},
        # 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}
        print me.gettype(b)
        #'Direction'
        print me.getref(b)
        #'J2000'
        print me.getoffset(b)
        #{}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_getoffset(self, *args, **kwargs)

    def cometname(self):
        """
        cometname(self) -> string

        Summary
        	get the current comet name

        Description
        	
        cometname gets the name of the current comet (if any).

        Example:
        	

        print '	----	 cometname Ex 1 	----'
        print me.cometname()
        #Thu Nov 9 21:27:25 2006      WARN :
        #Method cometname fails! No Comet table present
        #''


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_cometname(self)

    def comettype(self):
        """
        comettype(self) -> string

        Summary
        	get the current comet table type

        Description
        	
        comettype gets the comet table type (apparent or topocentric)

        Example:
        	

        print '	----	 comettype Ex 1 	----'
        print me.comettype()
        # 'none'


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_comettype(self)

    def cometdist(self):
        """
        cometdist(self) -> record *

        Summary
        	get the distance of the current comet in the current frame

        Description
        	
            cometdist returns the distance in AU of the current comet in the current frame,
            as a quantity.  It will return -1 AU on failure!
          
        Example:
        	

        print '	----	 cometdist Ex 1 	----'
        # Directory with several Solar System ephemerides for setjy.
        cometdir = os.getenv('CASAPATH').split()[0] + '/data/ephemerides/JPL-Horizons/'
        me.framecomet(cometdir + 'Ganymede_55438-56292dUTC.tab')
        #  Out[5]: True
        me.doframe(me.epoch('utc', '2011/01/03/17:00:00'))
        me.doframe(me.observatory('ALMA'))
        gandist = me.cometdist()
        print gandist
        # {'value': 5.1241088343892631, 'unit': 'AU'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_cometdist(self)

    def cometangdiam(self):
        """
        cometangdiam(self) -> record *

        Summary
        	get the angular diameter of the current comet in the current frame

        Description
        	
            cometdist returns the angular diameter (as seen from Earth) in AU of the current
            comet in the current frame, as a quantity.  It will return -1 radians on failure!
          
        Example:
        	

        print '	----	 cometangdiam Ex 1 	----'
        # Directory with several Solar System ephemerides for setjy.
        cometdir = os.getenv('CASAPATH').split()[0] + '/data/ephemerides/JPL-Horizons/'
        me.framecomet(cometdir + 'Ganymede_55438-56292dUTC.tab')
        #  Out[5]: True
        me.doframe(me.epoch('utc', '2011/01/03/17:00:00'))
        me.doframe(me.observatory('ALMA'))
        gad = me.cometangdiam()
        print gad
        # {'unit': 'rad', 'value': 6.8679673431729014e-06}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_cometangdiam(self)

    def comettopo(self):
        """
        comettopo(self) -> record *

        Summary
        	get the current comet table coordinates

        Description
        	
        comettopo gets the comet table's topographic coordinates used.

        Example:
        	

        print '	----	 comettopo Ex 1 	----'
        print me.comettopo()
        #Thu Nov 9 21:45:40 2006      WARN :
        #Method comettopo fails!  No Topocentric Comet table present
        #{'value': [0.0], 'unit': ''}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_comettopo(self)

    def framecomet(self, *args, **kwargs):
        """
        framecomet(self, v=string("")) -> bool

        Summary
        	set the current comet table

        Description
        	
        framecomet will put the specified comet table in the frame.


        Input Parameters:
        	v		 name of a table 
        	
        Example:
        	

        print '	----	 framecomet Ex 1 	----'
        print me.framecomet('VGEO')
        #True
        print me.showframe()
        #'Frame: VENUS comet between MJD 50802.7 and 50803.1'
        print me.cometname()
        #'VENUS'
        print me.comettype()
        #'APP'
        print me.doframe(me.epoch('et',qa.quantity('1997/12/20/17:30:0')))
        #True
        print me.measure(me.direction('comet'),'app')
        #{'m0': {'value': -0.94936485919663083, 'unit': 'rad'},
        # 'm1': {'value': -0.34710256485894436, 'unit': 'rad'},
        # 'refer': 'APP',
        # 'type': 'direction'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_framecomet(self, *args, **kwargs)

    def position(self, *args, **kwargs):
        """
        position(self, rf=string("WGS84"), v0=initialize_variant(""), v1=initialize_variant(""), v2=initialize_variant(""), 
            off=initialize_record("")) -> record *

        Summary
        	define a position measure

        Description
        	
        position defines a position measure from the CLI. It has to specify a 
        reference code, position quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value),

        and optionally it can specify an
        offset, which in itself has to be a position. Allowable reference codes are:
        {m WGS84 ITRF} (World Geodetic System and International Terrestrial
        Reference Frame).\               
        Note that additional ones may become available. Check in \casa\ with:
                    
        egin{verbatim}
        print '	----	 position Ex 1 	----'
        print me.listcodes(me.position())
        #{'normal': ['ITRF', 'WGS84'], 'extra': []}
        nd{verbatim}
                                                       
         The position quantity values should be either longitude
        (angle), latitude(angle) and height(length); or x,y,z (length).
        See quantity for possible angle formats.


        Input Parameters:
        	rf		 reference code WGS84 
        	v0		 longitude or x 
        	v1		 latitude or y 
        	v2		 height or z 
        	off		 optional offset position measure 
        	
        Example:
        	

        print '	----	 position Ex 2 	----'
        print me.position('wgs84','30deg','40deg','10m')
        #{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
        # 'm1': {'value': 0.6981317007977319, 'unit': 'rad'},
        # 'm2': {'value': 9.9999999999999982, 'unit': 'm'},
        # 'refer': 'WGS84',
        # 'type': 'position'}
        print me.observatory('ATCA')
        #{'m0': {'value': 2.6101423190348916, 'unit': 'rad'},
        # 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
        # 'm2': {'value': 6372960.2577234386, 'unit': 'm'},
        # 'refer': 'ITRF',
        # 'type': 'position'}

        ###One can use a quantity-vectors  especially when dealing with multiple antenna positions  for e.g for 3 positions

        ants=me.position('itrf',qa.quantity([3828763.11,3828746.55, 3828727.43],'m'), qa.quantity([442449.106,442592.14, 442580.12],'m'), 
                     qa.quantity([5064923.01, 5064923.01, 5064923.51],'m')) 

        print ants
         
        #{'m0': {'unit': 'rad',
        #        'value': array([ 0.11504897,  0.11508633,  0.1150838 ])},
        # 'm1': {'unit': 'rad',
        #        'value': array([ 0.92031276,  0.92031276,  0.92031535])},
        # 'm2': {'unit': 'm',
        #        'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587])},
        # 'refer': 'ITRF',
        # 'type': 'position'}




        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_position(self, *args, **kwargs)

    def observatory(self, *args, **kwargs):
        """
        observatory(self, name=string("ALMA")) -> record *

        Summary
        	get position of an observatory

        Description
        	
        observatory will give you the position of an observatory as given in the
        system. At the time of writing the following observatories are recognised
        (but check e.g. the position GUI for currently known ones, or the
        me.obslist() tool function):
        {m'ALMA' 'ARECIBO' 'ATCA' 'BIMA' 'CLRO' 'DRAO' 'DWL' 'GB' 'GBT' 'GMRT'
         'IRAM PDB' 'IRAM_PDB' 'JCMT' 'MOPRA' 'MOST' 'NRAO12M' 'NRAO_GBT' 'PKS'
         'SAO SMA' 'SMA' 'VLA' 'VLBA' 'WSRT' 'ATF' 'ATA' 'CARMA' 'ACA' 'OSF'
         'OVRO_MMA' 'EVLA' 'ASKAP' 'APEX' 'SMT' 'NRO' 'ASTE' 'LOFAR' 'MeerKAT'
         'KAT-7' 'EVN' 'LWA1' 'PAPER_SA' 'PAPER_GB' 'e-MERLIN' 'MERLIN2'
         'Effelsberg' 'MWA32T' }.


        Input Parameters:
        	name		 observatory name - case insensitive ALMA 
        	
        Example:
        	

        print '	----	 observatory Ex 1 	----'
        print me.observatory('ATCA')
        #{'m0': {'value': 2.6101423190348916, 'unit': 'rad'},
        # 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
        # 'm2': {'value': 6372960.2577234386, 'unit': 'm'},
        # 'refer': 'ITRF',
        # 'type': 'position'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_observatory(self, *args, **kwargs)

    def obslist(self):
        """
        obslist(self) -> std::vector< std::string >

        Summary
        	get a list of known observatories

        Description
        	
        obslist will give you an array of strings of the 
        observatories known in the Observatories table.

        Example:
        	

        print '	----	 obslist Ex 1 	----'
        print me.obslist()

        #['ALMA' 'ARECIBO' 'ATCA' 'BIMA' 'CLRO' 'DRAO' 'DWL' 'GB' 'GBT' 'GMRT'
         #'IRAM PDB' 'IRAM_PDB' 'JCMT' 'MOPRA' 'MOST' 'NRAO12M' 'NRAO_GBT' 'PKS'
         #'SAO SMA' 'SMA' 'VLA' 'VLBA' 'WSRT' 'ATF' 'ATA' 'CARMA' 'ACA' 'OSF'
         #'OVRO_MMA' 'EVLA' 'ASKAP' 'APEX' 'SMT' 'NRO' 'ASTE' 'LOFAR' 'MeerKAT'
         #'KAT-7' 'EVN' 'LWA1' 'PAPER_SA' 'PAPER_GB' 'e-MERLIN' 'MERLIN2'
         #'Effelsberg' 'MWA32T']


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_obslist(self)

    def linelist(self):
        """
        linelist(self) -> string

        Summary
        	get a list of known spectral lines

        Description
        	
        linelist will give you a string with a space separated list of spectral lines
        known in the Lines table.

        A number of lines are available now, but tables with many lines are
        already online, and will be interfaced once a nomenclature can be defined for
        the tens of thousands of lines.

        Example:
        	

        print '	----	 linelist Ex 1 	----'
        print me.linelist()
        #'C109A CI CII166A DI H107A H110A H138B H166A H240A H272A
        # H2CO HE110A HE138B HI OH1612 OH1665 OH1667 OH1720'


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_linelist(self)

    def spectralline(self, *args, **kwargs):
        """
        spectralline(self, name=string("HI")) -> record *

        Summary
        	get frequency of a spectral line

        Description
        	
        spectralline will give you the frequency of a spectral line. The known list
        can be obtained by me.linelist().


        Input Parameters:
        	name		 name HI 
        	
        Example:
        	

        print '	----	 spectralline Ex 1 	----'
        print me.spectralline('HI')
        #{'m0': {'value': 1420405751.786, 'unit': 'Hz'},
        # 'refer': 'REST',
        # 'type': 'frequency'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_spectralline(self, *args, **kwargs)

    def sourcelist(self):
        """
        sourcelist(self) -> string

        Summary
        	get a list of known sources

        Description
        	
        sourcelist will give you a string with the space separated list of sources 
        known in the Sources table.

        Example:
        	

        print '	----	 sourcelist Ex 1 	----'
        print me.sourcelist()[0:62]
        #'0002-478 0003+380 0003-066 0007+106 0007+171 0008-264 0008-421'
        #......


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_sourcelist(self)

    def source(self, *args, **kwargs):
        """
        source(self, name=initialize_variant("1934-638")) -> record *

        Summary
        	get direction of a source

        Description
        	
        source will give you the direction of a source. The known list
        can be obtained by me.sourcelist().


        Input Parameters:
        	name		 name 1934-638 
        	
        Example:
        	

        print '	----	 source Ex 1 	----'
        print me.source()
        print me.source('1934-638')
        #  Out[19]:
        #{'m0': {'value': -1.1370073467795063, 'unit': 'rad'},
        # 'm1': {'value': -1.1119959323803881, 'unit': 'rad'},
        # 'refer': 'ICRS',
        # 'type': 'direction'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_source(self, *args, **kwargs)

    def frequency(self, *args, **kwargs):
        """
        frequency(self, rf=string("LSRK"), v0=initialize_variant(""), off=initialize_record("")) -> record *

        Summary
        	define a frequency measure

        Description
        	
        frequency defines a frequency measure from the CLI. It has to specify a 
        reference code, frequency quantity value (see introduction for the action on a
        scalar quantity with either a vector or scalar value),

        and optionally it can specify an
        offset, which in itself has to be a frequency. Allowable reference codes are:
        {m REST LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB}.\
        Note that additional ones may become available. Check in \casa\ with:
        egin{verbatim}
        print '	----	 frequency Ex 1 	----'
        print me.listcodes(me.frequency())
        #{'normal': ['REST', 'LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO',
        # 'GALACTO', 'LGROUP', 'CMB'], 'extra': []}
        nd{verbatim}

        The frequency quantity values should be in one of the recognised units
        (examples all give same frequency):
        egin{itemize}
        \item value with time units: a period (0.5s)
        \item value as frequency: 2Hz
        \item value in angular frequency: 720deg/s
        \item value as length: 149896km
        \item value as wave number: 4.19169e-8m-1
        \item value as energy (h.nu): 8.27134e-9ueV
        \item value as momentum: 4.42044e-42kg.m
        nd{itemize}


        Input Parameters:
        	rf		 reference code LSRK 
        	v0		 frequency/wavelength/\ldots 
        	off		 optional offset frequency measure 
        	
        Example:
        	

        print '	----	 frequency Ex 2 	----'
        print me.frequency('lsrk','5GHz')
        #{'m0': {'value': 5000000000.0, 'unit': 'Hz'},
        # 'refer': 'LSRK',
        # 'type': 'frequency'}
        print me.frequency('lsrk','21cm')
        #{'m0': {'value': 1427583133.3333333, 'unit': 'Hz'},
        # 'refer': 'LSRK',
        # 'type': 'frequency'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_frequency(self, *args, **kwargs)

    def doppler(self, *args, **kwargs):
        """
        doppler(self, rf=string("RADIO"), v0=initialize_variant(""), off=initialize_record("")) -> record *

        Summary
        	define a doppler measure

        Description
        	
        doppler defines a doppler measure from the CLI. It has to specify a 
        reference code, doppler quantity value (see introduction for the action on a
        scalar quantity with either a vector or scalar value),

        and optionally it can specify an offset,
        which in itself has to be a doppler. Allowable reference codes are:
        {m RADIO Z RATIO BETA GAMMA OPTICAL TRUE RELATIVISTIC}.\
        Note that additional ones may become available. Check in \casa\ with:
           
        egin{verbatim}
        print '	----	 doppler Ex 1 	----'
        print me.listcodes(me.doppler())
        #{'normal': ['RADIO', 'Z', 'RATIO', 'BETA', 'GAMMA', 'OPTICAL',
        # 'TRUE', 'RELATIVISTIC'], 'extra': []}
        nd{verbatim}

        The doppler quantity values should be either non-dimensioned to specify a
        ratio of the light velocity, or in velocity.


        Input Parameters:
        	rf		 reference code RADIO 
        	v0		 doppler ratio/velocity 
        	off		 optional offset doppler measure 
        	
        Example:
        	
        Examples both give same doppler:

        print '	----	 doppler Ex 2 	----'
        print me.doppler('radio','0.4')
        #{'m0': {'value': 119916983.2, 'unit': 'm/s'},
        # 'refer': 'RADIO',
        # 'type': 'doppler'}
        print me.doppler('radio',qa.mul(qa.quantity('0.4'),qa.constants('c')))
        #{'m0': {'value': 119916983.2, 'unit': 'm/s'},
        # 'refer': 'RADIO',
        # 'type': 'doppler'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_doppler(self, *args, **kwargs)

    def radialvelocity(self, *args, **kwargs):
        """
        radialvelocity(self, rf=string("LSRK"), v0=initialize_variant(""), off=initialize_record("")) -> record *

        Summary
        	define a radialvelocity measure

        Description
        	
        radialvelocity defines a radialvelocity measure from the CLI. It has to
        specify a reference code, radialvelocity quantity value (see introduction for 
        the action on a
        scalar quantity with either a vector or scalar value),

        and optionally it
        can specify an offset, which in itself has to be a radialvelocity. 
        Allowable reference codes are:
        {m LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB}.\                          
        Note that additional ones may become available. Check in \casa\ with:
                                                            
        egin{verbatim}
        print '	----	 radialvelocity Ex 1 	----'
        print me.listcodes(me.radialvelocity())
        #  Out[17]:
        #{'extra': [],
        # 'normal': ['LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO', 'GALACTO',
        # 'LGROUP', 'CMB']}
        nd{verbatim}
        The radialvelocity quantity values should be given as velocity.


        Input Parameters:
        	rf		 reference code LSRK 
        	v0		 radial velocity 
        	off		 optional offset radialvelocity measure 
        	
        Example:
        	

        print '	----	 radialvelocity Ex 2 	----'
        print me.radialvelocity('lsrk','20km/s')
        #  Out[18]:
        #{'m0': {'value': 20000.0, 'unit': 'm/s'},
        # 'refer': 'LSRK',
        # 'type': 'radialvelocity'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_radialvelocity(self, *args, **kwargs)

    def shift(self, *args, **kwargs):
        """
        shift(self, v=initialize_record(""), offset=initialize_variant("0deg"), pa=initialize_variant("0deg")) -> record *

        Summary
        	Shift a direction measure by an offset angle at a position angle.

        Description
        	
                This method calculates the direction measure located at the specified offset angular amount along the specified
                position angle from the specified direction measure.
                

        Input Parameters:
        	v		 The direction measure to shift, represented as a record. 
        	offset		 The angular offset, represented as a quantity record or string. 0deg 
        	pa		 Position angle of the offset, measured from the positive latitude axis through the positive longitude axis. 0deg 
        	
        Example:
        	
                v = me.direction('J2000', '13:22:44', '-50.20.20')
                # shift along 4 arcminues at a pa of 30 degrees.
                offset = me.shift(v, offset='4arcmin', pa='30deg')
                
        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_shift(self, *args, **kwargs)

    def uvw(self, *args, **kwargs):
        """
        uvw(self, rf=string("ITRF"), v0=initialize_variant(""), v1=initialize_variant(""), v2=initialize_variant(""), 
            off=initialize_record("")) -> record *

        Summary
        	define a uvw measure

        Description
        	
        uvw defines a uvw measure from the CLI. It has to specify a 
        reference code, uvw quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value),  and optionally it can specify an
        offset, which in itself has to be a uvw. Allowable reference codes are
        ITRF and the direction ones.\
        Note that additional ones may become available. Check in \casa\ with: 
        egin{verbatim}
        print '	----	 uvw Ex 1 	----'
        print me.listcodes(me.uvw())
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN',
        # 'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE',
        # 'AZELGEO', 'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC',
        # 'MECLIPTIC', 'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO',
        # 'ICRS'], 'extra': []}
        nd{verbatim}

        The uvw quantity values should be either longitude
        (angle), latitude(angle) and height(length); or x,y,z (length).
        See quantity for possible angle formats.


        Input Parameters:
        	rf		 reference code ITRF 
        	v0		 longitude or x 
        	v1		 latitude or y 
        	v2		 height or z 
        	off		 optional offset uvw measure 
        	
        Example:
        	

        print '	----	 uvw Ex 2 	----'
        print me.uvw('itrf','30deg','40deg','10m')
        #{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
        # 'm1': {'value': 0.6981317007977319, 'unit': 'rad'},
        # 'm2': {'value': 9.9999999999999982, 'unit': 'm'},
        # 'refer': 'ITRF',
        # 'type': 'uvw'}
        print me.doframe(me.epoch('utc','today'))
        #True
        print me.doframe(me.observatory('ALMA'))
        #True
        print me.doframe(me.direction('mars'))
        #True
        print me.measure(me.uvw('itrf','30deg','40deg','10m'), 'j2000')
        #{'m0': {'value': 0.52321924738347259, 'unit': 'rad'},
        # 'm1': {'value': 0.69813169995801672, 'unit': 'rad'},
        # 'm2': {'value': 10.0, 'unit': 'm'},
        # 'refer': 'J2000',
        # 'type': 'uvw'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_uvw(self, *args, **kwargs)

    def touvw(self, *args, **kwargs):
        """
        touvw(self, v=initialize_record(""), _dot=_dot_touvw, _xyz=_xyz_touvw) -> record *

        Summary
        	calculate a uvw measure from a baseline

        Description
        	
        touvw calculates a uvw measure from a baseline.   Note that the
        baseline does not have to be a proper {m baseline}, but can be a
        series of positions (to call positions baselines see 
        asbaseline ) for speed reasons:
        operations are linear and can be done on positions, which are
        converted to baseline values at the end (with
        expand ).

        Whatever the reference code of the baseline, the returned {m uvw} will be
        given in J2000. If the {m dot} argument is given, that variable
        will be filled with a quantity array consisting of the time
        derivative of the uvw (note that only the sidereal rate is taken
        into account; not precession, earth tides and similar variations,
        which are much smaller). If the {m xyz} variable is given, it will
        be filled with the quantity values of the uvw measure.

        The values of the input baselines can be given as a quantity
        vector per x, y or z value. 

        uvw coordinates are calculated for a certain direction in the sky;
        hence the frame has to contain the direction for the calculation to
        work. Since the baseline and the sky rotate with respect of each
        other, the time should be specified as well.


        Input Parameters:
        	v		 baseline measure 
        	

        Output Parameters:
        	_dot		 uvw-dot (quantity array) 
        	_xyz		 uvw (quantity array) 
        	
        Example:
        	

        print '	----	 touvw Ex 1 	----'
        print me.doframe(me.observatory('atca'))
        #True
        print me.doframe(me.source('1934-638'))
        #True
        print me.doframe(me.epoch('utc',qa.unit('today')))
        #True
        b=me.baseline('itrf','10m','20m','30m')
        print me.touvw(b)
        #{'dot': {'unit': 'm/s',
        #         'value': [-0.0011912452908351659,
        #                   -0.00098731747136827593,
        #                   -0.00048769097314181744]},
        # 'return': {'m0': {'value': -0.094777304811312649, 'unit': 'rad'},
        #            'm1': {'value': -1.1509286139398101, 'unit': 'rad'},
        #            'm2': {'value': 37.416573867739416, 'unit': 'm'},
        #            'refer': 'J2000',
        #            'type': 'uvw'},
        # 'xyz': {'unit': 'm',
        #         'value': [15.184026188402472,
        #                   -1.4434256399579168,
        #                   -34.166677788919138]}}
        print me.getvalue(me.touvw(b))
        #{'m0': {'value': -0.094777304811312649, 'unit': 'rad'},
        # 'm1': {'value': -1.1509286139398101, 'unit': 'rad'},
        # 'm2': {'value': 37.416573867739416, 'unit': 'm'}}
        print me.getvalue(me.touvw(b))['m0']
        #{'value': -0.094777304811312649, 'unit': 'rad'}

        ###Or when you are dealing with multiple antennas
        ####set the frame..i,e where, direction and when.
        me.doframe(me.observatory('VLA'))
        me.doframe(me.direction('J2000', '19h20m00', '20d10m00'))
        me.doframe(me.epoch('utc', '2007/07/08/20:30:00'))
        ####antenna positions 
        ants=me.position('itrf',qa.quantity([3828763.11,3828746.55, 3828727.43],'m'), qa.quantity([442449.106,442592.14, 442580.12],'m'), qa.quantity([5064923.01, 5064923.01, 5064923.51],'m')) 
        ###convert to baseline measures
        bl=me.asbaseline(ants)
        ###convert to uvw
        me.touvw(bl)

        #{'dot': {'unit': 'm/s',
        #         'value': array([ 181.25190155,  -73.29924893,  199.57974846,  181.25985238,
        #        -73.29691498,  199.57339353,  181.2583565 ,  -73.29668498,
        #        199.57276731])},
        # 'return': {'m0': {'unit': 'rad',
        #                   'value': array([ 2.21611194,  2.21610131,  2.21609887])},
        #            'm1': {'unit': 'rad',
        #                   'value': array([ 0.6984441 ,  0.69846521,  0.69846285])},
        #            'm2': {'unit': 'm',
        #                   'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587])},
        #            'refer': 'J2000',
        #            'type': 'uvw'},
        # 'xyz': {'unit': 'm',
        #         'value': array([-2931661.69632123,  3894141.52172208,  4092634.20894752,
        #       -2931568.34776551,  3894103.64373003,  4092737.08879791,
        #       -2931559.14911939,  3894111.22249941,  4092717.89890567])}}


        ####print the (n-1)n/2 baselines(u,v,w)
        me.expand(me.touvw(bl)['return'])['xyz']
        #{'unit': 'm',
        # 'value': array([  93.34855573,  -37.87799205,  102.8798504 ,  102.54720184,
        #        -30.29922267,   83.68995815,    9.19864612,    7.57876938,
        #        -19.18989224])}




        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_touvw(self, *args, **kwargs)

    def expand(self, *args, **kwargs):
        """
        expand(self, v=initialize_record(""), _xyz=_xyz_expand) -> record *

        Summary
        	expand n positions to n*(n-1)/2 baselines

        Description
        	
        expand calculates the differences between a series of given measure
        values: it calculates baseline values from position values. The
        returned value is a measure, but the value of the optional output
        variable {m xyz} will be set to an array of values.


        Input Parameters:
        	v		 measure (baseline, position or uvw measure) 
        	

        Output Parameters:
        	_xyz		 uvw (quantity array) 
        	
        Example:
        	

        print '	----	 expand Ex 1 	----'
        b=me.baseline('itrf', qa.quantity([10, 20, 30], 'm'), qa.quantity([10, 20, 30], 'm'), qa.quantity([0, 0, 0], 'm'))
        print me.expand(b)
        me.expand(b)
         
        #{'return': {'m0': {'unit': 'rad',
        #                   'value': array([ 0.78539816,  0.78539816,  0.78539816])},
        #            'm1': {'unit': 'rad', 'value': array([ 0.,  0.,  0.])},
        #            'm2': {'unit': 'm',
        #                   'value': array([ 14.14213562,  28.28427125,  14.14213562])},
        #            'refer': 'ITRF',
        #            'type': 'baseline'},
        # 'xyz': {'unit': 'm',
        #         'value': array([ 10.,  10.,   0.,  20.,  20.,   0.,  10.,  10.,   0.])}}

        print me.expand(b)['xyz']['value']

        #[ 10.  10.   0.  20.  20.   0.  10.  10.   0.]



        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_expand(self, *args, **kwargs)

    def earthmagnetic(self, *args, **kwargs):
        """
        earthmagnetic(self, rf=string("IGRF"), v0=initialize_variant(""), v1=initialize_variant(""), v2=initialize_variant(""), 
            off=initialize_record("")) -> record *

        Summary
        	define an earthmagnetic measure

        Description
        	
        earthmagnetic defines an earthmagnetic measure from the CLI. It needs
        a reference code, earthmagnetic quantity values 
        (see introduction for the action on a
        scalar quantity with either a vector or scalar value)  if the reference code is not
        for a model, and optionally it
        can specify an offset, which in itself has to be a earthmagnetic. In general
        you specify a model (IGRF is the default and the only one known) and convert
        it to an explicit field.  (See

         http://fdd.gsfc.nasa.gov/IGRF.html

        for information on the International Geomagnetic Reference Field). The
        earthmagnetic quantity values should be either longitude (angle),
        latitude(angle) and length(field strength); or x,y,z (field).
        See quantity for possible angle formats.


        Input Parameters:
        	rf		 reference code IGRF 
        	v0		 Field strength 
        	v1		 longitude 
        	v2		 latitude 
        	off		 optional offset earthmagnetic measure 
        	
        Example:
        	

        print '	----	 earthmagnetic Ex 1 	----'
        print me.earthmagnetic('igrf')
        #{'type': 'earthmagnetic', 'refer': 'IGRF', 'm1': {'value': 0.0, 'unit': 'nT'},
        # 'm0': {'value': 6.1230317691118855e-23, 'unit': 'nT'},
        # 'm2': {'value': 9.9999999999999995e-07, 'unit': 'nT'}}
        print me.doframe(me.observatory('atca'))
        print me.doframe(me.source('1934-638'))
        print me.doframe(me.epoch('utc',qa.unit('today')))
        print me.measure(me.earthmagnetic('igrf'), 'j2000')
        #{'type': 'earthmagnetic', 'refer': 'J2000',
        # 'm1': {'value': -8664.8767628222304, 'unit': 'nT'},
        # 'm0': {'value': 50544.054410564473, 'unit': 'nT'},
        # 'm2': {'value': 1799.5131920958615, 'unit': 'nT'}}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_earthmagnetic(self, *args, **kwargs)

    def baseline(self, *args, **kwargs):
        """
        baseline(self, rf=string("ITRF"), v0=initialize_variant(""), v1=initialize_variant(""), v2=initialize_variant(""), 
            off=initialize_record("")) -> record *

        Summary
        	define a baseline measure

        Description
        	
        baseline defines a baseline measure from the CLI. It has to specify a 
        reference code, baseline quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value, and when a vector of
        quantities is given), and optionally it can specify an
        offset, which in itself has to be a baseline. Allowable reference codes are
        ITRF and the direction ones.\
        Note that additional ones may become available. Check in \casa\ with:

        egin{verbatim}
        print '	----	 baseline Ex 1 	----'
        print me.listcodes(me.baseline())
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN', 'BTRUE',
        # 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO', 'AZELSWGEO',
        # 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC', 'TECLIPTIC', 'SUPERGAL',
        # 'ITRF', 'TOPO', 'ICRS'], 'extra': []}
        nd{verbatim}

        The baseline quantity values should be either longitude
        (angle), latitude(angle) and height(length); or x,y,z (length).
        See quantity for possible angle formats.


        Input Parameters:
        	rf		 reference code ITRF 
        	v0		 longitude or x 
        	v1		 latitude or y 
        	v2		 height or z 
        	off		 optional offset baseline measure 
        	
        Example:
        	

        print '	----	 Ex 2 	----'
        print me.baseline('itrf','30deg','40deg','10m')
        #{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
        # 'm1': {'value': 0.6981317007977319, 'unit': 'rad'},
        # 'm2': {'value': 9.9999999999999982, 'unit': 'm'},
        # 'refer': 'ITRF',
        # 'type': 'baseline'}
        print me.doframe(me.observatory('atca'))
        print me.doframe(me.source('1934-638'))
        print me.doframe(me.epoch('utc',qa.unit('today')))
        print me.measure(me.baseline('itrf','30deg','40deg','10m'), 'J2000')
        #{'m0': {'value': 0.58375325605991979, 'unit': 'rad'},
        # 'm1': {'value': 0.69758519780286155, 'unit': 'rad'},
        # 'm2': {'value': 9.9999999999999964, 'unit': 'm'},
        # 'refer': 'J2000',
        # 'type': 'baseline'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_baseline(self, *args, **kwargs)

    def asbaseline(self, *args, **kwargs):
        """
        asbaseline(self, pos) -> record *

        Summary
        	define a baseline from a position measure

        Description
        	
        asbaseline converts a position measure into a baseline measure. No
        actual baseline is calculated, since operations can be done on
        positions, with subtractions to obtain baselines at a later stage.


        Input Parameters:
        	pos		 position measure 
        	
        Example:
        	

        print '	----	 asbaseline Ex 1 	----'

        ####An example of getting baselines with 3 antenna positions
        #### Define the frame ; where, which-direction and when
        me.doframe(me.observatory('VLA'))
        me.doframe(me.direction('J2000', '19h20m00', '20d10m00'))
        me.doframe(me.epoch('utc', '2007/07/08/20:30:00'))

        ##antenna position
        ants=me.position('itrf',qa.quantity([3828763.11,3828746.55, 3828727.43],'m'), qa.quantity([442449.106,442592.14, 442580.12],'m'), qa.quantity([5064923.01, 5064923.01, 5064923.51],'m')) 
        print ants
        #{'type': 'position', 'refer': 'ITRF', 'm1': {'value': array([ 0.92031276,  0.92031276,  0.92031535]), 'unit': 'rad'}, 
        #'m0': {'value': array([ 0.11504897,  0.11508633,  0.1150838 ]), 'unit': 'rad'}, 
        #'m2': {'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587]), 'unit': 'm'}}

        bl=me.asbaseline(ants)
        print bl
        #{'type': 'baseline', 'refer': 'J2000', 'm1': {'value': array([ 0.92068328,  0.92068326,  0.92068585]), 'unit': 'rad'}, 
        #'m0': {'value': array([-2.08658811, -2.08655073, -2.08655326]), 'unit': 'rad'}, 
        #'m2': {'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587]), 'unit': 'm'}}

        me.expand(bl)

        #{'return': {'m0': {'unit': 'rad',
        #                  'value': array([-0.51637894, -0.36575235,  1.50036599])},
        #            'm1': {'unit': 'rad',
        #                   'value': array([-0.00060966,  0.00302388,  0.02206414])},
        #            'm2': {'unit': 'm',
        #                   'value': array([ 143.98943974,  135.78652583,   22.58992696])},
        #            'refer': 'J2000',
        #            'type': 'baseline'},
        # 'xyz': {'unit': 'm',
        #         'value': array([  1.25215025e+02,  -7.10925354e+01,  -8.77850493e-02,
        #         1.26804339e+02,  -4.85640980e+01,   4.10601842e-01,
        #         1.58931410e+00,   2.25284374e+01,   4.98386892e-01])}}




        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_asbaseline(self, *args, **kwargs)

    def listcodes(self, *args, **kwargs):
        """
        listcodes(self, ms) -> record *

        Summary
        	get known reference codes

        Description
        	
        listcodes will produce the known reference codes for a specified measure
        type. It will return a record with two entries. The first is a string vector
        of all normal codes; the second a string vector (maybe empty) with all extra
        codes (like planets).


        Input Parameters:
        	ms		 the measure type for which to list 
        	
        Example:
        	

        print '	----	 listcodes Ex 1 	----'
        # Generate some direction
        # Note that an empty or non-specified reference code will produce the
        # measure with the default code for that measure type
        a=me.direction()
        print me.getref(a)
        #'J2000'
        print me.ismeasure(a)
        #True
        # Get the known reference codes for direction
        print me.listcodes(a)
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN',
        #'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
        #'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
        #'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'],
        #'extra': ['MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS',
        #'NEPTUNE', 'PLUTO', 'SUN', 'MOON', 'COMET']}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_listcodes(self, *args, **kwargs)

    def measure(self, *args, **kwargs):
        """
        measure(self, v, rf, off=initialize_record("")) -> record *

        Summary
        	convert a measure to another reference

        Description
        	
        measure converts measures (epoch, direction etc.) from one reference to
        another. It will, for instance, convert a direction from J2000 to AZEL
        representation. \
        Its arguments are a measure, an output reference code (see the individual
        measures for the allowable codes (direction,
        position,
        epoch,
        frequency,
        doppler,
        radialvelocity,
        baseline,
        uvw,
        earthmagnetic)), and an optional offset of
        the same type as the main measure. The offset will be subtracted from the
        result before it is returned.\
        In some cases (see the individual measures for when), more information than
        just a reference code is necessary. E.g. the above example of a conversion to
        AZEL, needs to know for when, and where on Earth we want it. This information
        is stored in a reference frame. Measures are set in the reference frame with
        the doframe function. The frame is tool
         wide.\

        {f IMPORTANT NOTE:}\
        To get an accurate conversion of solar system objects direction to a celestial frame, one should convert to AZEL or HADEC before to get parallax accounted for. Thus if you want to get the moon's position in J2000..one would do it in 2 stages\
        i.e (after setting the appropriate frames) \

        moonazel=me.measure(me.direction('moon'), 'AZELGEO')
        moonJ2000=me.measure(moonazel, 'J2000')




        Input Parameters:
        	v		 measure to be converted 
        	rf		 output reference code 
        	off		 optional output offset measure 
        	
        Example:
        	

        print '	----	 measure Ex 1 	----'
        a = me.epoch('utc','today') 			        # a time
        print a
        #{'m0': {'value': 54054.872957673608, 'unit': 'd'},
        # 'refer': 'UTC',
        # 'type': 'epoch'}
        print me.doframe(me.source('1934-638'))
        print me.measure(a, 'tai')					# convert to IAT
        #{'m0': {'value': 54054.873339618054, 'unit': 'd'},
        # 'refer': 'TAI',
        # 'type': 'epoch'}
        print me.doframe(a)						# set time in frame
        #True
        print me.doframe(me.observatory('ALMA'))			# set position in frame
        #True
        b=me.direction('j2000', qa.toangle('0h'), '-30deg')  # a direction
        print b
        #{'m0': {'value': 0.0, 'unit': 'rad'},
        # 'm1': {'value': -0.52359877559829882, 'unit': 'rad'},
        # 'refer': 'J2000',
        # 'type': 'direction'}
        print me.measure(b, 'azel')					# convert to AZEL
        #{'m0': {'value': 1.9244096810822324, 'unit': 'rad'},
        # 'm1': {'value': 0.76465385681363052, 'unit': 'rad'},
        # 'refer': 'AZEL',
        # 'type': 'direction'}
        print qa.angle(me.getvalue(me.measure(b,'azel'))['m0'])     # show as angles
        #['+110.15.38']
        print qa.angle(me.getvalue(me.measure(b,'azel'))['m1'])
        #['+043.48.41']


        Another example:

        print '	----	 measure Ex 2 	----'
        # Fill the frame with necessary information
        print me.doframe(me.epoch('utc','today'))
        #True
        print me.doframe(me.observatory('ALMA'))
        #True
        print me.doframe(me.direction('mars'))
        #True
        a=qa.unit('1GHz')
        print a
        #{'value': 1.0, 'unit': 'GHz'}
        m=me.frequency('lsrk',qa.quantity(qa.getvalue(a),qa.getunit(a)))
        print m
        #{'m0': {'value': 1000000000.0, 'unit': 'Hz'},
        # 'refer': 'LSRK',
        # 'type': 'frequency'}
        print me.measure(m,'lsrd')
        #{'m0': {'value': 1000001766.3928765, 'unit': 'Hz'},
        # 'refer': 'LSRD',
        # 'type': 'frequency'}



        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_measure(self, *args, **kwargs)

    def doframe(self, *args, **kwargs):
        """
        doframe(self, v) -> bool

        Summary
        	save a measure as frame reference

        Description
        	
        doframe will set the measure specified as part of a frame. 

        If conversion from one type to another is necessary,  with the
        measure function,
         the following frames
        should be set if one of the reference types involved in the conversion is as
        in the following lists.\
        {m Epoch}

         UTC		
         TAI
         LAST	position
         LMST 	position
         GMST1 
         GAST 
         UT1 
         UT2 
         TDT 
         TCG 
         TDB 
         TCD
         
        {m Direction}

         J2000
         JMEAN		epoch 
         JTRUE 		epoch
         APP 		epoch
         B1950 
         BMEAN 		epoch
         BTRUE 		epoch
         GALACTIC 	
         HADEC 		epoch	position
         AZEL		epoch 	position
         SUPERGALACTIC
         ECLIPTIC
         MECLIPTIC      epoch
         TECLIPTIC	epoch
         PLANET		epoch   [position]

        {m Position}

         WGS84
         ITRF

        {m Radial Velocity}

         LSRK 		direction
         LSRD 		direction
         BARY 		direction
         GEO 		direction	epoch
         TOPO 		direction	epoch	position
         GALACTO	direction

        {m Doppler}

         RADIO 
         OPTICAL 
         Z 
         RATIO 
         RELATIVISTIC 
         BETA 
         GAMMA

        {m Frequency}

         REST 		direction			radialvelocity
         LSRK 		direction
         LSRD 		direction
         BARY 		direction
         GEO 		direction	epoch
         TOPO 		direction	epoch	position
         GALACTO



        Input Parameters:
        	v		 measure to be set in frame 
        	
        Example:
        	

        print '	----	 doframe Ex 1 	----'
        a = me.epoch('utc', 'today') 			# a time
        print a
        #{'m0': {'value': 54054.91671484954, 'unit': 'd'},
        # 'refer': 'UTC',
        # 'type': 'epoch'}
        print me.doframe(a)					# set time in frame
        #True


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_doframe(self, *args, **kwargs)

    def framenow(self):
        """
        framenow(self) -> bool

        Summary
        	set the active frame time at now

        Description
        	
        framenow will fill the active frame time with the current date and time.
        The different frame values necessary are described in the
        doframe function

        Example:
        	

        print '	----	 framenow Ex 1 	----'
        print me.framenow()			# specify now as frame reference
        #True
        print me.showframe()	        # and show the current frame
        #'Frame: Epoch: 54054::22:01:42.2880'



        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_framenow(self)

    def showframe(self):
        """
        showframe(self) -> string

        Summary
        	show the currently active frame reference

        Description
        	
        showframe will display the currently active reference frame values  on the
        terminal.  The
        different frame values necessary are described in the
        doframe function.
        The frame is
        displayed on the terminal using the formatting as done for the 
        show function.

        Example:
        	

        print '	----	 showframe Ex 1 	----'
        print me.doframe(me.epoch('utc','today'))		# specify now as frame reference
        #T 
        print me.showframe()				# and show the current frame
        #'Frame: Epoch: 54054::22:01:42.2880'



        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_showframe(self)

    def toradialvelocity(self, *args, **kwargs):
        """
        toradialvelocity(self, rf, v0) -> record *

        Summary
        	convert a doppler type value to a real
        radial velocity

        Description
        	
        toradialvelocity will convert a Doppler type value (e.g. in radio mode) to a
        real radialvelocity. The type of velocity (e.g. LSRK) should be specified


        Input Parameters:
        	rf		 radial velocity reference type 
        	v0		 doppler value measure 
        	
        Example:
        	

        print '	----	 toradialvelocity Ex 1 	----'
        a = me.doppler('radio','0.4')
        print a
        #  Out[4]:
        #{'m0': {'value': 119916983.2, 'unit': 'm/s'},
        # 'refer': 'RADIO',
        # 'type': 'doppler'}
        print me.toradialvelocity('topo',a)
        #{'m0': {'value': 141078803.7647059, 'unit': 'm/s'},
        # 'refer': 'TOPO',
        # 'type': 'radialvelocity'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_toradialvelocity(self, *args, **kwargs)

    def tofrequency(self, *args, **kwargs):
        """
        tofrequency(self, rf, v0, rfq) -> record *

        Summary
        	convert a doppler type value to a frequency

        Description
        	
        tofrequency will convert a Doppler type value (e.g. in radio mode) to a
        frequency. The type of frequency (e.g. LSRK) and a rest frequency (either as a
        frequency quantity (e.g. qa.constants('HI')) or a frequency measure (e.g.
        me.frequency('rest','5100MHz')) should be specified


        Input Parameters:
        	rf		 frequency reference type 
        	v0		 doppler measure value 
        	rfq		 rest frequency (frequency measure or freuency quantity) 
        	
        Example:
        	

        print '	----	 tofrequency Ex 1 	----'
        a=me.doppler('radio','0.4')
        print a
        #{'m0': {'value': 119916983.2, 'unit': 'm/s'},
        # 'refer': 'RADIO',
        # 'type': 'doppler'}
        print me.tofrequency('lsrk',a,qa.constants('HI'))
        #{'m0': {'value': 852243451.07159996, 'unit': 'Hz'},
        # 'refer': 'LSRK',
        # 'type': 'frequency'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_tofrequency(self, *args, **kwargs)

    def todoppler(self, *args, **kwargs):
        """
        todoppler(self, rf, v0, rfq=initialize_variant("")) -> record *

        Summary
        	convert a frequency or radialvelocity measure
        to a doppler measure

        Description
        	
        todoppler will convert a radialvelocity measure or a frequency measure to a
        doppler measure. In the case of a frequency, a rest frequency has to be
        specified. The type of doppler wanted (e.g. RADIO) has to be specified.


        Input Parameters:
        	rf		 doppler reference type 
        	v0		 radial velocity or frequency measure 
        	rfq		 rest frequency (frequency measure or frequency quantity) 
        	
        Example:
        	

        print '	----	 todoppler Ex 1 	----'
        f = me.frequency('lsrk','1410MHz')     # specify a frequency
        print f
        #{'m0': {'value': 1410000000.0, 'unit': 'Hz'},
        # 'refer': 'LSRK',
        # 'type': 'frequency'}
        print me.todoppler('radio', f, qa.constants('HI')) # give doppler, using HI rest
        #{'m0': {'value': 2196249.8401180855, 'unit': 'm/s'},
        # 'refer': 'RADIO',
        # 'type': 'doppler'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_todoppler(self, *args, **kwargs)

    def torestfrequency(self, *args, **kwargs):
        """
        torestfrequency(self, v0, d0) -> record *

        Summary
        	convert a frequency and doppler measure
        to a rest frequency

        Description
        	
        torestfrequency will convert a frequency measure and a doppler measure
        (e.g. obtained from another spectral line with a known rest frequency) to a
        rest frequency.


        Input Parameters:
        	v0		 frequency reference type 
        	d0		 doppler measure value 
        	
        Example:
        	

        print '	----	 torestfrequency Ex 1 	----'
        dp = me.doppler('radio', '2196.24984km/s')  # a measured doppler speed 
        print dp
        #{'m0': {'value': 2196249.8399999999, 'unit': 'm/s'},
        # 'refer': 'RADIO',
        # 'type': 'doppler'}
        f = me.frequency('lsrk','1410MHz')    # a measured frequency
        print f
        #{'m0': {'value': 1410000000.0, 'unit': 'Hz'},
        # 'refer': 'LSRK',
        # 'type': 'frequency'}
        print me.torestfrequency(f, dp)                   # the corresponding rest frequency
        #{'m0': {'value': 1420405751.7854364, 'unit': 'Hz'},
        # 'refer': 'REST',
        # 'type': 'frequency'}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_torestfrequency(self, *args, **kwargs)

    def rise(self, *args, **kwargs):
        """
        rise(self, crd=initialize_variant(""), ev=initialize_variant("0.0deg")) -> record *

        Summary
        	get rise and set sidereal time

        Description
        	
        rise will give the rise/set hour-angles of a source. It needs the position
        in the frame, and a time. If the latter is not set, the current time will be
        used.


        Input Parameters:
        	crd		 direction of source (direction measure) 
        	ev		 elevation angle limit 0.0deg 
        	
        Example:
        	

        # NOT IMPLEMENTED
        print '	----	 rise Ex 1 	----'
        print me.rise(me.direction('sun'))
        #[rise=[value=267.12445, unit=deg], set=[value=439.029964, unit=deg]] 
        print qa.form.long(me.rise(me.direction('sun')).rise)
        #17:48:29.868 
        #


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_rise(self, *args, **kwargs)

    def riseset(self, *args, **kwargs):
        """
        riseset(self, crd, ev=initialize_variant("0.0deg")) -> record *

        Summary
        	get rise and set times 

        Description
        	
        rise will give the rise/set times of a source. It needs the position
        in the frame, and a time. If the latter is not set, the current time will be
        used. The returned value is a record with a 'solved' field, which is F if the
        source is always below or above the horizon. In that case the rise and set
        fields will all have a string value. The record also returns a rise and set
        record, with 'last' and 'utc' fields showing the rise and set times as epochs.


        Input Parameters:
        	crd		 direction of source (direction measure) 
        	ev		 elevation limit 0.0deg 
        	
        Example:
        	

        # NOT IMPLEMENTED
        print '	----	 riseset Ex 1 	----'
        print me.riseset(me.direction('sun'))                     
        #[solved=T,
        # rise=[last=[type=epoch, refer=LAST, m0=[value=0.0731388605, unit=d]],
        #       utc=[type=epoch, refer=UTC, m0=[value=52085.8964, unit=d]]],
        # set=[last=[type=epoch, refer=LAST, m0=[value=0.455732593, unit=d]],
        #       utc=[type=epoch, refer=UTC, m0=[value=52086.2779, unit=d]]]] 
        print me.riseset(me.direction('sun'), qa.unit('80deg'))                     
        #[solved=F,
        # rise=[last=below, utc=below],
        # set=[last=below, utc=below]] 
        print qa.form.long(me.riseset(me.direction('sun')).rise.utc.m0)  
        #21:30:47.439 
        #


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_riseset(self, *args, **kwargs)

    def posangle(self, *args, **kwargs):
        """
        posangle(self, m1, m2) -> record *

        Summary
        	get position angle of two directions

        Description
        	
        posangle will give the position angle from a direction to another. I.e. the
        angle in a direction between the direction to the North pole and the other
        direction. 
        The posiation angle is calculated in the frame of the first argument. m2 is thus converted to the frame of m1 before calculating the position angle.


        Input Parameters:
        	m1		 direction of source (direction measure) 
        	m2		 direction of other source (direction measure) 
        	
        Example:
        	

        print '	----	 posangle Ex 1 	----'
        a=me.direction('j2000','0deg','70deg')
        b=me.direction('j2000','0deg','80deg')
        print me.posangle(a,b)
        #{'value': -0.0, 'unit': 'deg'}
        print me.separation(a,b)
        #{'value': 9.9999999999999893, 'unit': 'deg'}
        tim=me.epoch('utc','today')
        print me.doframe(tim)
        #True
        pos=me.observatory('ATCA')
        print me.doframe(pos)
        #True
        print me.posangle(a,b)
        #{'value': -0.0, 'unit': 'deg'}

        ###Example of how to calculate the parallactic angle of a given direction on thesky.

        ###set the frames and epoch

         



        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_posangle(self, *args, **kwargs)

    def separation(self, *args, **kwargs):
        """
        separation(self, m1, m2) -> record *

        Summary
        	get separation angle between two directions

        Description
        	
        separation will give the separation of a direction from another as an angle.


        Input Parameters:
        	m1		 direction of source (direction measure) 
        	m2		 direction of other source (direction measure) 
        	
        Example:
        	

        print '	----	 separation Ex 1 	----'
        a=me.direction('j2000','0deg','70deg')
        b=me.direction('j2000','0deg','80deg')
        print me.separation(a,b)
        #{'value': 9.9999999999999893, 'unit': 'deg'}
        tim = me.epoch('utc','today')              # set the time
        print me.doframe(tim)
        #True
        pos = me.observatory('ATCA')               # set where
        print me.doframe(pos)
        #True
        c=me.measure(b,'azel')                     # try with different type
        print me.separation(a,c)
        #{'value': 10.000000000062277, 'unit': 'deg'}

        ### the example below is how to calculate 
        ### the parallactic angle 
        me.doframe(me.epoch('utc','2015/06/30/19:30:40')))
        me.doframe(me.observatory('ALMA'))
        mydir = me.direction('J2000','17h28m00','-28d00m00' )
        #convert direction to AZEL
        mydirazel=me.measure(mydir, 'AZEL')
        hadecpol=me.direction('HADEC', '00h00m00', '90d00m00')
        ### no need to convert north pole direction to AZEL
        ### as it will coverted to the frame of mydirazel
        parAngle=me.posangle(mydirazel, hadecpol)

        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_separation(self, *args, **kwargs)

    def addxvalue(self, *args, **kwargs):
        """
        addxvalue(self, a) -> record *

        Summary
        	get some additional measure information

        Description
        	
        addxvalue will give some additional information about some measures as a vector
        of quantities. It is used internally to get the rectangular coordinates of
        measures that are normally given in angles. The casual user will probably in
        general not interested in this function.


        Input Parameters:
        	a		 measures for which extra information is to be gotten 
        	
        Example:
        	

        print '	----	 addxvalue Ex 1 	----'
        a=me.observatory('atca')
        print a
        #{'m0': {'value': 2.6101423190348916, 'unit': 'rad'},
        # 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
        # 'm2': {'value': 6372960.2577234386, 'unit': 'm'},
        # 'refer': 'ITRF',
        # 'type': 'position'}
        print me.addxvalue(a)
        #{'value': [-4750915.8370000012, 2792906.1819999996, -3200483.747], 'unit': 'm'}
        print me.addxvalue(me.epoch('utc','today'))
        #{}


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_addxvalue(self, *args, **kwargs)

    def type(self):
        """
        type(self) -> string

        Summary
        	type of tool

        Description
        	
        type will return the tool name.

        Example:
        	

        print '	----	 type Ex 1 	----'
        print me.type()
        #'measures'


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_type(self)

    def done(self):
        """
        done(self) -> bool

        Summary
        	free resources used by tool.

        Description
        	
        In general you will not want to call this method.  It removes and then
        recreates the default measures tool.


        Example:
        	

        print '	----	 done Ex 1 	----'
        print me.done()
        #True


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_done(self)

    def ismeasure(self, *args, **kwargs):
        """
        ismeasure(self, v) -> bool

        Summary
        	Check if measure

        Description
        	
        Checks if the operand is a correct measure


        Input Parameters:
        	v		 value to be tested 
        	
        Example:
        	

        print '	----	 ismeasure Ex 1 	----'
        x=me.epoch('utc','today')
        print x
        #{'m0': {'value': 54056.043754386577, 'unit': 'd'},
        # 'refer': 'UTC',
        # 'type': 'epoch'}
        print me.ismeasure(x)
        #True
        y=me.getvalue(x)
        print y
        #{'m0': {'value': 54056.043754386577, 'unit': 'd'}}
        print me.ismeasure(y)
        #False
        print 'Last example, exiting!'
        exit()


        --------------------------------------------------------------------------------
        	      
        """
        return _measures.measures_ismeasure(self, *args, **kwargs)

measures_swigregister = _measures.measures_swigregister
measures_swigregister(measures)
cvar = _measures.cvar

# This file is compatible with both classic and new-style classes.


